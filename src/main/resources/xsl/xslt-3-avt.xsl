<?xml version="1.0" encoding="UTF-8"?>
<!-- This file was generated on Thu Jan 20, 2022 10:02 (UTC+01) by REx v5.55 which is Copyright (c) 1979-2022 by Gunther Rademacher <grd@gmx.net> -->
<!-- REx command line: xslt-3-avt.ebnf -xslt -tree -->

<xsl:stylesheet version="2.0"
                xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:p="http://www.nkutsche.com/avt-parser">
  <!--~
   ! The index of the lexer state for accessing the combined
   ! (i.e. level > 1) lookahead code.
  -->
  <xsl:variable name="p:lk" as="xs:integer" select="1"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the begin of the token that has been consumed.
  -->
  <xsl:variable name="p:b0" as="xs:integer" select="2"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the end of the token that has been consumed.
  -->
  <xsl:variable name="p:e0" as="xs:integer" select="3"/>

  <!--~
   ! The index of the lexer state for accessing the code of the
   ! level-1-lookahead token.
  -->
  <xsl:variable name="p:l1" as="xs:integer" select="4"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the begin of the level-1-lookahead token.
  -->
  <xsl:variable name="p:b1" as="xs:integer" select="5"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the end of the level-1-lookahead token.
  -->
  <xsl:variable name="p:e1" as="xs:integer" select="6"/>

  <!--~
   ! The index of the lexer state for accessing the code of the
   ! level-2-lookahead token.
  -->
  <xsl:variable name="p:l2" as="xs:integer" select="7"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the begin of the level-2-lookahead token.
  -->
  <xsl:variable name="p:b2" as="xs:integer" select="8"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the end of the level-2-lookahead token.
  -->
  <xsl:variable name="p:e2" as="xs:integer" select="9"/>

  <!--~
   ! The index of the lexer state for accessing the code of the
   ! level-3-lookahead token.
  -->
  <xsl:variable name="p:l3" as="xs:integer" select="10"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the begin of the level-3-lookahead token.
  -->
  <xsl:variable name="p:b3" as="xs:integer" select="11"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the end of the level-3-lookahead token.
  -->
  <xsl:variable name="p:e3" as="xs:integer" select="12"/>

  <!--~
   ! The index of the lexer state for accessing the token code that
   ! was expected when an error was found.
  -->
  <xsl:variable name="p:error" as="xs:integer" select="13"/>

  <!--~
   ! The index of the lexer state that points to the first entry
   ! used for collecting action results.
  -->
  <xsl:variable name="p:result" as="xs:integer" select="14"/>

  <!--~
   ! The codepoint to charclass mapping for 7 bit codepoints.
  -->
  <xsl:variable name="p:MAP0" as="xs:integer+" select="
    55, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 6, 18, 19, 20, 21, 22, 23, 23, 23, 23, 24, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 25, 23, 23, 23, 23, 23, 23,
    23, 23, 23, 26, 6, 27, 6, 23, 6, 28, 29, 30, 31, 32, 33, 34, 35, 36, 23, 23, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 23, 51, 52, 53, 6, 6
  "/>

  <!--~
   ! The codepoint to charclass mapping for codepoints below the surrogate block.
  -->
  <xsl:variable name="p:MAP1" as="xs:integer+" select="
    108, 124, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 156, 181, 181, 181, 181, 181, 214, 215, 213, 214, 214, 214, 214, 214, 214,
    214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
    214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
    214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 247, 261, 277, 293, 309, 331, 370, 386, 422, 422, 422, 414, 354, 346, 354, 346,
    354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 439, 439, 439, 439, 439, 439, 439, 315, 354, 354, 354, 354, 354, 354, 354,
    354, 400, 422, 422, 423, 421, 422, 422, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 422, 422, 422, 422, 422,
    422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 353, 354, 354, 354,
    354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 422, 55, 0,
    0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 17, 6, 18, 19, 20, 21, 22, 23, 23, 23, 23, 24, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 6, 23, 23, 25, 23, 23, 23,
    23, 23, 23, 23, 23, 23, 26, 6, 27, 6, 23, 23, 23, 23, 23, 23, 23, 6, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 6, 28, 29, 30, 31, 32,
    33, 34, 35, 36, 23, 23, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 23, 51, 52, 53, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 23, 23, 6, 6, 6, 6, 6,
    6, 6, 54, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54
  "/>

  <!--~
   ! The codepoint to charclass mapping for codepoints above the surrogate block.
  -->
  <xsl:variable name="p:MAP2" as="xs:integer+" select="
    57344, 63744, 64976, 65008, 65536, 983040, 63743, 64975, 65007, 65533, 983039, 1114111, 6, 23, 6, 23, 23, 6
  "/>

  <!--~
   ! The token-set-id to DFA-initial-state mapping.
  -->
  <xsl:variable name="p:INITIAL" as="xs:integer+" select="
    1, 2050, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60
  "/>

  <!--~
   ! The DFA transition table.
  -->
  <xsl:variable name="p:TRANSITION" as="xs:integer+" select="
    3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639,
    3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639,
    3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3584, 3604, 3605, 3588, 3621, 3639, 5648, 11881, 3806, 3655, 7364, 10933, 3671,
    3688, 3744, 3672, 12191, 6069, 3773, 3795, 4047, 3779, 3801, 3958, 8881, 3851, 3822, 3849, 3867, 3883, 12241, 3888, 4025, 3904, 3930, 3914, 11729, 3833,
    4088, 12297, 3757, 3946, 3986, 4014, 11871, 11881, 11876, 4002, 10947, 4041, 4063, 4079, 4104, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639,
    3639, 5294, 4123, 4136, 6521, 3621, 3639, 5648, 11881, 3806, 3655, 7364, 10933, 3671, 3688, 3744, 3672, 12191, 6069, 3773, 3795, 4047, 3779, 3801, 3958,
    8881, 3851, 3822, 3849, 3867, 3883, 12241, 3888, 4025, 3904, 3930, 3914, 11729, 3833, 4088, 12297, 3757, 3946, 3986, 4014, 11871, 11881, 11876, 4002, 10947,
    4041, 4063, 4079, 4104, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294, 4164, 3639, 4212, 4187, 3639, 5648, 11881, 3806, 4228, 7364,
    10933, 3671, 3688, 3744, 3672, 12191, 6069, 3773, 3795, 4047, 3779, 3801, 3958, 8881, 3851, 3822, 3849, 3867, 3883, 12241, 3888, 4025, 3904, 3930, 3914,
    11729, 3833, 4088, 12297, 3757, 3946, 3986, 4014, 11871, 11881, 11876, 4002, 10947, 4041, 4063, 4079, 4104, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639,
    3639, 3639, 3639, 4244, 4264, 6846, 5455, 3621, 3639, 5648, 11881, 3806, 3655, 7364, 10933, 3671, 3688, 3744, 3672, 12191, 6069, 3773, 3795, 4047, 3779,
    3801, 3958, 8881, 3851, 3822, 3849, 3867, 3883, 12241, 3888, 4025, 3904, 3930, 3914, 11729, 3833, 4088, 12297, 3757, 3946, 3986, 4014, 11871, 11881, 11876,
    4002, 10947, 4041, 4063, 4079, 4104, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 4283, 4304, 5256, 4324, 3621, 3639, 5648, 11881,
    3806, 3655, 7364, 10933, 3671, 3688, 3744, 3672, 12191, 6069, 3773, 3795, 4047, 3779, 3801, 3958, 8881, 3851, 3822, 3849, 3867, 3883, 12241, 3888, 4025,
    3904, 3930, 3914, 11729, 3833, 4088, 12297, 3757, 3946, 3986, 4014, 11871, 11881, 11876, 4002, 10947, 4041, 4063, 4079, 4104, 3639, 3639, 3639, 3639, 3639,
    3639, 3639, 3639, 3639, 3639, 3639, 5294, 3638, 3639, 5455, 3621, 3639, 5648, 11881, 3806, 3655, 7364, 10933, 3671, 3688, 3744, 3672, 12191, 6069, 3773,
    3795, 4047, 3779, 3801, 3958, 8881, 3851, 3822, 3849, 3867, 3883, 12241, 3888, 4025, 3904, 3930, 3914, 11729, 3833, 4088, 12297, 3757, 3946, 3986, 4014,
    11871, 11881, 11876, 4002, 10947, 4041, 4063, 4079, 4104, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294, 4372, 3639, 3970, 4395,
    3639, 5648, 11881, 3806, 4435, 7364, 10933, 3671, 3688, 3744, 3672, 12191, 6069, 3773, 3795, 4047, 3779, 3801, 3958, 8881, 3851, 3822, 3849, 3867, 3883,
    12241, 3888, 4025, 3904, 3930, 3914, 11729, 3833, 4088, 12297, 3757, 3946, 3986, 4014, 11871, 11881, 11876, 4002, 10947, 4041, 4063, 4079, 4104, 3639, 3639,
    3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 4451, 4467, 4483, 4499, 4536, 3639, 5648, 11881, 3806, 4575, 7364, 10933, 3671, 3688, 3744, 3672,
    12191, 6069, 3773, 3795, 4047, 3779, 3801, 3958, 8881, 3851, 3822, 3849, 3867, 3883, 12241, 3888, 4025, 3904, 3930, 3914, 11729, 3833, 4088, 12297, 3757,
    3946, 3986, 4014, 11871, 11881, 11876, 4002, 10947, 4041, 4063, 4079, 4104, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 4591, 4614,
    4624, 4640, 4669, 3639, 5648, 11881, 3806, 4721, 7364, 10933, 3671, 3688, 3744, 3672, 12191, 6069, 3773, 3795, 4047, 3779, 3801, 3958, 8881, 3851, 3822,
    3849, 3867, 3883, 12241, 3888, 4025, 3904, 3930, 3914, 11729, 3833, 4088, 12297, 3757, 3946, 3986, 4014, 11871, 11881, 11876, 4002, 10947, 4041, 4063, 4079,
    4104, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 4737, 4761, 4770, 5354, 3621, 3639, 5648, 11881, 3806, 3655, 7364, 10933, 3671,
    4786, 3744, 3672, 12191, 6069, 3773, 3795, 6291, 3779, 3801, 3958, 8881, 3851, 3822, 3849, 3867, 3883, 12241, 3888, 4025, 3904, 3930, 3914, 11729, 3833,
    4088, 12297, 3757, 3946, 3986, 4014, 11871, 11881, 11876, 4002, 10947, 4041, 4063, 4079, 4104, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639,
    3639, 5294, 4802, 4822, 4806, 3621, 3639, 5648, 11881, 3806, 3655, 7364, 10933, 3671, 3688, 3744, 3672, 11739, 6069, 3773, 3795, 4047, 3779, 3801, 3958,
    8881, 3851, 3822, 3849, 3867, 3883, 12241, 3888, 4025, 3904, 3930, 3914, 11729, 3833, 4088, 12297, 3757, 3946, 3986, 4014, 11871, 11881, 11876, 4002, 10947,
    4041, 4063, 4079, 4104, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 4850, 4875, 4885, 9995, 3621, 3639, 5648, 11881, 3806, 3655, 7364,
    10933, 3671, 3688, 3744, 3672, 12191, 6069, 3773, 3795, 4047, 3779, 3801, 3958, 8881, 3851, 3822, 3849, 3867, 3883, 12241, 3888, 4025, 3904, 3930, 3914,
    11729, 3833, 4088, 12297, 3757, 3946, 3986, 4014, 11871, 11881, 11876, 4002, 10947, 4041, 4063, 4079, 4104, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639,
    3639, 3639, 3639, 5294, 4901, 4921, 4905, 4958, 3639, 6078, 7334, 10368, 3635, 3639, 10816, 7425, 10818, 5008, 5009, 9473, 3639, 7423, 7425, 9419, 5009,
    5009, 8108, 7999, 7425, 7620, 5009, 7125, 8737, 6085, 7456, 9138, 7424, 5026, 7803, 6082, 7622, 6594, 5049, 5103, 9348, 5126, 7781, 5142, 9693, 6954, 5158,
    7614, 8028, 8032, 7899, 7046, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294, 3638, 3639, 8485, 4958, 3639, 6078, 7334, 4705, 3635,
    3639, 10816, 7425, 10818, 5008, 5009, 11799, 3639, 7423, 7425, 9419, 5009, 5009, 8108, 7999, 7425, 7620, 5009, 7125, 6082, 6085, 5009, 7125, 7424, 7620,
    6664, 6082, 7622, 11256, 6086, 6663, 6084, 12127, 7618, 10249, 9693, 6954, 7618, 7614, 8028, 8032, 7899, 7046, 3639, 3639, 3639, 3639, 3639, 3639, 3639,
    3639, 3639, 3639, 3639, 5294, 3638, 8395, 5283, 3621, 3639, 6229, 11881, 3806, 3655, 7364, 10933, 3671, 3688, 3744, 3672, 12191, 6069, 3773, 3795, 4047,
    3779, 3801, 3958, 8881, 3851, 3822, 3849, 3867, 3883, 12241, 3888, 4025, 3904, 3930, 3914, 11729, 3833, 4088, 12297, 3757, 3946, 3986, 4014, 11871, 11881,
    11876, 4002, 10947, 4041, 4063, 4079, 4104, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5185, 5205, 3639, 4148, 7313, 3639, 6078,
    7334, 11550, 3635, 3639, 10816, 7425, 10818, 5008, 5009, 8712, 3639, 7423, 7425, 9419, 5009, 5009, 5250, 7999, 7425, 7620, 5009, 7125, 6082, 6085, 5009,
    7125, 7424, 7620, 6664, 6082, 7622, 11256, 6086, 6663, 6084, 12127, 7618, 10249, 9693, 6954, 7618, 7614, 8028, 8032, 7899, 7046, 3639, 3639, 3639, 3639,
    3639, 3639, 3639, 3639, 3639, 3639, 3639, 5272, 5313, 5324, 9159, 5340, 3639, 6195, 6202, 5572, 5390, 7364, 11140, 5406, 5437, 5471, 5513, 5551, 6069, 5529,
    5700, 5722, 5484, 5567, 5627, 9091, 5712, 5588, 5615, 5670, 5686, 8691, 5738, 5599, 5763, 5421, 5838, 8681, 5924, 5747, 11154, 5497, 5779, 5810, 5540, 5914,
    5867, 5862, 5826, 5794, 5854, 5883, 5899, 5940, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294, 5960, 5971, 10069, 3621, 5987, 5648,
    11881, 3806, 3655, 7364, 10933, 3671, 3688, 3744, 3672, 12191, 6069, 3773, 3795, 4047, 3779, 3801, 3958, 8881, 3851, 3822, 3849, 3867, 3883, 12241, 3888,
    4025, 3904, 3930, 3914, 11729, 3833, 4088, 12297, 3757, 3946, 3986, 4014, 11871, 11881, 11876, 4002, 10947, 4041, 4063, 4079, 4104, 3639, 3639, 3639, 3639,
    3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294, 6007, 6021, 11481, 6055, 6102, 5648, 11881, 3806, 3655, 7364, 10933, 3671, 3688, 3744, 3672, 12191, 6069,
    3773, 3795, 4047, 3779, 3801, 3958, 8881, 3851, 3822, 3849, 3867, 3883, 12241, 3888, 4025, 3904, 3930, 3914, 11729, 3833, 4088, 12297, 3757, 3946, 3986,
    4014, 11871, 11881, 11876, 4002, 10947, 4041, 4063, 4079, 4104, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294, 6122, 6133, 6169,
    3621, 5451, 6284, 11881, 3806, 3655, 7364, 10933, 3671, 3688, 3744, 3672, 12191, 6069, 3773, 3795, 4047, 3779, 3801, 3958, 8881, 3851, 3822, 3849, 3867,
    3883, 12241, 3888, 4025, 3904, 3930, 3914, 11729, 3833, 4088, 12297, 3757, 3946, 3986, 4014, 11871, 11881, 11876, 4002, 10947, 4041, 4063, 4079, 4104, 3639,
    3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294, 6149, 6185, 6346, 3621, 3639, 5648, 11881, 3806, 3655, 7364, 10933, 3671, 3688, 3744,
    3672, 12191, 6069, 3773, 3795, 4047, 3779, 3801, 3958, 8881, 3851, 3822, 3849, 3867, 3883, 12241, 3888, 4025, 3904, 3930, 3914, 11729, 3833, 4088, 12297,
    3757, 3946, 3986, 4014, 11871, 11881, 11876, 4002, 10947, 4041, 4063, 4079, 4104, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294,
    3638, 3639, 6479, 3621, 3639, 5648, 11881, 3806, 3655, 7364, 10933, 3671, 3688, 3744, 3672, 12191, 6069, 3773, 3795, 4047, 3779, 3801, 3958, 8881, 3851,
    3822, 3849, 3867, 3883, 12241, 3888, 4025, 3904, 3930, 3914, 11729, 3833, 4088, 12297, 3757, 3946, 3986, 4014, 11871, 11881, 11876, 4002, 10947, 4041, 4063,
    4079, 4104, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294, 6218, 4308, 11762, 4745, 3639, 6078, 7334, 6665, 3635, 3639, 10026,
    7425, 10028, 5008, 5009, 6664, 3639, 6252, 7425, 10091, 5009, 5009, 6567, 7999, 7425, 7620, 5009, 7125, 6082, 6085, 5009, 7125, 7424, 7620, 6664, 6082,
    7622, 11256, 6086, 6663, 6084, 12127, 7618, 10249, 9693, 6954, 7618, 7614, 8028, 8032, 7899, 7046, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639,
    3639, 3639, 5294, 6218, 4308, 11762, 4745, 3639, 6078, 7334, 8578, 3635, 3639, 10026, 7425, 10028, 5008, 5009, 10112, 3639, 6252, 7425, 10091, 5009, 5009,
    6567, 7999, 7425, 7620, 5009, 7125, 6082, 6085, 5009, 7125, 7424, 7620, 6664, 6082, 7622, 11256, 6086, 6663, 6084, 12127, 7618, 10249, 9693, 6954, 7618,
    7614, 8028, 8032, 7899, 7046, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294, 6218, 7050, 6271, 4745, 3639, 6078, 7334, 6665, 3635,
    3639, 10026, 7425, 10028, 5008, 5009, 6664, 3639, 6252, 7425, 10091, 5009, 5009, 6567, 7999, 7425, 7620, 5009, 7125, 6082, 6085, 5009, 7125, 7424, 7620,
    6664, 6082, 7622, 11256, 6086, 6663, 6084, 12127, 7618, 10249, 9693, 6954, 7618, 7614, 8028, 8032, 7899, 7046, 3639, 3639, 3639, 3639, 3639, 3639, 3639,
    3639, 3639, 3639, 3639, 5294, 3638, 8473, 8513, 3621, 3639, 5648, 11881, 3806, 3655, 7364, 10933, 3671, 3688, 3744, 3672, 12191, 6069, 3773, 3795, 4047,
    3779, 3801, 3958, 8881, 3851, 3822, 3849, 3867, 3883, 12241, 3888, 4025, 3904, 3930, 3914, 11729, 3833, 4088, 12297, 3757, 3946, 3986, 4014, 11871, 11881,
    11876, 4002, 10947, 4041, 4063, 4079, 4104, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294, 6307, 6318, 4598, 3621, 3639, 5648,
    11881, 3806, 3655, 7364, 10933, 3671, 3688, 3744, 3672, 12191, 6069, 3773, 3795, 4047, 3779, 3801, 3958, 8881, 3851, 3822, 3849, 3867, 3883, 12241, 3888,
    4025, 3904, 3930, 3914, 11729, 3833, 4088, 12297, 3757, 3946, 3986, 4014, 11871, 11881, 11876, 4002, 10947, 4041, 4063, 4079, 4104, 3639, 3639, 3639, 3639,
    3639, 3639, 3639, 3639, 3639, 3639, 3639, 6334, 6362, 6373, 6389, 4745, 4107, 7256, 6426, 6467, 3635, 3639, 10026, 7425, 10028, 5008, 5009, 6664, 4267,
    6495, 7425, 11444, 5009, 5009, 6516, 6537, 10641, 10970, 6927, 8652, 6082, 11504, 5009, 6562, 8762, 7620, 6588, 6402, 6610, 6636, 6086, 6663, 6084, 12127,
    7618, 10249, 9693, 6954, 7618, 7614, 8028, 8032, 7899, 7046, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294, 6218, 4308, 11762,
    4745, 3639, 6078, 7334, 6665, 3635, 3639, 10026, 7425, 10028, 5008, 5009, 6664, 3639, 6252, 7425, 10091, 5009, 5009, 6567, 7999, 7425, 7620, 5009, 7125,
    7327, 6085, 6661, 7125, 7424, 7620, 6664, 6082, 7622, 11256, 6086, 6663, 6084, 12127, 7618, 10249, 11985, 6681, 7618, 7614, 8028, 8032, 7899, 7046, 3639,
    3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294, 6732, 6746, 6760, 7392, 3639, 6078, 9773, 6451, 3702, 3639, 6806, 7425, 10028, 6822, 5009,
    6664, 3639, 6862, 6897, 10091, 6913, 10316, 6567, 7999, 7425, 6951, 5009, 6970, 6082, 6085, 5009, 8080, 7495, 7620, 6991, 7016, 7622, 7007, 9019, 11032,
    6084, 12127, 7618, 10249, 11069, 9359, 7618, 7614, 8028, 8032, 7032, 7046, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294, 7066,
    7077, 7093, 4745, 7384, 10444, 7334, 7122, 4409, 6033, 7141, 7145, 10028, 7161, 6881, 6664, 3639, 6252, 7425, 10091, 5009, 5009, 6567, 4337, 7425, 8629,
    5009, 7125, 6082, 6709, 5009, 7179, 9667, 10391, 6664, 6082, 7622, 11256, 6086, 6663, 6084, 12127, 7618, 9509, 7200, 9499, 7618, 7614, 8028, 8032, 7899,
    7046, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294, 7216, 7227, 7243, 4745, 8999, 9266, 7283, 7350, 11396, 5297, 11310, 4520,
    7408, 7442, 11227, 7480, 12349, 7524, 7560, 7601, 6440, 7638, 7678, 8825, 6500, 12007, 8558, 7125, 9620, 6085, 7703, 10048, 6695, 7620, 7725, 7767, 7819,
    7835, 10140, 7930, 9813, 12075, 7875, 7915, 10531, 7956, 7972, 7614, 9783, 8020, 7899, 7046, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639,
    3639, 5294, 6218, 5189, 8048, 4419, 3639, 4859, 7334, 8077, 3635, 3639, 10026, 7425, 10028, 5008, 5009, 6664, 3639, 6252, 7425, 8096, 5009, 7709, 6567,
    7999, 7425, 7620, 5009, 10837, 6082, 6790, 5009, 8130, 7424, 7620, 6664, 6082, 7622, 11256, 6086, 6663, 6084, 12127, 7618, 10249, 9693, 6954, 7618, 7614,
    9949, 8782, 8151, 7046, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294, 8206, 8217, 8233, 4745, 3639, 6078, 7334, 6665, 3635, 3639,
    10026, 7425, 10028, 5008, 5009, 6664, 3639, 6252, 7425, 10091, 5009, 5009, 6567, 7999, 7425, 7620, 5009, 7125, 6082, 6085, 5009, 7125, 7424, 7620, 6664,
    6082, 7622, 11256, 8269, 8294, 7945, 9546, 7618, 10249, 9693, 6954, 7618, 7614, 8028, 5075, 7899, 7046, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639,
    3639, 3639, 3639, 5294, 6218, 4308, 11762, 10995, 3639, 8416, 5374, 6665, 4550, 3639, 10026, 7425, 7508, 5008, 5009, 8332, 3639, 6252, 7425, 10091, 5009,
    5009, 6567, 7999, 7425, 7620, 5009, 7125, 6082, 9673, 5009, 8357, 7424, 7620, 6664, 6082, 7622, 11256, 6086, 6663, 11687, 12108, 7618, 10249, 9693, 6954,
    7618, 7614, 8028, 8032, 7899, 7046, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 8382, 8432, 8444, 8460, 4745, 9990, 9580, 12050, 6665,
    3635, 8501, 8529, 11325, 8941, 8552, 8574, 11716, 8114, 6252, 7425, 8594, 5009, 11109, 6567, 4512, 7425, 9290, 5009, 7125, 6082, 8622, 4356, 11900, 7740,
    8645, 8668, 6082, 8707, 8728, 6086, 6663, 6084, 12127, 7618, 9555, 8753, 6954, 7618, 7888, 8778, 8032, 8798, 7046, 3639, 3639, 3639, 3639, 3639, 3639, 3639,
    3639, 3639, 3639, 3639, 5294, 8841, 8852, 8868, 11404, 4933, 7687, 8536, 6665, 3635, 3639, 10026, 8897, 7267, 8917, 5009, 11603, 3639, 8933, 8957, 10091,
    8977, 5009, 6567, 7999, 7425, 7620, 5009, 7125, 6082, 6085, 5009, 7125, 9015, 9918, 6664, 6082, 7622, 7653, 11330, 11235, 6084, 12127, 7618, 10249, 9693,
    6954, 9035, 9962, 8028, 5063, 7899, 7046, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294, 9051, 9062, 9078, 4745, 3639, 4559, 8316,
    6665, 3635, 3639, 9107, 6255, 8190, 9131, 7464, 8166, 9154, 9175, 6782, 10091, 9216, 9239, 11612, 3728, 7426, 10413, 5009, 9257, 6082, 6085, 5009, 7125,
    7424, 7620, 6664, 6082, 7622, 11256, 6086, 6663, 6084, 11572, 6872, 9282, 9693, 6954, 7618, 7614, 8028, 8032, 7899, 7046, 3639, 3639, 3639, 3639, 3639,
    3639, 3639, 3639, 3639, 3639, 3639, 5294, 9306, 9317, 9333, 4834, 7106, 10694, 6410, 9385, 3635, 3639, 10026, 9413, 10028, 5008, 9435, 9438, 3639, 6252,
    7425, 10091, 5009, 5009, 6975, 7999, 10647, 9466, 6935, 11965, 9454, 9489, 9533, 9571, 8309, 6716, 6664, 7662, 9596, 9636, 9852, 9652, 9910, 9689, 9709,
    9369, 9763, 9799, 7618, 7614, 6620, 8032, 7585, 7046, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 9829, 9868, 9879, 9895, 4745, 4171,
    4683, 9934, 9978, 3635, 3639, 10026, 7425, 10011, 5008, 5009, 10044, 6572, 6252, 7425, 10551, 5009, 5009, 10064, 7999, 10085, 7620, 10107, 7125, 6082, 6085,
    5009, 7125, 10128, 12100, 10156, 6082, 7622, 11256, 6086, 6663, 10200, 12127, 10216, 7859, 10244, 6954, 7618, 7614, 8028, 8032, 10184, 7046, 3639, 3639,
    3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294, 6218, 5944, 10265, 4745, 3639, 6078, 7334, 6665, 3635, 3639, 10628, 8004, 8901, 10304, 4992,
    11937, 3639, 6252, 7425, 10091, 5009, 5009, 8341, 7999, 10342, 7620, 10364, 7125, 6082, 10384, 9241, 7125, 7424, 7620, 6664, 6082, 7622, 11256, 6086, 6663,
    6084, 12127, 7618, 10249, 9693, 6954, 7618, 7614, 8028, 8032, 7899, 7046, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294, 6218,
    4308, 11762, 4745, 8407, 8366, 10574, 6665, 3635, 3639, 10026, 7425, 10028, 5008, 5009, 6664, 3639, 6252, 7425, 10091, 5009, 5009, 6567, 7999, 7425, 7620,
    5009, 7125, 6082, 6085, 5009, 7125, 7424, 7620, 6664, 6082, 7622, 11256, 10407, 10429, 6084, 12127, 7618, 10249, 9693, 6954, 7618, 7614, 8028, 8032, 7899,
    7046, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294, 10460, 10471, 10487, 4745, 4288, 4972, 10518, 7987, 3635, 3639, 10567, 10590,
    10613, 10663, 5009, 10679, 3639, 10710, 7425, 10348, 11648, 5009, 8135, 7999, 7751, 7620, 9200, 7125, 6082, 6085, 5009, 7125, 7424, 7620, 6664, 8246, 7538,
    11256, 6086, 6663, 6084, 11350, 10865, 10726, 5033, 7849, 7618, 7614, 10758, 10750, 7899, 7046, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639,
    3639, 5294, 10774, 10785, 10801, 9397, 5225, 10502, 7334, 10834, 3716, 5991, 10853, 12043, 10028, 10891, 11026, 6664, 3639, 6252, 7425, 10091, 5009, 5009,
    7184, 5367, 9115, 4697, 10875, 10918, 6082, 10963, 7544, 10986, 8181, 11011, 7298, 6082, 7622, 5110, 11527, 5169, 6084, 12127, 11048, 10249, 9223, 11064,
    11928, 11085, 8028, 8032, 7899, 7046, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 11125, 11170, 11184, 11198, 4745, 7375, 5234, 11214,
    11251, 3635, 11381, 11272, 12033, 11295, 11346, 11100, 11366, 6106, 11420, 10544, 9188, 11460, 5010, 11476, 11497, 11520, 11543, 11566, 8813, 8061, 11588,
    8606, 8989, 9844, 9517, 6664, 6773, 11637, 9611, 7574, 9724, 10171, 11674, 7618, 10249, 9693, 8278, 10288, 11703, 11755, 8032, 11778, 7046, 3639, 3639,
    3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294, 11815, 11826, 11842, 4745, 3639, 12358, 7334, 11897, 3635, 3639, 10026, 7425, 10028, 5008, 5009,
    6664, 4379, 11916, 7425, 11953, 11793, 11658, 6567, 7999, 7425, 7620, 5009, 7125, 6082, 6085, 5009, 7125, 10280, 9747, 6664, 6082, 7622, 11256, 6086, 6663,
    9739, 11981, 7618, 10249, 9693, 6954, 4347, 12001, 8028, 5087, 7899, 7046, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294, 6218,
    4308, 11762, 4745, 3639, 4942, 10597, 6665, 4201, 3639, 12023, 7425, 10028, 12066, 5009, 6664, 5216, 6252, 11435, 10091, 7163, 5009, 6567, 7999, 7425, 7620,
    5009, 7125, 6082, 6085, 5009, 7125, 7424, 7620, 6664, 6082, 7622, 11256, 6086, 6663, 6084, 12127, 7618, 10249, 9693, 6954, 7618, 7614, 8028, 8032, 7899,
    7046, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294, 6218, 4308, 11762, 4745, 3639, 6078, 4982, 10902, 3635, 3639, 10026, 7425,
    10028, 5008, 5009, 6664, 3639, 6252, 7425, 10091, 5009, 5009, 6567, 7999, 7425, 7620, 5009, 7125, 6645, 8961, 7792, 6837, 7424, 7620, 6664, 6082, 7622,
    11256, 6086, 6663, 6084, 12127, 7618, 10249, 9693, 6954, 7618, 7614, 8028, 8032, 7899, 7046, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639,
    3639, 5294, 6218, 4308, 11762, 4745, 5639, 11621, 8253, 6665, 3635, 3639, 10026, 7425, 11279, 5008, 5009, 10228, 3639, 6252, 7425, 10091, 5009, 5009, 6567,
    7999, 7425, 7620, 5009, 7125, 6082, 6085, 5009, 7125, 7424, 7620, 6664, 6082, 7622, 11256, 6086, 6663, 6084, 12127, 7618, 10249, 9693, 6954, 7618, 7614,
    8028, 8032, 7899, 7046, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294, 6218, 4308, 11762, 4745, 3639, 6078, 6546, 10326, 3635,
    3639, 10026, 7425, 10028, 5008, 5009, 6664, 3639, 6252, 7425, 10091, 5009, 5009, 6567, 4653, 12091, 10734, 12124, 7125, 6082, 6085, 5009, 7125, 7424, 7620,
    6664, 6082, 7622, 11256, 6086, 6663, 6084, 12127, 7618, 10249, 9693, 6954, 7618, 7614, 8028, 8032, 7899, 7046, 3639, 3639, 3639, 3639, 3639, 3639, 3639,
    3639, 3639, 3639, 3639, 12143, 12159, 12173, 4248, 3621, 3639, 12182, 6236, 3806, 3655, 7364, 5653, 3671, 3688, 5654, 3672, 12191, 6069, 3773, 3795, 4047,
    3779, 3801, 3958, 8881, 3851, 3822, 3849, 3867, 3883, 12241, 3888, 4025, 3904, 3930, 3914, 11729, 3833, 4088, 12297, 3757, 3946, 3986, 4014, 11871, 11881,
    11876, 4002, 10947, 4041, 4063, 4079, 4104, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294, 12207, 12218, 12318, 3621, 3639, 12234,
    11881, 3806, 3655, 7364, 10933, 3671, 3688, 3744, 3672, 12191, 6069, 3773, 3795, 4047, 3779, 3801, 3958, 8881, 3851, 3822, 3849, 3867, 3883, 12241, 3888,
    4025, 3904, 3930, 3914, 11729, 3833, 4088, 12297, 3757, 3946, 3986, 4014, 11871, 11881, 11876, 4002, 10947, 4041, 4063, 4079, 4104, 3639, 3639, 3639, 3639,
    3639, 3639, 3639, 3639, 3639, 3639, 3639, 6164, 12257, 12268, 6039, 3621, 3639, 5648, 11881, 3806, 3655, 7364, 11857, 3671, 3688, 12284, 3672, 12191, 6069,
    3773, 3795, 4047, 3779, 3801, 3958, 8881, 3851, 3822, 3849, 3867, 3883, 12241, 3888, 4025, 3904, 3930, 3914, 11729, 3833, 4088, 12297, 3757, 3946, 3986,
    4014, 11871, 11881, 11876, 4002, 10947, 4041, 4063, 4079, 4104, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 5294, 3638, 3639, 5455,
    4745, 3639, 6078, 7334, 6665, 3635, 3639, 10816, 7425, 10818, 5008, 5009, 6664, 3639, 7423, 7425, 9419, 5009, 5009, 6567, 7999, 7425, 7620, 5009, 7125,
    6082, 6085, 5009, 7125, 7424, 7620, 6664, 6082, 7622, 11256, 6086, 6663, 6084, 12127, 7618, 10249, 9693, 6954, 7618, 7614, 8028, 8032, 7899, 7046, 3639,
    3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 12313, 3639, 3639, 3639, 12334, 3639, 5648, 11881, 3806, 12374, 7364, 5653, 3671, 3688, 5654,
    3672, 12191, 6069, 3773, 3795, 4047, 3779, 3801, 3958, 8881, 3851, 3822, 3849, 3867, 3883, 12241, 3888, 4025, 3904, 3930, 3914, 11729, 3833, 4088, 12297,
    3757, 3946, 3986, 4014, 11871, 11881, 11876, 4002, 10947, 4041, 4063, 4079, 4104, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 3639, 0, 2109,
    10304, 10304, 10304, 10304, 10304, 10304, 10304, 10304, 10304, 10304, 10304, 10304, 10304, 10304, 2109, 0, 0, 10304, 73, 10304, 10304, 10304, 10304, 10304,
    10304, 10304, 10304, 10304, 10304, 10304, 10304, 10304, 10304, 10304, 10304, 0, 134144, 0, 0, 0, 0, 0, 0, 73, 73, 73, 76, 77, 139264, 0, 0, 73, 73, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 220160, 0, 73, 73, 0, 0, 0, 0, 0, 0, 0, 0, 194560, 0, 201728, 202752, 140288, 140288, 201728, 202752, 140288, 204800,
    140288, 208896, 140288, 210944, 212992, 140288, 140288, 140288, 218112, 140288, 221184, 221184, 140288, 140288, 140288, 140288, 140288, 140288, 140288,
    140288, 140288, 235520, 140288, 140288, 140288, 0, 0, 73, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 278, 0, 0, 73, 73, 0, 0, 0, 0, 0, 0, 0, 277, 0, 0, 0, 0, 389, 104,
    104, 104, 104, 104, 104, 104, 475, 104, 104, 104, 225, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 194560,
    140288, 140288, 140288, 140288, 200704, 206848, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 0, 207872, 140288, 0, 140288, 179200,
    140288, 140288, 140288, 140288, 140288, 140288, 189440, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 199680, 140288, 140288, 140288, 140288,
    140288, 199680, 140288, 140288, 140288, 140288, 140288, 211968, 214016, 215040, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288,
    140288, 140288, 140288, 0, 134144, 181248, 205824, 230400, 231424, 140288, 233472, 140288, 140288, 140288, 140288, 140288, 140288, 183296, 140288, 140288,
    140288, 140288, 140288, 140288, 140288, 140288, 186368, 140288, 140288, 191488, 140288, 140288, 140288, 140288, 192512, 140288, 140288, 140288, 140288,
    140288, 203776, 140288, 140288, 209920, 140288, 219136, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 230400, 231424, 140288, 233472,
    140288, 140288, 140288, 0, 0, 0, 0, 0, 0, 238592, 0, 236544, 0, 140288, 180224, 140288, 140288, 185344, 140288, 140288, 140288, 140288, 140288, 195584,
    140288, 140288, 140288, 140288, 140288, 140288, 140288, 0, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 196608, 140288, 140288, 140288,
    140288, 140288, 222208, 140288, 140288, 226304, 140288, 140288, 232448, 140288, 191488, 0, 0, 140288, 140288, 226304, 140288, 140288, 232448, 140288,
    140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 196608, 227328, 140288, 182272, 140288, 140288, 140288, 197632, 207872, 216064, 223232,
    140288, 227328, 140288, 140288, 140288, 140288, 0, 136192, 234496, 0, 0, 192512, 0, 203776, 0, 0, 0, 0, 0, 77, 77, 77, 77, 77, 77, 77, 2109, 0, 0, 0,
    182272, 140288, 140288, 140288, 197632, 207872, 216064, 223232, 140288, 227328, 140288, 140288, 140288, 0, 140288, 187392, 140288, 190464, 140288, 140288,
    140288, 140288, 140288, 140288, 140288, 140288, 140288, 190464, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 237568, 140288, 187392,
    140288, 140288, 140288, 140288, 140288, 140288, 236544, 140288, 238592, 0, 0, 196608, 0, 226304, 0, 0, 140288, 217088, 140288, 140288, 140288, 229376,
    140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 0, 0, 140288, 179200, 140288, 140288, 140288, 140288, 178176, 140288,
    140288, 140288, 140288, 228352, 178176, 140288, 140288, 140288, 140288, 228352, 140288, 198656, 224256, 140288, 140288, 198656, 224256, 140288, 188416,
    140288, 188416, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 0, 0, 0, 206848, 184320, 177152, 140288, 184320, 140288, 225280, 225280, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 170, 0, 0, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 81, 81, 81, 81, 81, 14417, 14417, 14417, 14417, 14417, 14417, 14417, 14417,
    14417, 0, 0, 0, 0, 0, 142, 142, 142, 142, 142, 142, 142, 2109, 0, 0, 0, 73, 0, 0, 0, 0, 0, 76, 0, 0, 0, 0, 0, 0, 0, 0, 0, 166, 0, 0, 0, 0, 171, 0, 0,
    134144, 0, 0, 0, 0, 0, 0, 73, 73, 73, 6294, 77, 139264, 0, 0, 73, 73, 0, 0, 0, 0, 0, 0, 276, 0, 0, 0, 0, 0, 76, 76, 76, 76, 76, 76, 76, 2109, 0, 0, 0,
    220160, 0, 73, 73, 0, 76, 0, 0, 0, 0, 0, 0, 194560, 0, 201728, 202752, 0, 2109, 0, 16384, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 2109, 0, 0, 73, 16384, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 386, 0, 0, 0, 2109, 0, 0, 17408, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 168, 0, 0, 0, 0, 73, 0, 17408, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 104, 123, 104, 104, 17408, 0, 0, 0, 0, 17408, 17408, 17408, 17408, 17408, 17408, 17408, 2109, 0, 0, 0, 0, 389, 104, 104, 104, 104, 472,
    104, 104, 104, 104, 104, 104, 104, 780, 104, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 562, 123, 123, 123, 123, 73, 0, 0, 0, 0, 0, 77, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 382, 0, 0, 0, 0, 0, 0, 0, 134144, 0, 0, 0, 0, 0, 0, 73, 73, 73, 76, 6295, 139264, 0, 0, 73, 73, 0, 0, 0, 0, 0, 275, 0, 0, 0, 0, 0, 0, 145,
    0, 73, 73, 73, 76, 77, 78, 0, 0, 220160, 0, 73, 73, 0, 0, 77, 0, 0, 0, 0, 0, 194560, 0, 201728, 202752, 0, 2109, 65, 65, 65, 18497, 65, 65, 65, 65, 65, 65,
    65, 65, 65, 65, 74, 18497, 65, 65, 65, 65, 65, 65, 65, 18497, 18497, 65, 65, 65, 65, 65, 18497, 65, 65, 65, 18497, 65, 65, 18497, 18497, 18497, 18497,
    18497, 65, 65, 18497, 65, 18497, 18497, 18497, 65, 18497, 18497, 18497, 18497, 18497, 18497, 18497, 18497, 2109, 0, 0, 0, 0, 389, 104, 104, 470, 104, 104,
    104, 104, 104, 104, 104, 104, 312, 104, 104, 104, 104, 104, 104, 104, 0, 134144, 0, 0, 0, 0, 0, 0, 147, 147, 147, 76, 77, 139264, 0, 0, 73, 73, 0, 0, 0, 0,
    274, 0, 0, 0, 0, 0, 0, 0, 104, 104, 104, 104, 104, 189, 104, 104, 104, 220160, 0, 147, 147, 0, 0, 0, 0, 0, 0, 0, 0, 194560, 0, 201728, 202752, 0, 2109, 0,
    0, 0, 0, 20480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45056, 0, 45056, 2109, 0, 0, 0, 73, 0, 20480, 20480, 20480, 0, 20480, 20480, 20480, 0, 20480, 20480, 20480,
    20480, 20480, 20480, 20480, 20480, 20480, 20480, 20480, 20480, 0, 0, 0, 0, 0, 20480, 0, 20480, 20480, 0, 0, 0, 20480, 0, 0, 20480, 2109, 0, 0, 0, 0, 389,
    104, 469, 104, 104, 104, 104, 104, 104, 104, 104, 477, 0, 134144, 0, 0, 0, 0, 0, 0, 73, 73, 30720, 76, 77, 139264, 0, 0, 171, 0, 0, 0, 0, 104, 104, 104,
    184, 187, 104, 193, 104, 104, 104, 104, 104, 493, 104, 495, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 26624, 134414, 0, 0, 220160, 0, 73,
    273408, 273408, 0, 0, 0, 0, 0, 0, 0, 194560, 0, 201728, 202752, 0, 2109, 0, 0, 0, 0, 0, 21504, 0, 0, 0, 0, 0, 0, 0, 0, 73, 73, 73, 76, 77, 78, 0, 0, 73, 0,
    0, 0, 0, 0, 0, 0, 0, 21504, 21504, 21504, 21504, 21504, 21504, 21504, 21504, 21504, 21504, 21504, 21504, 0, 12410, 0, 21504, 221184, 140288, 140288, 140288,
    140288, 140288, 140288, 140288, 140288, 140288, 235520, 140288, 140288, 140288, 0, 12288, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22528, 22528, 22528, 22528,
    22528, 2109, 0, 0, 0, 22528, 22528, 22528, 22528, 22528, 22528, 22528, 22528, 22528, 22528, 22528, 22528, 0, 0, 0, 0, 0, 144, 0, 0, 73, 73, 73, 76, 77, 78,
    0, 0, 0, 2109, 0, 0, 0, 0, 0, 0, 23552, 0, 0, 0, 0, 0, 0, 0, 104, 104, 104, 104, 104, 104, 104, 104, 198, 73, 0, 0, 23552, 0, 0, 0, 23552, 0, 0, 23552,
    23552, 23552, 23552, 23552, 23552, 23552, 23552, 23552, 23552, 23552, 23552, 0, 0, 0, 0, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24576, 24576, 24576, 24576,
    24576, 2109, 0, 0, 0, 24576, 24576, 24576, 24576, 24576, 24576, 24576, 24576, 24576, 24576, 24576, 24576, 0, 0, 0, 0, 0, 156, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    104, 104, 104, 104, 104, 191, 104, 104, 104, 0, 134144, 0, 0, 0, 0, 0, 0, 73, 73, 73, 76, 77, 78, 0, 0, 174, 0, 0, 0, 0, 104, 104, 180, 104, 104, 104, 104,
    104, 104, 217, 104, 104, 0, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 356, 123, 123, 123, 123, 123, 225, 123, 123, 123, 123, 123, 123, 123, 123,
    123, 123, 123, 123, 123, 123, 123, 123, 453, 104, 104, 104, 104, 596, 104, 104, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 104, 753, 104, 104, 104,
    104, 661, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 672, 123, 123, 104, 815, 104, 104, 104, 104, 123, 819, 123, 123, 123, 123, 104, 104,
    816, 817, 104, 104, 123, 123, 820, 821, 123, 123, 104, 104, 104, 104, 818, 104, 123, 123, 123, 123, 822, 123, 104, 104, 123, 675, 123, 123, 123, 123, 123,
    123, 123, 123, 123, 123, 123, 123, 0, 0, 657, 0, 0, 104, 104, 104, 104, 123, 123, 123, 123, 702, 123, 703, 704, 123, 123, 123, 123, 123, 0, 104, 711, 727,
    123, 123, 123, 0, 731, 104, 104, 104, 104, 104, 104, 104, 104, 104, 741, 774, 104, 104, 104, 104, 104, 104, 104, 104, 123, 783, 123, 123, 123, 123, 123,
    123, 123, 123, 123, 123, 682, 123, 123, 123, 0, 0, 0, 2109, 66, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 110, 129, 110, 110, 73, 0, 0, 0, 0, 0, 0, 0, 0, 66,
    66, 0, 0, 0, 0, 0, 0, 380, 0, 0, 0, 0, 0, 0, 0, 0, 0, 163, 0, 0, 0, 0, 0, 0, 0, 0, 104, 104, 181, 104, 104, 104, 104, 196, 201, 123, 123, 123, 123, 374,
    374, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17408, 0, 0, 0, 0, 0, 0, 2109, 0, 0, 0, 0, 0, 0, 0, 67, 68, 0, 0, 0, 0, 0, 0, 27751, 27751, 27751, 27751, 27751, 0, 2109,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 286, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29696, 29696, 29696, 29696, 29696, 29763, 29696, 29696, 29763, 29696,
    29696, 29763, 0, 0, 0, 0, 19456, 134144, 31744, 0, 0, 0, 0, 0, 148, 19605, 148, 76, 77, 139264, 0, 0, 21504, 21504, 21504, 12410, 12410, 12410, 12410,
    12410, 12410, 12410, 2109, 0, 0, 0, 0, 389, 468, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 0, 123, 123, 123, 230, 123, 123, 220160, 0, 273557, 148,
    0, 0, 0, 0, 0, 0, 0, 0, 194560, 0, 201728, 202752, 140465, 140465, 201905, 202929, 140465, 204977, 140465, 209073, 140465, 211121, 213169, 140465, 140465,
    140465, 218289, 140465, 140465, 226481, 140465, 140465, 232625, 140465, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 196832, 221361,
    140465, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 235697, 140465, 140465, 140465, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    2109, 0, 0, 0, 225, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 194784, 140512, 140512, 140512, 140512, 189664,
    140512, 140512, 140512, 140512, 140512, 140512, 140512, 199904, 140512, 140512, 140512, 140512, 200928, 207072, 140512, 140512, 140512, 140512, 140512,
    140512, 140512, 140512, 0, 207872, 140512, 201952, 202976, 140512, 205024, 140512, 209120, 140512, 211168, 213216, 140512, 140512, 140512, 218336, 140512,
    221408, 140288, 0, 140465, 179377, 140465, 140465, 140465, 140465, 140465, 140465, 189617, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 140465,
    237745, 140512, 187616, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 235744, 140512, 140512, 140512, 135168, 0, 0, 140512,
    140512, 212192, 214240, 215264, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 0, 134144, 181248, 205824,
    230577, 231601, 140465, 233649, 140465, 140465, 140465, 140512, 140512, 140512, 183520, 140512, 140512, 140512, 140512, 140512, 140512, 236768, 140512,
    238816, 0, 0, 196608, 0, 226304, 0, 0, 192736, 140512, 140512, 140512, 140512, 140512, 204000, 140512, 140512, 210144, 140512, 219360, 140512, 140512,
    140512, 140512, 0, 136192, 234496, 0, 0, 192512, 0, 203776, 0, 0, 0, 0, 0, 158, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 140288, 140288, 140288, 140288, 140288,
    140288, 140288, 140288, 140288, 140288, 140288, 194560, 140288, 140288, 140288, 140512, 140512, 230624, 231648, 140512, 233696, 140512, 140512, 140512, 0,
    0, 0, 0, 0, 0, 238592, 0, 236544, 0, 140465, 180401, 140465, 140465, 185521, 140465, 140465, 140465, 140465, 140465, 195761, 140465, 140465, 199857, 140465,
    140465, 140465, 140465, 140465, 212145, 214193, 215217, 140465, 140465, 140465, 140465, 140465, 203953, 140465, 140465, 210097, 140465, 219313, 140465,
    140465, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 0, 0, 140512, 179424, 140512, 140512, 140512, 140512, 185568, 140512, 140512,
    140512, 140512, 140512, 195808, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 0, 0, 0, 206848, 184320, 177329, 140465, 184497, 140465, 0, 140465,
    140465, 140465, 140465, 140465, 140465, 140465, 140465, 196785, 140465, 140465, 140465, 140465, 140465, 222385, 227328, 140465, 182449, 140465, 140465,
    140465, 197809, 208049, 216241, 223409, 140465, 227505, 140465, 140465, 140465, 140512, 140512, 140512, 229376, 140465, 140465, 193713, 140465, 217265,
    140465, 140465, 140465, 229553, 140512, 140512, 193760, 182496, 140512, 140512, 140512, 197856, 208096, 216288, 223456, 140512, 227552, 140512, 140512,
    140512, 0, 140465, 187569, 140465, 190641, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 140512, 140512, 190688, 140512, 140512, 140512, 140512,
    140512, 222432, 140512, 140512, 226528, 140512, 140512, 232672, 140512, 191488, 0, 0, 140512, 217312, 140512, 140512, 140512, 229600, 140465, 140465,
    140465, 140465, 140465, 140465, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 0, 140465, 140465, 140465, 140465, 140465,
    140465, 140512, 140512, 178353, 140465, 140465, 140465, 140465, 228529, 178400, 140512, 140512, 140512, 140512, 228576, 140465, 198833, 224433, 140465,
    140512, 198880, 224480, 140512, 188593, 140465, 188640, 140512, 140465, 140512, 140465, 140512, 140465, 140512, 140512, 140512, 237792, 0, 140465, 140465,
    140465, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 140512, 140512, 140512, 186592, 140512, 140512, 191712, 140512, 140512, 140512, 140512,
    225457, 225504, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 117, 136, 117, 117, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33874, 33874, 33874, 33874, 33874, 33874,
    33874, 33874, 33874, 33874, 33874, 33874, 0, 0, 0, 0, 0, 34816, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 285, 0, 287, 288, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 36864, 36864, 36864, 36864, 36864, 36965, 36965, 36965, 36965, 36965, 36965, 36965, 36965, 36965, 36965, 0, 0, 0, 0, 0, 281, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 111616, 111616, 63, 0, 2109, 0, 0, 134144, 0, 32768, 0, 0, 0, 0, 73, 73, 73, 76, 77, 139264, 0, 0, 179200, 189440, 0, 0, 0, 0, 215040, 0, 0, 0, 0, 0, 0,
    0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 123, 123, 123, 15360, 35840, 39936, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 385, 0,
    387, 388, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38995, 38995, 38995, 38995, 38995, 38995, 38995, 38995, 38995, 38995, 38995, 38995, 0, 0, 0, 0, 73, 0, 0, 0,
    41984, 0, 0, 0, 0, 0, 0, 0, 0, 0, 41984, 0, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38995, 2109, 0, 0, 0, 41984, 41984, 0, 0, 0, 0, 0, 0, 0, 41984, 0,
    0, 0, 0, 0, 0, 0, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 223, 140512, 140512, 140512, 140512, 140512, 140512, 73, 0, 0, 0,
    0, 0, 78, 0, 0, 78, 78, 0, 0, 0, 0, 0, 0, 28672, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 0, 140288, 140513, 140288, 140288,
    140288, 140288, 289, 389, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 316, 104, 104, 105, 105, 105, 105, 105, 124, 124, 124, 124,
    124, 124, 124, 2109, 0, 0, 0, 0, 37888, 0, 0, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 0, 12288, 140288, 179200,
    140288, 140288, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45056, 45056, 45056, 45056, 45056, 45056, 45056, 45056, 45056, 45056, 45056, 45056, 0, 0, 0, 0, 0, 2109,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 69, 0, 0, 0, 0, 0, 41984, 41984, 41984, 41984, 41984, 41984, 41984, 2109, 0, 0, 0, 73, 0, 0, 0, 0, 69, 78, 69, 0, 78, 78, 84, 84,
    84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 106, 125, 106, 106, 106, 106, 106, 106, 106, 125, 125, 125, 125, 125, 125, 125, 2109, 0, 0, 0, 104, 104, 104, 104,
    624, 104, 104, 104, 104, 104, 104, 104, 104, 222, 0, 123, 123, 226, 123, 123, 123, 104, 204, 206, 104, 210, 104, 213, 104, 104, 0, 123, 123, 123, 229, 123,
    123, 123, 123, 123, 123, 123, 433, 123, 123, 436, 123, 123, 123, 123, 123, 123, 123, 123, 123, 261, 123, 123, 0, 0, 0, 0, 123, 123, 123, 123, 251, 253, 123,
    257, 123, 260, 123, 123, 0, 0, 0, 0, 0, 43008, 43008, 43008, 43008, 43008, 43008, 43008, 2109, 0, 0, 0, 289, 389, 104, 104, 391, 104, 104, 104, 104, 104,
    104, 104, 104, 104, 104, 104, 486, 487, 104, 104, 104, 123, 455, 123, 123, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14417, 2109, 0, 0, 0, 465, 0, 467, 467, 389,
    104, 104, 104, 471, 104, 104, 104, 104, 104, 104, 104, 221, 104, 0, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 571, 123, 123, 123, 123, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 384, 0, 0, 0, 0, 123, 123, 123, 123, 610, 123, 123, 123, 123, 123, 123, 123, 123, 0, 0, 0, 0, 0, 658, 104, 104, 104, 104, 104, 104,
    635, 104, 123, 123, 123, 123, 641, 123, 123, 123, 123, 123, 123, 104, 104, 805, 806, 104, 104, 123, 123, 811, 812, 123, 123, 123, 123, 123, 652, 123, 0, 0,
    0, 0, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 539, 553, 554, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0,
    0, 0, 0, 758, 104, 760, 104, 123, 123, 123, 123, 766, 123, 768, 123, 770, 123, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 591, 104, 104,
    104, 104, 104, 545, 104, 104, 104, 104, 104, 104, 104, 104, 123, 123, 123, 123, 123, 603, 123, 123, 123, 73, 0, 0, 0, 0, 0, 78, 0, 0, 78, 78, 0, 0, 0, 0,
    100, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 107, 126, 107, 107, 107, 107, 107, 126, 126, 126, 126, 126, 126, 126, 2109, 0, 0, 0, 104, 622, 104,
    104, 104, 625, 104, 104, 104, 104, 104, 104, 104, 408, 104, 104, 104, 104, 104, 104, 104, 104, 548, 104, 104, 104, 104, 104, 123, 123, 289, 178, 291, 104,
    104, 104, 104, 104, 104, 104, 300, 104, 104, 104, 104, 305, 225, 333, 123, 123, 123, 123, 123, 123, 123, 342, 123, 123, 123, 123, 347, 123, 123, 123, 123,
    123, 123, 123, 573, 123, 0, 0, 0, 0, 0, 0, 0, 16384, 0, 0, 16384, 16384, 0, 0, 0, 0, 289, 389, 104, 104, 104, 104, 104, 104, 104, 396, 104, 104, 104, 104,
    104, 104, 104, 719, 104, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 357, 123, 123, 359, 123, 104, 104, 104, 404, 104, 104, 104, 104, 104, 104,
    104, 104, 104, 104, 412, 413, 123, 123, 123, 430, 123, 123, 123, 123, 123, 123, 123, 123, 123, 438, 123, 123, 123, 123, 123, 123, 123, 509, 123, 123, 123,
    123, 123, 123, 123, 123, 123, 123, 123, 123, 512, 123, 123, 123, 104, 104, 491, 104, 104, 104, 104, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0,
    104, 123, 123, 123, 123, 518, 123, 123, 123, 123, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 464, 123, 123, 608, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0,
    0, 617, 647, 648, 123, 123, 123, 123, 123, 0, 0, 0, 0, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 630, 631, 104, 824, 123, 123, 123, 826,
    104, 104, 123, 123, 104, 123, 104, 123, 104, 123, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 105, 124, 105, 105, 73, 0, 0, 0, 0, 0, 78, 0, 0, 78, 78, 85, 85,
    85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 108, 127, 108, 108, 108, 108, 108, 108, 108, 127, 127, 127, 127, 127, 127, 127, 2109, 0, 0, 0, 154, 0, 0, 0, 162, 0,
    0, 0, 0, 0, 0, 0, 172, 123, 123, 244, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 0, 0, 0, 0, 0, 0, 289, 178, 292, 104, 104, 104, 104, 104, 104, 104,
    104, 104, 104, 104, 104, 104, 315, 104, 104, 317, 225, 334, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 439, 123, 567, 123, 123,
    123, 123, 123, 123, 123, 123, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 463, 0, 123, 743, 123, 123, 123, 123, 123, 123, 123, 0, 104, 104, 104, 104, 104, 757, 73, 0, 0,
    0, 0, 0, 78, 0, 79, 78, 78, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 109, 128, 109, 109, 109, 109, 109, 109, 109, 128, 128, 128, 128, 128, 128, 128,
    2109, 0, 0, 0, 175, 0, 176, 0, 104, 104, 104, 182, 104, 104, 104, 104, 104, 104, 324, 104, 104, 104, 104, 104, 104, 104, 12619, 289, 202, 104, 207, 104,
    104, 212, 215, 218, 104, 0, 123, 123, 123, 123, 232, 123, 123, 123, 123, 123, 123, 123, 612, 123, 123, 123, 123, 123, 0, 0, 0, 66, 0, 0, 0, 0, 0, 0, 73, 73,
    73, 76, 77, 78, 0, 0, 529, 104, 104, 531, 532, 104, 104, 104, 104, 104, 104, 104, 104, 104, 0, 123, 123, 123, 123, 123, 123, 123, 242, 123, 249, 123, 254,
    123, 123, 259, 262, 265, 123, 0, 271, 0, 0, 208896, 210944, 212992, 0, 218112, 221184, 0, 0, 235520, 0, 0, 0, 0, 0, 0, 160, 0, 165, 0, 0, 0, 0, 0, 0, 0,
    161, 0, 0, 0, 0, 0, 0, 0, 0, 73, 73, 73, 76, 77, 78, 0, 153, 104, 104, 319, 104, 104, 104, 104, 104, 104, 104, 104, 328, 104, 104, 12619, 289, 0, 104, 104,
    104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 490, 225, 123, 123, 123, 123, 123, 123, 123, 123, 123, 343, 123, 123, 346, 123, 123,
    123, 123, 123, 123, 123, 559, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 358, 123, 123, 123, 123, 361, 123, 123, 123, 123, 123, 123, 123,
    123, 370, 123, 123, 271, 0, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 590, 104, 104, 104, 104, 104, 323, 104, 104, 104, 104, 104, 104, 104,
    104, 12619, 289, 289, 389, 390, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 399, 104, 104, 104, 104, 104, 638, 123, 123, 123, 123, 123, 123, 123, 123,
    123, 123, 123, 123, 123, 564, 123, 123, 402, 104, 104, 104, 104, 104, 407, 104, 104, 104, 104, 409, 410, 411, 104, 104, 104, 104, 104, 664, 104, 104, 104,
    104, 669, 104, 104, 123, 123, 123, 123, 104, 104, 123, 123, 104, 123, 104, 123, 833, 834, 104, 104, 416, 104, 418, 104, 104, 104, 422, 104, 12619, 389, 424,
    123, 123, 123, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 441, 123, 123, 123, 123, 443, 444,
    445, 123, 123, 123, 123, 450, 123, 452, 123, 123, 123, 123, 123, 123, 123, 655, 0, 0, 0, 0, 104, 104, 104, 104, 104, 104, 104, 104, 627, 628, 104, 104, 104,
    123, 123, 456, 123, 0, 0, 0, 458, 0, 0, 0, 0, 0, 0, 0, 0, 104, 104, 104, 104, 104, 188, 104, 104, 104, 123, 123, 123, 123, 123, 557, 123, 123, 123, 123,
    123, 123, 123, 123, 123, 123, 123, 123, 123, 451, 123, 123, 123, 123, 123, 609, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 616, 0, 104, 104, 104, 104,
    104, 104, 104, 104, 104, 588, 104, 104, 104, 104, 104, 104, 483, 104, 104, 104, 104, 104, 104, 488, 104, 104, 618, 619, 620, 104, 104, 623, 104, 104, 104,
    104, 626, 104, 104, 629, 104, 104, 104, 104, 104, 717, 104, 104, 104, 123, 721, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 561, 123, 123, 123, 123,
    123, 123, 123, 123, 123, 123, 614, 123, 123, 0, 0, 0, 104, 104, 634, 636, 104, 123, 123, 640, 123, 123, 123, 123, 643, 123, 123, 646, 123, 123, 123, 123,
    651, 653, 123, 0, 0, 0, 0, 0, 104, 659, 104, 104, 104, 104, 123, 763, 123, 123, 123, 123, 123, 123, 123, 123, 0, 104, 732, 104, 104, 104, 736, 104, 104,
    104, 104, 123, 104, 713, 104, 104, 104, 104, 104, 104, 104, 123, 123, 123, 723, 123, 123, 123, 0, 104, 104, 104, 793, 104, 794, 104, 104, 104, 123, 123,
    123, 123, 104, 104, 123, 123, 104, 123, 104, 123, 104, 123, 123, 123, 123, 123, 730, 104, 104, 104, 104, 104, 104, 104, 104, 104, 740, 123, 123, 123, 123,
    123, 123, 123, 679, 123, 123, 123, 123, 123, 123, 686, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 694, 104, 104, 104, 104, 123, 123, 764, 123, 123,
    123, 123, 123, 123, 123, 0, 773, 104, 104, 775, 104, 777, 104, 104, 104, 104, 782, 123, 123, 784, 123, 786, 123, 123, 123, 123, 123, 123, 256, 258, 123,
    123, 267, 123, 0, 0, 0, 0, 389, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 314, 104, 104, 104, 104, 123, 814, 104, 104, 104, 104, 104, 104, 123,
    123, 123, 123, 123, 123, 104, 104, 104, 104, 104, 104, 123, 123, 123, 123, 123, 123, 104, 104, 110, 110, 110, 110, 110, 129, 129, 129, 129, 129, 129, 129,
    2109, 0, 0, 0, 530, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 538, 104, 123, 123, 245, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 0, 0, 0, 0,
    0, 578, 104, 104, 104, 417, 104, 104, 104, 104, 104, 104, 12619, 389, 123, 123, 123, 123, 0, 136192, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 383, 0, 0, 0, 0, 0, 123,
    123, 123, 570, 123, 123, 123, 123, 123, 0, 0, 0, 0, 0, 0, 0, 0, 461, 462, 0, 0, 104, 104, 825, 123, 123, 123, 104, 104, 123, 123, 104, 123, 104, 123, 104,
    123, 123, 123, 123, 123, 123, 367, 123, 123, 123, 123, 123, 123, 0, 0, 0, 104, 104, 104, 104, 104, 104, 104, 587, 104, 104, 104, 104, 104, 104, 104, 325,
    104, 104, 104, 104, 104, 104, 12619, 289, 73, 0, 0, 0, 0, 0, 78, 0, 0, 78, 78, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 111, 130, 111, 111, 111, 111,
    111, 111, 111, 130, 130, 130, 130, 130, 130, 130, 2109, 0, 0, 0, 621, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 0, 123, 123, 123, 123,
    123, 239, 104, 104, 663, 104, 104, 104, 104, 666, 104, 104, 104, 104, 104, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 772, 104, 123, 123, 123, 677,
    123, 123, 123, 123, 680, 123, 123, 123, 123, 123, 0, 0, 104, 104, 104, 104, 104, 585, 104, 104, 104, 104, 104, 104, 104, 104, 104, 0, 123, 123, 123, 123,
    123, 236, 123, 123, 123, 123, 365, 123, 123, 123, 123, 123, 123, 123, 123, 0, 0, 0, 0, 0, 0, 460, 0, 0, 0, 0, 0, 123, 123, 123, 123, 123, 572, 123, 123,
    123, 0, 0, 0, 0, 0, 0, 0, 104, 104, 104, 104, 104, 190, 104, 104, 104, 0, 2109, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 70, 0, 0, 0, 27751, 27751, 27751, 27751,
    27751, 27751, 27751, 27751, 27751, 0, 0, 0, 0, 0, 157, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 104, 104, 104, 183, 104, 104, 104, 104, 104, 73, 0, 0, 0, 0, 0, 78, 0,
    0, 78, 78, 88, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 112, 131, 112, 112, 112, 112, 112, 112, 112, 131, 131, 131, 131, 131, 131, 131, 2109, 0, 0,
    0, 44032, 44032, 44032, 44032, 44032, 44032, 44032, 44032, 44032, 0, 0, 0, 0, 0, 25741, 25741, 25741, 25741, 25741, 25741, 25741, 2109, 0, 0, 0, 279, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 284, 0, 0, 0, 0, 0, 44032, 44032, 44032, 44032, 44032, 44032, 44032, 2109, 0, 0, 0, 289, 178, 104, 104, 104, 104, 296, 104, 104,
    104, 104, 104, 104, 104, 104, 104, 0, 123, 123, 123, 123, 123, 235, 225, 123, 123, 123, 123, 338, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123,
    123, 123, 513, 514, 123, 123, 123, 123, 351, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 271, 0, 0, 104, 415, 104, 104, 104, 104, 104,
    104, 104, 104, 12619, 389, 123, 123, 123, 123, 123, 123, 123, 123, 123, 560, 123, 123, 123, 123, 123, 566, 540, 104, 104, 104, 104, 104, 104, 104, 104, 104,
    104, 104, 104, 104, 123, 123, 123, 123, 499, 123, 123, 123, 123, 593, 104, 104, 595, 104, 104, 597, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 523, 0,
    0, 0, 0, 0, 606, 123, 123, 123, 123, 123, 611, 123, 123, 613, 123, 123, 615, 0, 0, 0, 140465, 140465, 140465, 186545, 140465, 140465, 191665, 140465,
    140465, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 236721, 140465, 238769, 140512, 180448, 104, 633, 104, 104, 104, 123, 123,
    123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 270, 374, 0, 123, 123, 123, 650, 123, 123, 123, 0, 0, 0, 0, 0, 104, 104, 104, 104, 104, 104, 104,
    104, 104, 537, 104, 104, 104, 123, 123, 123, 745, 123, 747, 748, 749, 123, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 592, 104,
    799, 123, 800, 123, 123, 123, 104, 104, 104, 104, 104, 104, 123, 123, 123, 123, 123, 123, 823, 104, 104, 104, 123, 123, 123, 123, 104, 104, 123, 123, 829,
    830, 104, 123, 104, 123, 123, 123, 123, 123, 123, 519, 123, 123, 0, 0, 524, 0, 0, 0, 0, 389, 104, 104, 104, 104, 104, 473, 474, 104, 476, 104, 104, 73, 0,
    0, 0, 0, 0, 78, 0, 0, 78, 78, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 113, 132, 113, 113, 113, 113, 113, 113, 113, 132, 132, 132, 132, 132, 132,
    132, 2109, 0, 0, 0, 183296, 138240, 140288, 140288, 140288, 183296, 140288, 140288, 140288, 140288, 140288, 192512, 140288, 306, 104, 104, 104, 104, 104,
    104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 329, 104, 12619, 289, 225, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 348, 289,
    389, 104, 104, 104, 104, 104, 394, 104, 104, 104, 104, 104, 104, 104, 104, 326, 104, 104, 104, 104, 330, 12619, 289, 104, 403, 104, 104, 104, 104, 104, 104,
    104, 104, 104, 104, 104, 104, 104, 104, 551, 104, 123, 123, 123, 428, 123, 123, 123, 123, 123, 123, 123, 123, 123, 437, 123, 123, 123, 123, 123, 123, 123,
    123, 123, 574, 0, 0, 0, 0, 0, 0, 159, 0, 164, 0, 167, 0, 169, 0, 0, 0, 579, 104, 104, 582, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 671,
    123, 123, 123, 104, 104, 104, 776, 104, 778, 104, 104, 104, 123, 123, 123, 123, 785, 123, 787, 73, 0, 0, 0, 0, 0, 78, 0, 0, 78, 78, 90, 90, 90, 90, 90, 90,
    90, 90, 90, 90, 90, 90, 114, 133, 114, 114, 114, 114, 114, 114, 114, 133, 133, 133, 133, 133, 133, 133, 2109, 0, 0, 0, 183296, 138240, 140465, 140465,
    140465, 183473, 140465, 140465, 140465, 140465, 140465, 192689, 140465, 289, 178, 104, 104, 104, 104, 104, 297, 104, 104, 104, 104, 104, 104, 104, 104, 484,
    104, 104, 104, 104, 104, 489, 104, 225, 123, 123, 123, 123, 123, 339, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 575, 0, 0, 0, 0, 0, 376, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29696, 2109, 0, 0, 0, 289, 389, 104, 104, 104, 104, 104, 104, 395, 104, 104, 104, 398, 104, 104, 104, 104, 104, 419, 420,
    104, 104, 104, 12619, 389, 123, 123, 123, 123, 123, 123, 123, 123, 510, 123, 123, 123, 123, 123, 123, 515, 123, 123, 429, 123, 123, 123, 432, 123, 123, 123,
    123, 123, 123, 123, 123, 123, 0, 752, 104, 104, 104, 104, 104, 123, 442, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 565, 123,
    123, 517, 123, 123, 123, 123, 123, 123, 123, 0, 0, 0, 0, 0, 0, 0, 104, 104, 104, 104, 185, 104, 104, 195, 104, 123, 123, 729, 123, 0, 104, 104, 104, 104,
    104, 104, 104, 104, 104, 104, 123, 123, 497, 123, 123, 123, 123, 123, 123, 73, 0, 0, 0, 0, 0, 78, 0, 0, 78, 78, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,
    91, 115, 134, 115, 115, 115, 115, 115, 115, 115, 134, 134, 134, 134, 134, 134, 134, 2109, 0, 0, 0, 104, 104, 104, 104, 104, 691, 104, 692, 693, 104, 104,
    104, 104, 104, 123, 123, 123, 765, 123, 123, 123, 123, 123, 123, 0, 104, 104, 104, 734, 104, 104, 104, 104, 104, 104, 123, 123, 123, 246, 123, 123, 123,
    123, 123, 123, 123, 123, 269, 0, 0, 0, 0, 143, 0, 0, 0, 73, 73, 73, 76, 77, 78, 0, 0, 104, 308, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
    104, 104, 12619, 0, 123, 123, 123, 123, 350, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 0, 375, 528, 0, 0, 104, 104, 104,
    104, 104, 533, 534, 104, 536, 104, 104, 104, 104, 104, 104, 494, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 135168, 373, 0, 104, 541,
    104, 104, 104, 104, 104, 547, 104, 104, 104, 104, 104, 104, 123, 123, 123, 123, 123, 767, 123, 123, 123, 123, 0, 104, 104, 733, 104, 104, 104, 104, 104,
    104, 104, 123, 123, 123, 601, 123, 123, 604, 123, 123, 123, 123, 123, 555, 556, 123, 558, 123, 123, 123, 123, 123, 563, 123, 123, 123, 123, 123, 123, 123,
    123, 705, 123, 123, 123, 123, 0, 104, 104, 104, 104, 735, 104, 737, 738, 739, 104, 123, 123, 123, 569, 123, 123, 123, 123, 123, 123, 0, 0, 0, 0, 0, 0, 0,
    104, 104, 104, 104, 186, 104, 104, 104, 104, 632, 104, 104, 104, 104, 123, 123, 123, 123, 123, 123, 123, 123, 644, 645, 123, 123, 123, 123, 123, 123, 654,
    0, 656, 0, 0, 0, 104, 104, 104, 104, 104, 104, 104, 535, 104, 104, 104, 104, 104, 123, 123, 649, 123, 123, 123, 123, 0, 0, 0, 0, 0, 104, 104, 104, 660, 674,
    123, 123, 123, 123, 123, 123, 123, 123, 681, 123, 123, 123, 123, 0, 0, 104, 104, 104, 104, 584, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 550, 104,
    104, 104, 123, 123, 123, 123, 700, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 715, 104, 104, 104,
    104, 104, 123, 123, 123, 123, 123, 725, 123, 123, 123, 123, 123, 123, 678, 123, 123, 123, 123, 683, 123, 123, 0, 0, 104, 104, 104, 104, 690, 104, 104, 104,
    104, 104, 104, 104, 104, 104, 123, 599, 123, 123, 123, 123, 123, 123, 123, 123, 123, 744, 123, 123, 123, 123, 123, 123, 751, 104, 104, 104, 104, 104, 104,
    214, 104, 104, 0, 123, 123, 123, 123, 123, 123, 104, 804, 104, 104, 104, 808, 123, 810, 123, 123, 104, 759, 104, 761, 123, 123, 123, 123, 123, 123, 123,
    769, 123, 771, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 696, 104, 123, 0, 2109, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 71, 0, 0, 104, 104,
    104, 583, 104, 104, 586, 104, 104, 104, 104, 104, 104, 104, 104, 667, 104, 104, 104, 104, 123, 123, 123, 73, 0, 0, 0, 0, 0, 78, 0, 0, 78, 78, 92, 92, 92,
    92, 92, 92, 92, 92, 92, 92, 92, 92, 116, 135, 116, 116, 116, 116, 116, 116, 116, 135, 135, 135, 135, 135, 135, 135, 2109, 0, 0, 0, 104, 104, 104, 689, 104,
    104, 104, 104, 104, 104, 104, 104, 104, 104, 123, 123, 600, 123, 123, 123, 123, 123, 123, 104, 205, 208, 104, 104, 104, 216, 219, 104, 0, 123, 123, 123,
    231, 234, 123, 123, 123, 123, 123, 123, 803, 104, 104, 104, 104, 104, 809, 123, 123, 123, 0, 791, 104, 104, 104, 104, 104, 104, 104, 104, 797, 123, 123,
    240, 123, 123, 123, 252, 255, 123, 123, 123, 263, 266, 123, 0, 0, 0, 0, 155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23552, 2109, 0, 0, 0, 104, 104, 320, 104, 104,
    104, 104, 104, 104, 104, 104, 104, 104, 104, 12619, 289, 178, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 12619, 289, 123, 362,
    123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 0, 0, 576, 0, 0, 0, 123, 123, 123, 457, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33874, 2109, 0, 0, 0,
    104, 104, 480, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 12619, 389, 123, 123, 123, 123, 123, 123, 123, 123, 507, 123, 123, 123, 123,
    123, 123, 123, 123, 123, 123, 123, 123, 123, 271, 0, 0, 0, 580, 104, 104, 104, 104, 104, 104, 104, 104, 104, 589, 104, 104, 104, 104, 104, 104, 665, 104,
    104, 104, 104, 104, 104, 123, 673, 123, 123, 607, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 0, 0, 104, 104, 688, 104, 104, 104, 104, 104,
    104, 104, 104, 695, 104, 104, 123, 123, 123, 123, 104, 104, 123, 123, 104, 123, 831, 832, 104, 123, 0, 687, 104, 104, 104, 104, 104, 104, 104, 104, 104,
    104, 104, 104, 104, 698, 712, 104, 104, 104, 104, 104, 104, 104, 104, 123, 123, 722, 123, 123, 123, 123, 123, 123, 123, 123, 369, 123, 123, 123, 123, 0, 0,
    0, 742, 123, 123, 123, 746, 123, 123, 123, 123, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 123, 117, 117, 117, 117, 117, 136, 136, 136, 136, 136,
    136, 136, 2109, 0, 0, 0, 104, 581, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 781, 123, 123, 123, 123, 123, 123, 123, 225, 123, 123,
    123, 123, 123, 123, 123, 123, 123, 123, 345, 123, 123, 123, 123, 123, 123, 123, 123, 446, 447, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 268, 123,
    0, 0, 0, 0, 104, 479, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 12619, 389, 123, 123, 123, 426, 123, 123, 123, 506, 123, 123,
    123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 134144, 0, 0, 104, 104, 104, 543, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 123, 123, 123, 123,
    602, 123, 123, 123, 123, 104, 662, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 123, 123, 123, 123, 123, 123, 123, 502, 123, 123, 123, 676, 123,
    123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 0, 161, 0, 0, 0, 0, 0, 104, 104, 104, 104, 104, 104, 104, 104, 197, 73, 0, 0, 0, 0, 0, 78, 0, 0, 78,
    78, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 118, 137, 118, 118, 118, 118, 118, 118, 118, 137, 137, 137, 137, 137, 137, 137, 2109, 0, 0, 0, 163, 0,
    0, 0, 0, 0, 104, 104, 104, 104, 104, 104, 104, 104, 200, 104, 104, 104, 209, 211, 104, 104, 220, 104, 0, 123, 123, 227, 123, 123, 123, 123, 123, 123, 123,
    123, 750, 0, 104, 104, 754, 104, 104, 104, 104, 104, 406, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 423, 12619, 389, 123, 123, 123, 123, 289, 178,
    104, 293, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 0, 123, 123, 123, 123, 123, 237, 307, 104, 104, 104, 104, 104, 104, 104, 104, 104,
    104, 104, 104, 104, 104, 104, 0, 123, 123, 123, 123, 123, 238, 104, 318, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 12619, 289, 178, 104,
    104, 104, 104, 104, 104, 104, 104, 104, 104, 303, 104, 104, 104, 104, 104, 482, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 485, 104, 104, 104, 104,
    104, 225, 123, 335, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 349, 360, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 0,
    0, 173, 0, 0, 0, 0, 0, 104, 104, 179, 104, 104, 104, 104, 104, 199, 289, 389, 104, 104, 104, 392, 104, 104, 104, 104, 104, 104, 104, 104, 104, 401, 123,
    728, 123, 123, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 123, 496, 123, 123, 123, 123, 123, 123, 123, 813, 123, 104, 104, 104, 104, 104, 104,
    123, 123, 123, 123, 123, 123, 104, 104, 104, 104, 807, 104, 123, 123, 123, 123, 73, 0, 0, 0, 0, 0, 78, 0, 80, 78, 78, 94, 94, 94, 94, 94, 94, 94, 94, 94,
    94, 94, 94, 119, 138, 119, 119, 119, 119, 119, 119, 119, 138, 138, 138, 138, 138, 138, 138, 2109, 0, 0, 0, 178, 104, 104, 104, 104, 104, 104, 104, 104, 104,
    104, 104, 104, 104, 104, 0, 0, 123, 123, 247, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 0, 0, 0, 0, 527, 0, 289, 178, 104, 104, 104, 295, 104, 104,
    298, 104, 104, 302, 104, 104, 104, 104, 104, 104, 718, 104, 104, 720, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 511, 123, 123, 123, 123, 123, 225,
    123, 123, 123, 337, 123, 123, 340, 123, 123, 344, 123, 123, 123, 123, 123, 123, 123, 123, 123, 264, 123, 123, 0, 0, 0, 0, 516, 123, 123, 123, 123, 123, 123,
    520, 123, 0, 0, 0, 525, 0, 0, 0, 178, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 194560, 140288, 140288,
    140288, 229376, 140288, 140288, 193536, 140288, 217088, 140288, 140288, 140288, 229376, 140288, 140288, 193536, 104, 104, 542, 104, 104, 104, 546, 104, 104,
    104, 104, 104, 104, 104, 123, 123, 123, 498, 123, 123, 123, 123, 123, 123, 568, 123, 123, 123, 123, 123, 123, 123, 0, 0, 0, 0, 0, 0, 0, 146, 73, 73, 73, 76,
    77, 78, 0, 0, 104, 594, 104, 104, 104, 104, 104, 123, 123, 123, 123, 123, 123, 123, 605, 123, 123, 123, 123, 123, 352, 123, 123, 123, 123, 123, 123, 123,
    123, 123, 123, 123, 123, 123, 685, 0, 0, 104, 104, 714, 104, 716, 104, 104, 104, 104, 123, 123, 123, 123, 724, 123, 726, 104, 104, 104, 104, 762, 123, 123,
    123, 123, 123, 123, 123, 123, 123, 0, 104, 104, 104, 755, 104, 104, 788, 123, 123, 0, 104, 792, 104, 104, 104, 104, 104, 104, 104, 123, 798, 123, 123, 123,
    123, 123, 353, 123, 123, 355, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 449, 123, 123, 123, 123, 0, 2109, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    72, 0, 178, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 194737, 140465, 140465, 140465, 200881, 207025, 140465,
    140465, 140465, 140465, 140465, 140465, 140465, 140465, 177376, 140512, 184544, 73, 0, 0, 0, 0, 0, 78, 0, 0, 78, 78, 95, 95, 99, 95, 99, 99, 99, 99, 99, 99,
    99, 99, 99, 99, 99, 120, 139, 120, 120, 120, 120, 120, 139, 139, 139, 139, 139, 139, 139, 2109, 0, 0, 0, 203, 104, 104, 104, 104, 104, 104, 104, 104, 0,
    123, 123, 228, 123, 123, 123, 123, 123, 123, 123, 354, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 684, 123, 0, 0, 123, 243, 248, 250, 123,
    123, 123, 123, 123, 123, 123, 123, 0, 0, 0, 0, 0, 104, 104, 104, 104, 289, 178, 104, 104, 294, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 327,
    104, 104, 104, 104, 12619, 289, 104, 104, 104, 321, 322, 104, 104, 104, 104, 104, 104, 104, 104, 104, 12619, 289, 178, 104, 104, 104, 104, 104, 104, 104,
    104, 104, 301, 104, 104, 304, 104, 104, 104, 104, 309, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 670, 104, 123, 123, 123, 225, 123, 123, 336,
    123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 710, 104, 123, 123, 363, 364, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 0, 0, 280,
    0, 0, 0, 0, 0, 0, 282, 283, 0, 0, 280, 0, 0, 0, 272, 73, 73, 0, 0, 0, 273, 0, 0, 0, 0, 0, 0, 0, 0, 73, 73, 73, 76, 77, 78, 152, 0, 289, 389, 104, 104, 104,
    104, 393, 104, 104, 104, 104, 104, 104, 104, 400, 104, 104, 104, 104, 405, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 421, 104, 104, 12619, 389,
    123, 123, 425, 123, 427, 123, 123, 123, 123, 123, 123, 123, 434, 123, 123, 123, 123, 123, 123, 440, 454, 123, 123, 123, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    36965, 2109, 0, 0, 0, 0, 466, 0, 0, 389, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 549, 104, 104, 104, 104, 123, 123, 104, 104, 104, 481, 104,
    104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 668, 104, 104, 104, 123, 123, 123, 104, 104, 104, 104, 492, 104, 104, 123, 123, 123, 123, 123, 123,
    123, 123, 123, 123, 123, 123, 270, 142, 0, 0, 123, 123, 123, 123, 123, 508, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 709, 104, 104,
    104, 104, 104, 104, 544, 104, 104, 104, 104, 104, 104, 104, 104, 104, 552, 123, 123, 123, 123, 123, 366, 123, 123, 123, 123, 123, 123, 123, 0, 0, 0, 0, 459,
    0, 0, 0, 0, 0, 0, 0, 104, 104, 104, 104, 104, 192, 104, 104, 104, 104, 104, 104, 104, 637, 123, 639, 123, 123, 123, 642, 123, 123, 123, 123, 123, 123, 123,
    123, 123, 435, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 448, 123, 123, 123, 123, 123, 123, 699, 123, 123, 123, 123, 123, 123, 123, 123, 706, 123,
    123, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 697, 123, 123, 123, 790, 0, 104, 104, 104, 104, 104, 104, 795, 796, 104, 123, 123,
    123, 123, 123, 123, 123, 368, 123, 123, 123, 123, 372, 0, 0, 0, 140288, 140288, 140288, 186368, 140288, 140288, 191488, 140288, 140288, 140288, 140288,
    140288, 140288, 140288, 140288, 140288, 235520, 140288, 140288, 140288, 135168, 373, 0, 123, 123, 123, 801, 802, 123, 104, 104, 104, 104, 104, 104, 123,
    123, 123, 123, 123, 123, 123, 2109, 0, 0, 0, 104, 104, 123, 123, 123, 123, 104, 827, 123, 828, 104, 123, 104, 123, 104, 123, 123, 123, 123, 123, 431, 123,
    123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 135168, 0, 0, 73, 0, 0, 0, 0, 0, 78, 0, 0, 78, 78, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,
    96, 121, 140, 121, 121, 121, 121, 121, 121, 121, 140, 140, 140, 140, 140, 140, 140, 2109, 0, 0, 0, 290, 140288, 140288, 140288, 140288, 140288, 140288,
    140288, 140288, 140288, 140288, 140288, 194560, 140288, 140288, 140288, 237568, 0, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288,
    140288, 140288, 140288, 140288, 140288, 0, 140288, 140288, 140288, 140288, 140288, 140288, 241, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 0,
    0, 0, 0, 577, 0, 289, 389, 104, 104, 104, 104, 104, 104, 104, 104, 104, 397, 104, 104, 104, 104, 104, 104, 779, 104, 104, 123, 123, 123, 123, 123, 123, 123,
    123, 123, 123, 123, 371, 123, 0, 0, 0, 414, 104, 104, 104, 104, 104, 104, 104, 104, 104, 12619, 389, 123, 123, 123, 123, 123, 123, 123, 123, 521, 522, 0, 0,
    0, 526, 0, 0, 123, 123, 123, 701, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 104, 104, 104, 104, 756, 104, 123, 789, 123, 0, 104, 104, 104, 104, 104,
    104, 104, 104, 104, 123, 123, 123, 123, 123, 500, 501, 123, 503, 289, 178, 104, 104, 104, 104, 104, 104, 104, 299, 104, 104, 104, 104, 104, 104, 311, 104,
    104, 313, 104, 104, 104, 104, 104, 104, 310, 104, 104, 104, 104, 104, 104, 104, 104, 104, 0, 123, 123, 123, 123, 233, 123, 225, 123, 123, 123, 123, 123,
    123, 123, 341, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 707, 123, 0, 104, 104, 478, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
    104, 104, 104, 104, 598, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 708, 0, 104, 104, 123, 504, 505, 123, 123, 123, 123, 123, 123, 123,
    123, 123, 123, 123, 123, 123, 0, 104, 104, 108544, 108606, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 108544, 73, 0, 0, 0, 0, 108544, 0, 0, 0, 0, 0, 0, 0, 0,
    108544, 0, 0, 0, 0, 0, 108544, 0, 0, 0, 0, 0, 0, 0, 0, 0, 140288, 140466, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 235520,
    140288, 140288, 140288, 135168, 0, 0, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 109665, 109665, 109665, 109665, 109665, 109665, 109665, 109665, 109665, 109665,
    109665, 109665, 0, 0, 0, 0, 110592, 0, 0, 0, 0, 0, 0, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 236544,
    140288, 238592, 140288, 180224, 73, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111616, 111616, 111616, 111616, 111616, 111616, 111616, 111616, 111616, 111616, 111616,
    111616, 0, 0, 0, 0, 332, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 194560, 140288, 140288, 140288, 200704,
    206848, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 177152, 140288, 184320, 13312, 13312, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    109665, 2109, 0, 0, 0, 0, 134144, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 139264, 0, 0, 377, 0, 0, 378, 379, 0, 381, 0, 0, 0, 0, 0, 0, 0, 0, 104, 104, 104, 104,
    104, 104, 194, 104, 104, 220160, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 194560, 0, 201728, 202752
  "/>

  <!--~
   ! The DFA-state to expected-token-set mapping.
  -->
  <xsl:variable name="p:EXPECTED" as="xs:integer+" select="
    417, 421, 425, 429, 433, 437, 441, 445, 449, 457, 469, 470, 841, 476, 522, 482, 528, 465, 732, 470, 470, 470, 490, 522, 522, 522, 522, 523, 497, 528, 528,
    528, 528, 503, 470, 470, 490, 522, 522, 522, 522, 463, 528, 528, 528, 528, 507, 470, 990, 522, 522, 522, 477, 528, 528, 528, 528, 514, 520, 522, 522, 491,
    528, 528, 528, 514, 521, 522, 477, 528, 528, 499, 520, 522, 478, 528, 498, 460, 522, 478, 528, 529, 521, 477, 528, 484, 522, 527, 534, 477, 528, 486, 492,
    533, 522, 527, 485, 478, 538, 492, 540, 538, 493, 544, 547, 907, 548, 552, 556, 559, 562, 566, 578, 470, 573, 470, 955, 979, 470, 628, 577, 470, 582, 587,
    470, 470, 591, 598, 450, 470, 470, 470, 602, 608, 627, 470, 470, 470, 612, 470, 616, 640, 626, 470, 470, 583, 639, 625, 470, 470, 470, 632, 795, 604, 645,
    470, 470, 638, 644, 470, 470, 649, 949, 656, 627, 470, 660, 664, 470, 649, 896, 674, 470, 680, 675, 676, 895, 682, 829, 681, 470, 966, 686, 829, 693, 470,
    701, 470, 702, 470, 706, 712, 743, 718, 717, 782, 778, 687, 717, 716, 778, 719, 723, 781, 779, 780, 729, 736, 470, 470, 742, 708, 747, 747, 751, 751, 470,
    773, 667, 768, 621, 470, 755, 759, 738, 765, 772, 516, 870, 619, 777, 470, 510, 786, 594, 840, 470, 470, 790, 799, 803, 807, 666, 812, 828, 470, 689, 817,
    822, 470, 470, 688, 816, 821, 807, 857, 826, 470, 724, 834, 839, 470, 470, 833, 838, 515, 826, 470, 845, 838, 470, 724, 851, 856, 861, 724, 851, 807, 725,
    852, 867, 688, 874, 470, 846, 877, 724, 881, 688, 847, 890, 900, 450, 901, 668, 905, 914, 917, 916, 920, 670, 669, 911, 915, 919, 918, 634, 884, 885, 886,
    924, 928, 931, 470, 863, 893, 935, 939, 942, 943, 947, 960, 470, 470, 761, 953, 470, 569, 470, 808, 959, 470, 470, 470, 964, 470, 470, 470, 470, 472, 793,
    470, 470, 470, 470, 652, 996, 470, 970, 470, 470, 470, 470, 697, 470, 470, 470, 470, 696, 976, 972, 470, 470, 470, 471, 984, 470, 470, 470, 983, 972, 470,
    470, 470, 988, 470, 470, 994, 470, 470, 470, 1000, 470, 470, 1001, 470, 470, 453, 470, 452, 470, 470, 453, 470, 1005, 470, 452, 470, 453, 451, 470, 1006,
    470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 470, 1088, 1010, 1012, 1014, 1016, 1018, 1019, 1019, 1021, 1023, 1025, 1027, 1029,
    1031, 1032, 1032, 1036, 1033, 1039, 1034, 1038, 1041, 1043, 1045, 1047, 1049, 1051, 1053, 1056, 1054, 1068, 1063, 1058, 1171, 1065, 1065, 1065, 1061, 1065,
    1065, 1263, 1079, 1080, 1065, 1065, 1256, 1256, 1231, 1100, 1100, 1097, 1065, 1116, 1065, 1065, 1065, 1065, 1067, 1070, 1090, 1256, 1256, 1256, 1091, 1100,
    1257, 1233, 1100, 1100, 1092, 1256, 1256, 1256, 1082, 1256, 1256, 1256, 1100, 1100, 1256, 1232, 1100, 1100, 1100, 1092, 1065, 1100, 1100, 1101, 1072, 1100,
    1100, 1103, 1065, 1065, 1260, 1104, 1092, 1065, 1065, 1065, 1075, 1065, 1065, 1161, 1256, 1256, 1256, 1256, 1099, 1091, 1100, 1100, 1100, 1100, 1065, 1100,
    1100, 1100, 1161, 1256, 1100, 1100, 1100, 1256, 1256, 1256, 1100, 1091, 1091, 1091, 1065, 1065, 1065, 1106, 1111, 1157, 1076, 1077, 1119, 1121, 1123, 1124,
    1125, 1124, 1127, 1127, 1127, 1128, 1129, 1130, 1132, 1065, 1065, 1306, 1180, 1157, 1117, 1134, 1149, 1223, 1065, 1065, 1065, 1107, 1107, 1065, 1065, 1065,
    1115, 1166, 1251, 1280, 1203, 1138, 1065, 1303, 1278, 1140, 1154, 1241, 1140, 1148, 1190, 1202, 1065, 1302, 1277, 1139, 1147, 1156, 1147, 1155, 1191, 1170,
    1065, 1157, 1252, 1168, 1138, 1065, 1115, 1277, 1271, 1202, 1065, 1225, 1065, 1167, 1287, 1075, 1065, 1065, 1065, 1152, 1166, 1183, 1075, 1065, 1269, 1167,
    1275, 1277, 1139, 1147, 1155, 1167, 1156, 1282, 1171, 1065, 1065, 1065, 1166, 1073, 1065, 1066, 1069, 1177, 1270, 1147, 1156, 1287, 1276, 1113, 1140, 1200,
    1286, 1171, 1065, 1065, 1073, 1065, 1065, 1269, 1167, 1171, 1156, 1283, 1065, 1065, 1065, 1166, 1275, 1113, 1147, 1156, 1274, 1065, 1205, 1201, 1065, 1065,
    1065, 1175, 1070, 1113, 1200, 1274, 1065, 1066, 1069, 1261, 1081, 1065, 1187, 1199, 1201, 1065, 1228, 1201, 1065, 1065, 1075, 1209, 1065, 1187, 1200, 1274,
    1065, 1187, 1189, 1274, 1065, 1065, 1187, 1207, 1065, 1065, 1065, 1176, 1085, 1142, 1065, 1142, 1065, 1086, 1173, 1174, 1142, 1142, 1065, 1065, 1094, 1219,
    1162, 1065, 1065, 1065, 1187, 1211, 1211, 1211, 1211, 1213, 1213, 1213, 1213, 1093, 1218, 1220, 1153, 1273, 1193, 1065, 1065, 1105, 1258, 1221, 1272, 1192,
    1065, 1095, 1215, 1271, 1065, 1161, 1163, 1065, 1065, 1160, 1065, 1065, 1065, 1188, 1065, 1065, 1188, 1201, 1060, 1230, 1236, 1304, 1065, 1259, 1071, 1178,
    1081, 1065, 1065, 1138, 1275, 1159, 1235, 1237, 1112, 1139, 1141, 1240, 1202, 1186, 1065, 1065, 1065, 1259, 1065, 1262, 1216, 1250, 1070, 1083, 1087, 1135,
    1278, 1278, 1239, 1254, 1202, 1186, 1243, 1250, 1064, 1065, 1065, 1065, 1275, 1176, 1083, 1087, 1146, 1253, 1253, 1282, 1185, 1065, 1065, 1065, 1255, 1065,
    1175, 1245, 1266, 1254, 1170, 1085, 1279, 1254, 1202, 1186, 1186, 1065, 1065, 1075, 1164, 1243, 1247, 1065, 1065, 1109, 1065, 1065, 1172, 1247, 1065, 1104,
    1262, 1227, 1245, 1266, 1254, 1185, 1073, 1249, 1064, 1085, 1267, 1184, 1171, 1065, 1291, 1289, 1065, 1291, 1075, 1172, 1250, 1065, 1143, 1065, 1065, 1114,
    1113, 1147, 1065, 1265, 1267, 1184, 1171, 1167, 1171, 1065, 1065, 1111, 1065, 1171, 1075, 1065, 1062, 1285, 1289, 1075, 1065, 1062, 1285, 1289, 1074, 1065,
    1289, 1062, 1167, 1062, 1167, 1183, 1183, 1281, 1281, 1281, 1084, 1194, 1195, 1293, 1293, 1196, 1196, 1295, 1196, 1297, 1297, 1297, 1297, 1299, 1065, 1065,
    1065, 1114, 1277, 1301, 1065, 1065, 1065, 1137, 1145, 1307, 1065, 1065, 1108, 1065, 1105, 1164, 1065, 1065, 1137, 1198, 1161, 1164, 1065, 1065, 1161, 1164,
    1081, 1065, 1072, 1065, 1151, 1222, 1224, 1067, 1070, 1060, 1180, 1065, 1059, 1081, 1065, 1065, 1179, 1256, 1065, 1181, 1060, 1180, 1108, 1065, 1065, 1181,
    1061, 1065, 1065, 1065, 1158, 1065, 1065, 1065, 262660, 295424, 328192, 393728, 786944, 1311232, 4456960, 1074004480, -2147220992, 262656, 262656,
    537134080, 426496, 852480, 4981248, 786944, 262656, 787104, 4981248, 786944, 1442436, 6161028, 284967424, 284967424, 486302208, 486466048, 285098496,
    284967424, 1560175104, 486433280, 1560044032, 486531584, 1560207872, 262976, 265024, 394048, 1311552, 459584, 918336, 1442624, 1835840, 1966912, 50793340,
    252119932, 262605692, 334457724, 263129980, 262605692, 262144, 4, 64, 128, 0, 2, 512, 0, 0, 1, 2, 2, 4, 8, 16, 0, -2147483648, -2147483648, 0, -1459599121,
    -1459599121, 536871936, 32, 128, 256, 64, 512, 512, 1024, 1024, 4096, 4098, 320, 256, 2304, 0, 15, 48, 3136, 33554456, 28, 2048, 2304, 2304, 24, 16, 16, 32,
    256, 65536, 0, 16, 512, 0, 65536, 131072, 524288, 12288, 16384, 0, 6, -1459598865, -1459074833, -1459598865, -1459074577, -1458812673, -1458811649,
    -1458811649, -1458811393, -69632, -69632, -67840, -67840, -65792, -67840, -65537, 192, 16384, 65536, 0, 524288, 786432, 1048576, 2097152, 8388608, 0, 512,
    16, 786432, 2097152, 12582912, 16777216, -1476395008, 0, 192512, 3932160, 8388608, 16777216, 33554432, 67108864, 0, 128, 1536, 0, 256, 4194304, 0, 64, 0,
    67108864, 134217728, -2147483648, 536870912, 1073741824, -2147483648, 1024, 32, 0, 3, 8, 32, 64, 256, 0, 4, 0, 134217728, 536870912, -1073741824, 0, 8192,
    8388608, 33554432, 201326592, 268435456, -536870912, 0, 7456, 7520, 7520, 12288, 131072, 12582912, 33554432, 268435456, 536870912, -2147483648, 524288,
    12582912, 8388608, 268435456, 0, 814918768, 814919280, 814919280, -4194561, -4194561, 40960, 131072, 268435456, 48, 7872, 57344, 196608, 3932160, 62914560,
    -67108864, 0, 3648, 2048, 8192, 12582912, 1536, 2048, 2112, 2304, 2368, 2048, 4096, 24576, 32768, 2097152, 16777216, 234881024, 268435456, 1024, 268435456,
    8, 512, 536870912, 512, 1024, 536870912, 0, 16384, 16777216, 100663296, 134217728, 256, 256, 2048, 0, 7, 8, 64, 1024, 263168, 3, 1024, 786432, 100663296, 2,
    524288, 1048576, 8388608, 251658240, 268435456, 0, 12288, 32768, 131072, 786432, 16777216, 134217728, 134217728, 268435456, -2147483648, 524288, 67108864,
    268435456, 1073741824, 134217728, 1073741824, 2, 67108864, 7968, 7520, 8032, 7520, 495, 495, 4591, 7663, 96, 0, 28672, 32768, 65536, 7, 232, 256
  "/>

  <!--~
   ! The token-string table.
  -->
  <xsl:variable name="p:TOKEN" as="xs:string+" select="
    '(0)',
    'AVTFix',
    'IntegerLiteral',
    'DecimalLiteral',
    'DoubleLiteral',
    'StringLiteral',
    'URIQualifiedName',
    'NCName',
    'QName',
    'S',
    'CommentContents',
    'Wildcard',
    'EOF',
    &quot;'!'&quot;,
    &quot;'!='&quot;,
    &quot;'#'&quot;,
    &quot;'$'&quot;,
    &quot;'('&quot;,
    &quot;'(:'&quot;,
    &quot;')'&quot;,
    &quot;'*'&quot;,
    &quot;'+'&quot;,
    &quot;','&quot;,
    &quot;'-'&quot;,
    &quot;'.'&quot;,
    &quot;'..'&quot;,
    &quot;'/'&quot;,
    &quot;'//'&quot;,
    &quot;':'&quot;,
    &quot;':)'&quot;,
    &quot;'::'&quot;,
    &quot;':='&quot;,
    &quot;'&lt;'&quot;,
    &quot;'&lt;&lt;'&quot;,
    &quot;'&lt;='&quot;,
    &quot;'='&quot;,
    &quot;'=&gt;'&quot;,
    &quot;'&gt;'&quot;,
    &quot;'&gt;='&quot;,
    &quot;'&gt;&gt;'&quot;,
    &quot;'?'&quot;,
    &quot;'@'&quot;,
    &quot;'['&quot;,
    &quot;']'&quot;,
    &quot;'ancestor'&quot;,
    &quot;'ancestor-or-self'&quot;,
    &quot;'and'&quot;,
    &quot;'array'&quot;,
    &quot;'as'&quot;,
    &quot;'attribute'&quot;,
    &quot;'cast'&quot;,
    &quot;'castable'&quot;,
    &quot;'child'&quot;,
    &quot;'comment'&quot;,
    &quot;'descendant'&quot;,
    &quot;'descendant-or-self'&quot;,
    &quot;'div'&quot;,
    &quot;'document-node'&quot;,
    &quot;'element'&quot;,
    &quot;'else'&quot;,
    &quot;'empty-sequence'&quot;,
    &quot;'eq'&quot;,
    &quot;'every'&quot;,
    &quot;'except'&quot;,
    &quot;'following'&quot;,
    &quot;'following-sibling'&quot;,
    &quot;'for'&quot;,
    &quot;'function'&quot;,
    &quot;'ge'&quot;,
    &quot;'gt'&quot;,
    &quot;'idiv'&quot;,
    &quot;'if'&quot;,
    &quot;'in'&quot;,
    &quot;'instance'&quot;,
    &quot;'intersect'&quot;,
    &quot;'is'&quot;,
    &quot;'item'&quot;,
    &quot;'le'&quot;,
    &quot;'let'&quot;,
    &quot;'lt'&quot;,
    &quot;'map'&quot;,
    &quot;'mod'&quot;,
    &quot;'namespace'&quot;,
    &quot;'namespace-node'&quot;,
    &quot;'ne'&quot;,
    &quot;'node'&quot;,
    &quot;'of'&quot;,
    &quot;'or'&quot;,
    &quot;'parent'&quot;,
    &quot;'preceding'&quot;,
    &quot;'preceding-sibling'&quot;,
    &quot;'processing-instruction'&quot;,
    &quot;'return'&quot;,
    &quot;'satisfies'&quot;,
    &quot;'schema-attribute'&quot;,
    &quot;'schema-element'&quot;,
    &quot;'self'&quot;,
    &quot;'some'&quot;,
    &quot;'switch'&quot;,
    &quot;'text'&quot;,
    &quot;'then'&quot;,
    &quot;'to'&quot;,
    &quot;'treat'&quot;,
    &quot;'typeswitch'&quot;,
    &quot;'union'&quot;,
    &quot;'{'&quot;,
    &quot;'|'&quot;,
    &quot;'||'&quot;,
    &quot;'}'&quot;
  "/>

  <!--~
   ! Match next token in input string, starting at given index, using
   ! the DFA entry state for the set of tokens that are expected in
   ! the current context.
   !
   ! @param $input the input string.
   ! @param $begin the index where to start in input string.
   ! @param $token-set the expected token set id.
   ! @return a sequence of three: the token code of the result token,
   ! with input string begin and end positions. If there is no valid
   ! token, return the negative id of the DFA state that failed, along
   ! with begin and end positions of the longest viable prefix.
  -->
  <xsl:function name="p:match" as="xs:integer+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="token-set" as="xs:integer"/>

    <xsl:variable name="result" select="$p:INITIAL[1 + $token-set]"/>
    <xsl:sequence select="p:transition($input, $begin, $begin, $begin, $result, $result mod 1024, 0)"/>
  </xsl:function>

  <!--~
   ! The DFA state transition function. If we are in a valid DFA state, save
   ! it's result annotation, consume one input codepoint, calculate the next
   ! state, and use tail recursion to do the same again. Otherwise, return
   ! any valid result or a negative DFA state id in case of an error.
   !
   ! @param $input the input string.
   ! @param $begin the begin index of the current token in the input string.
   ! @param $current the index of the current position in the input string.
   ! @param $end the end index of the result in the input string.
   ! @param $result the result code.
   ! @param $current-state the current DFA state.
   ! @param $previous-state the  previous DFA state.
   ! @return a sequence of three: the token code of the result token,
   ! with input string begin and end positions. If there is no valid
   ! token, return the negative id of the DFA state that failed, along
   ! with begin and end positions of the longest viable prefix.
  -->
  <xsl:function name="p:transition">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="current" as="xs:integer"/>
    <xsl:param name="end" as="xs:integer"/>
    <xsl:param name="result" as="xs:integer"/>
    <xsl:param name="current-state" as="xs:integer"/>
    <xsl:param name="previous-state" as="xs:integer"/>

    <xsl:choose>
      <xsl:when test="$current-state eq 0">
        <xsl:variable name="result" select="$result idiv 1024"/>
        <xsl:variable name="end" select="$end - $result idiv 128"/>
        <xsl:variable name="end" select="if ($end gt string-length($input)) then string-length($input) + 1 else $end"/>
        <xsl:sequence select="
          if ($result ne 0) then
          (
            $result mod 128 - 1,
            $begin,
            $end
          )
          else
          (
            - $previous-state,
            $begin,
            $current - 1
          )
        "/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="c0" select="(string-to-codepoints(substring($input, $current, 1)), 0)[1]"/>
        <xsl:variable name="c1" as="xs:integer">
          <xsl:choose>
            <xsl:when test="$c0 &lt; 128">
              <xsl:sequence select="$p:MAP0[1 + $c0]"/>
            </xsl:when>
            <xsl:when test="$c0 &lt; 55296">
              <xsl:variable name="c1" select="$c0 idiv 16"/>
              <xsl:variable name="c2" select="$c1 idiv 32"/>
              <xsl:sequence select="$p:MAP1[1 + $c0 mod 16 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:sequence select="p:map2($c0, 1, 6)"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:variable name="current" select="$current + 1"/>
        <xsl:variable name="i0" select="1024 * $c1 + $current-state - 1"/>
        <xsl:variable name="i1" select="$i0 idiv 16"/>
        <xsl:variable name="next-state" select="$p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]"/>
        <xsl:sequence select="
          if ($next-state &gt; 1023) then
            p:transition($input, $begin, $current, $current, $next-state, $next-state mod 1024, $current-state)
          else
            p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Recursively translate one 32-bit chunk of an expected token bitset
   ! to the corresponding sequence of token strings.
   !
   ! @param $result the result of previous recursion levels.
   ! @param $chunk the 32-bit chunk of the expected token bitset.
   ! @param $base-token-code the token code of bit 0 in the current chunk.
   ! @return the set of token strings.
  -->
  <xsl:function name="p:token">
    <xsl:param name="result" as="xs:string*"/>
    <xsl:param name="chunk" as="xs:integer"/>
    <xsl:param name="base-token-code" as="xs:integer"/>

    <xsl:sequence select="
      if ($chunk = 0) then
        $result
      else
        p:token
        (
          ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
          if ($chunk &lt; 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
          $base-token-code + 1
        )
    "/>
  </xsl:function>

  <!--~
   ! Calculate expected token set for a given DFA state as a sequence
   ! of strings.
   !
   ! @param $state the DFA state.
   ! @return the set of token strings
  -->
  <xsl:function name="p:expected-token-set" as="xs:string*">
    <xsl:param name="state" as="xs:integer"/>

    <xsl:if test="$state > 0">
      <xsl:for-each select="0 to 3">
        <xsl:variable name="i0" select=". * 834 + $state - 1"/>
        <xsl:variable name="i1" select="$i0 idiv 2"/>
        <xsl:variable name="i2" select="$i1 idiv 4"/>
        <xsl:sequence select="p:token((), $p:EXPECTED[$i0 mod 2 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 + 1] + 1] + 1], . * 32 + 1)"/>
      </xsl:for-each>
    </xsl:if>
  </xsl:function>

  <!--~
   ! Classify codepoint by doing a tail recursive binary search for a
   ! matching codepoint range entry in MAP2, the codepoint to charclass
   ! map for codepoints above the surrogate block.
   !
   ! @param $c the codepoint.
   ! @param $lo the binary search lower bound map index.
   ! @param $hi the binary search upper bound map index.
   ! @return the character class.
  -->
  <xsl:function name="p:map2" as="xs:integer">
    <xsl:param name="c" as="xs:integer"/>
    <xsl:param name="lo" as="xs:integer"/>
    <xsl:param name="hi" as="xs:integer"/>

    <xsl:variable name="m" select="($hi + $lo) idiv 2"/>
    <xsl:choose>
      <xsl:when test="$lo &gt; $hi">
        <xsl:sequence select="0"/>
      </xsl:when>
      <xsl:when test="$p:MAP2[$m] &gt; $c">
        <xsl:sequence select="p:map2($c, $lo, $m - 1)"/>
      </xsl:when>
      <xsl:when test="$p:MAP2[6 + $m] &lt; $c">
        <xsl:sequence select="p:map2($c, $m + 1, $hi)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="$p:MAP2[12 + $m]"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Try parsing the 1st loop of production Comment (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:try-Comment-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1(16, $input, $state)"/>      <!-- CommentContents | ('(' ':') | (':' ')') -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] = 29">                                      <!-- (':' ')') -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 10">                                <!-- CommentContents -->
                  <xsl:variable name="state" select="p:consumeT(10, $input, $state)"/> <!-- CommentContents -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="
                    if ($state[$p:error]) then
                      $state
                    else
                      p:try-Comment($input, $state)
                  "/>
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:sequence select="p:try-Comment-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Try parsing Comment.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:try-Comment" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="state" select="p:consumeT(18, $input, $state)"/>            <!-- ('(' ':') -->
    <xsl:variable name="state" select="p:try-Comment-1($input, $state)"/>
    <xsl:variable name="state" select="p:consumeT(29, $input, $state)"/>            <!-- (':' ')') -->
    <xsl:sequence select="$state"/>
  </xsl:function>

  <!--~
   ! Try parsing Whitespace.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:try-Whitespace" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 9">                                         <!-- S^WS -->
          <xsl:variable name="state" select="p:consumeT(9, $input, $state)"/>       <!-- S^WS -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:try-Comment($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:sequence select="$state"/>
  </xsl:function>

  <!--~
   ! Parse NodeComp.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NodeComp" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 75">                                        <!-- 'is' -->
          <xsl:variable name="state" select="p:consume(75, $input, $state)"/>       <!-- 'is' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 33">                                        <!-- '<<' -->
          <xsl:variable name="state" select="p:consume(33, $input, $state)"/>       <!-- '<<' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(39, $input, $state)"/>       <!-- '>>' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NodeComp', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse GeneralComp.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-GeneralComp" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 35">                                        <!-- '=' -->
          <xsl:variable name="state" select="p:consume(35, $input, $state)"/>       <!-- '=' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 14">                                        <!-- '!=' -->
          <xsl:variable name="state" select="p:consume(14, $input, $state)"/>       <!-- '!=' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 32">                                        <!-- '<' -->
          <xsl:variable name="state" select="p:consume(32, $input, $state)"/>       <!-- '<' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 34">                                        <!-- '<=' -->
          <xsl:variable name="state" select="p:consume(34, $input, $state)"/>       <!-- '<=' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 37">                                        <!-- '>' -->
          <xsl:variable name="state" select="p:consume(37, $input, $state)"/>       <!-- '>' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(38, $input, $state)"/>       <!-- '>=' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'GeneralComp', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ValueComp.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ValueComp" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 61">                                        <!-- 'eq' -->
          <xsl:variable name="state" select="p:consume(61, $input, $state)"/>       <!-- 'eq' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 84">                                        <!-- 'ne' -->
          <xsl:variable name="state" select="p:consume(84, $input, $state)"/>       <!-- 'ne' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 79">                                        <!-- 'lt' -->
          <xsl:variable name="state" select="p:consume(79, $input, $state)"/>       <!-- 'lt' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 77">                                        <!-- 'le' -->
          <xsl:variable name="state" select="p:consume(77, $input, $state)"/>       <!-- 'le' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 69">                                        <!-- 'gt' -->
          <xsl:variable name="state" select="p:consume(69, $input, $state)"/>       <!-- 'gt' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(68, $input, $state)"/>       <!-- 'ge' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ValueComp', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SimpleTypeName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleTypeName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-TypeName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SimpleTypeName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SingleType.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SingleType" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SimpleTypeName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(33, $input, $state)"/>         <!-- S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' | '<' |
                                                                                         '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' | ']' | 'and' |
                                                                                         'castable' | 'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                                                         'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' |
                                                                                         'return' | 'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' |
                                                                                         '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 40">                                        <!-- '?' -->
          <xsl:variable name="state" select="p:consume(40, $input, $state)"/>       <!-- '?' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SingleType', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ArrowFunctionSpecifier.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArrowFunctionSpecifier" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 16">                                        <!-- '$' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-VarRef($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 17">                                        <!-- '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ParenthesizedExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-EQName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ArrowFunctionSpecifier', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production PredicateList (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PredicateList-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(35, $input, $state)"/>     <!-- S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' |
                                                                                         '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                                                         ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' | 'eq' | 'except' |
                                                                                         'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'lt' |
                                                                                         'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' | 'treat' |
                                                                                         'union' | '|' | '||' | '}' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 42">                                     <!-- '[' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-Predicate($input, $state)
            "/>
            <xsl:sequence select="p:parse-PredicateList-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse PredicateList.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PredicateList" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:parse-PredicateList-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PredicateList', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AbbrevForwardStep.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AbbrevForwardStep" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 41">                                        <!-- '@' -->
          <xsl:variable name="state" select="p:consume(41, $input, $state)"/>       <!-- '@' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(45, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | Wildcard | ('(' ':') |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-NodeTest($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AbbrevForwardStep', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ForwardAxis.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ForwardAxis" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 52">                                        <!-- 'child' -->
          <xsl:variable name="state" select="p:consume(52, $input, $state)"/>       <!-- 'child' -->
          <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 54">                                        <!-- 'descendant' -->
          <xsl:variable name="state" select="p:consume(54, $input, $state)"/>       <!-- 'descendant' -->
          <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 49">                                        <!-- 'attribute' -->
          <xsl:variable name="state" select="p:consume(49, $input, $state)"/>       <!-- 'attribute' -->
          <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 96">                                        <!-- 'self' -->
          <xsl:variable name="state" select="p:consume(96, $input, $state)"/>       <!-- 'self' -->
          <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 55">                                        <!-- 'descendant-or-self' -->
          <xsl:variable name="state" select="p:consume(55, $input, $state)"/>       <!-- 'descendant-or-self' -->
          <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 65">                                        <!-- 'following-sibling' -->
          <xsl:variable name="state" select="p:consume(65, $input, $state)"/>       <!-- 'following-sibling' -->
          <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 64">                                        <!-- 'following' -->
          <xsl:variable name="state" select="p:consume(64, $input, $state)"/>       <!-- 'following' -->
          <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(82, $input, $state)"/>       <!-- 'namespace' -->
          <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ForwardAxis', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ForwardStep.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ForwardStep" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 49">                                       <!-- 'attribute' -->
          <xsl:variable name="state" select="p:lookahead2W(40, $input, $state)"/>   <!-- S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         '/' | '//' | ':' | '::' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' |
                                                                                         '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                                                         'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                                                         'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = (52,                                          (: 'child' :)
                                         54,                                          (: 'descendant' :)
                                         55,                                          (: 'descendant-or-self' :)
                                         64,                                          (: 'following' :)
                                         65,                                          (: 'following-sibling' :)
                                         82,                                          (: 'namespace' :)
                                         96)">                                      <!-- 'self' -->
          <xsl:variable name="state" select="p:lookahead2W(37, $input, $state)"/>   <!-- S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' |
                                                                                         '//' | ':' | '::' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' |
                                                                                         '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                                                         'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                                                         'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 3889                                          (: 'attribute' '::' :)
                     or $state[$p:lk] = 3892                                          (: 'child' '::' :)
                     or $state[$p:lk] = 3894                                          (: 'descendant' '::' :)
                     or $state[$p:lk] = 3895                                          (: 'descendant-or-self' '::' :)
                     or $state[$p:lk] = 3904                                          (: 'following' '::' :)
                     or $state[$p:lk] = 3905                                          (: 'following-sibling' '::' :)
                     or $state[$p:lk] = 3922                                          (: 'namespace' '::' :)
                     or $state[$p:lk] = 3936">                                      <!-- 'self' '::' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ForwardAxis($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(45, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | Wildcard | ('(' ':') |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NodeTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AbbrevForwardStep($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ForwardStep', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AbbrevReverseStep.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AbbrevReverseStep" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(25, $input, $state)"/>             <!-- '..' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AbbrevReverseStep', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse NameTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NameTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 11">                                        <!-- Wildcard -->
          <xsl:variable name="state" select="p:consume(11, $input, $state)"/>       <!-- Wildcard -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-EQName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NameTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse NodeTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NodeTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] = (49,                                          (: 'attribute' :)
                                         53,                                          (: 'comment' :)
                                         57,                                          (: 'document-node' :)
                                         58,                                          (: 'element' :)
                                         83,                                          (: 'namespace-node' :)
                                         85,                                          (: 'node' :)
                                         91,                                          (: 'processing-instruction' :)
                                         94,                                          (: 'schema-attribute' :)
                                         95,                                          (: 'schema-element' :)
                                         99)">                                      <!-- 'text' -->
          <xsl:variable name="state" select="p:lookahead2W(36, $input, $state)"/>   <!-- S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                                                         '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' | 'eq' |
                                                                                         'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                                                         'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' |
                                                                                         'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2225                                          (: 'attribute' '(' :)
                     or $state[$p:lk] = 2229                                          (: 'comment' '(' :)
                     or $state[$p:lk] = 2233                                          (: 'document-node' '(' :)
                     or $state[$p:lk] = 2234                                          (: 'element' '(' :)
                     or $state[$p:lk] = 2259                                          (: 'namespace-node' '(' :)
                     or $state[$p:lk] = 2261                                          (: 'node' '(' :)
                     or $state[$p:lk] = 2267                                          (: 'processing-instruction' '(' :)
                     or $state[$p:lk] = 2270                                          (: 'schema-attribute' '(' :)
                     or $state[$p:lk] = 2271                                          (: 'schema-element' '(' :)
                     or $state[$p:lk] = 2275">                                      <!-- 'text' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-KindTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NameTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NodeTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ReverseAxis.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ReverseAxis" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 88">                                        <!-- 'parent' -->
          <xsl:variable name="state" select="p:consume(88, $input, $state)"/>       <!-- 'parent' -->
          <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 44">                                        <!-- 'ancestor' -->
          <xsl:variable name="state" select="p:consume(44, $input, $state)"/>       <!-- 'ancestor' -->
          <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 90">                                        <!-- 'preceding-sibling' -->
          <xsl:variable name="state" select="p:consume(90, $input, $state)"/>       <!-- 'preceding-sibling' -->
          <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 89">                                        <!-- 'preceding' -->
          <xsl:variable name="state" select="p:consume(89, $input, $state)"/>       <!-- 'preceding' -->
          <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(45, $input, $state)"/>       <!-- 'ancestor-or-self' -->
          <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ReverseAxis', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ReverseStep.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ReverseStep" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 25">                                        <!-- '..' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AbbrevReverseStep($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ReverseAxis($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(45, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | Wildcard | ('(' ':') |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NodeTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ReverseStep', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AxisStep.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AxisStep" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] = (44,                                          (: 'ancestor' :)
                                         45,                                          (: 'ancestor-or-self' :)
                                         88,                                          (: 'parent' :)
                                         89,                                          (: 'preceding' :)
                                         90)">                                      <!-- 'preceding-sibling' -->
          <xsl:variable name="state" select="p:lookahead2W(37, $input, $state)"/>   <!-- S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' |
                                                                                         '//' | ':' | '::' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' |
                                                                                         '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                                                         'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                                                         'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 25                                            (: '..' :)
                     or $state[$p:lk] = 3884                                          (: 'ancestor' '::' :)
                     or $state[$p:lk] = 3885                                          (: 'ancestor-or-self' '::' :)
                     or $state[$p:lk] = 3928                                          (: 'parent' '::' :)
                     or $state[$p:lk] = 3929                                          (: 'preceding' '::' :)
                     or $state[$p:lk] = 3930">                                      <!-- 'preceding-sibling' '::' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ReverseStep($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ForwardStep($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(35, $input, $state)"/>         <!-- S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' |
                                                                                         '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                                                         ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' | 'eq' | 'except' |
                                                                                         'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'lt' |
                                                                                         'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' | 'treat' |
                                                                                         'union' | '|' | '||' | '}' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-PredicateList($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AxisStep', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Lookup.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Lookup" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(40, $input, $state)"/>             <!-- '?' -->
    <xsl:variable name="state" select="p:lookahead1W(25, $input, $state)"/>         <!-- IntegerLiteral | NCName | S^WS | '(' | ('(' ':') | '*' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-KeySpecifier($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Lookup', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Predicate.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Predicate" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(42, $input, $state)"/>             <!-- '[' -->
    <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-Expr($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(43, $input, $state)"/>             <!-- ']' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Predicate', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse KeySpecifier.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-KeySpecifier" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 7">                                         <!-- NCName -->
          <xsl:variable name="state" select="p:consume(7, $input, $state)"/>        <!-- NCName -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 2">                                         <!-- IntegerLiteral -->
          <xsl:variable name="state" select="p:consume(2, $input, $state)"/>        <!-- IntegerLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 17">                                        <!-- '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ParenthesizedExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(20, $input, $state)"/>       <!-- '*' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'KeySpecifier', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse UnaryLookup.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-UnaryLookup" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(40, $input, $state)"/>             <!-- '?' -->
    <xsl:variable name="state" select="p:lookahead1W(25, $input, $state)"/>         <!-- IntegerLiteral | NCName | S^WS | '(' | ('(' ':') | '*' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-KeySpecifier($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'UnaryLookup', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse CurlyArrayConstructor.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-CurlyArrayConstructor" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(47, $input, $state)"/>             <!-- 'array' -->
    <xsl:variable name="state" select="p:lookahead1W(15, $input, $state)"/>         <!-- S^WS | ('(' ':') | '{' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EnclosedExpr($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'CurlyArrayConstructor', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production SquareArrayConstructor (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SquareArrayConstructor-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ExprSingle($input, $state)
            "/>
            <xsl:sequence select="p:parse-SquareArrayConstructor-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse SquareArrayConstructor.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SquareArrayConstructor" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(42, $input, $state)"/>             <!-- '[' -->
    <xsl:variable name="state" select="p:lookahead1W(57, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         ']' | 'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 43">                                       <!-- ']' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ExprSingle($input, $state)
          "/>
          <xsl:variable name="state" select="p:parse-SquareArrayConstructor-1($input, $state)"/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(43, $input, $state)"/>             <!-- ']' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SquareArrayConstructor', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ArrayConstructor.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArrayConstructor" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 42">                                        <!-- '[' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SquareArrayConstructor($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-CurlyArrayConstructor($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ArrayConstructor', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse MapValueExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MapValueExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'MapValueExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse MapKeyExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MapKeyExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'MapKeyExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse MapConstructorEntry.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MapConstructorEntry" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-MapKeyExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(28, $input, $state)"/>             <!-- ':' -->
    <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-MapValueExpr($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'MapConstructorEntry', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production MapConstructor (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MapConstructor-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-MapConstructorEntry($input, $state)
            "/>
            <xsl:sequence select="p:parse-MapConstructor-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse MapConstructor.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MapConstructor" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(80, $input, $state)"/>             <!-- 'map' -->
    <xsl:variable name="state" select="p:lookahead1W(15, $input, $state)"/>         <!-- S^WS | ('(' ':') | '{' -->
    <xsl:variable name="state" select="p:consume(105, $input, $state)"/>            <!-- '{' -->
    <xsl:variable name="state" select="p:lookahead1W(58, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' | '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 108">                                      <!-- '}' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-MapConstructorEntry($input, $state)
          "/>
          <xsl:variable name="state" select="p:parse-MapConstructor-1($input, $state)"/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(108, $input, $state)"/>            <!-- '}' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'MapConstructor', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse EnclosedExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-EnclosedExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(105, $input, $state)"/>            <!-- '{' -->
    <xsl:variable name="state" select="p:lookahead1W(58, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' | '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 108">                                      <!-- '}' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-Expr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(108, $input, $state)"/>            <!-- '}' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'EnclosedExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FunctionBody.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionBody" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EnclosedExpr($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionBody', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse OccurrenceIndicator.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-OccurrenceIndicator" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 40">                                        <!-- '?' -->
          <xsl:variable name="state" select="p:consume(40, $input, $state)"/>       <!-- '?' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 20">                                        <!-- '*' -->
          <xsl:variable name="state" select="p:consume(20, $input, $state)"/>       <!-- '*' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(21, $input, $state)"/>       <!-- '+' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'OccurrenceIndicator', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ParenthesizedItemType.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ParenthesizedItemType" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(46, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ItemType($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(6, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ParenthesizedItemType', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TypedArrayTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TypedArrayTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(47, $input, $state)"/>             <!-- 'array' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(46, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SequenceType($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(6, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TypedArrayTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AnyArrayTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AnyArrayTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(47, $input, $state)"/>             <!-- 'array' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>          <!-- S^WS | ('(' ':') | '*' -->
    <xsl:variable name="state" select="p:consume(20, $input, $state)"/>             <!-- '*' -->
    <xsl:variable name="state" select="p:lookahead1W(6, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AnyArrayTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ArrayTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArrayTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 47">                                       <!-- 'array' -->
          <xsl:variable name="state" select="p:lookahead2W(5, $input, $state)"/>    <!-- S^WS | '(' | ('(' ':') -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:lk] eq 2223">                               <!-- 'array' '(' -->
                <xsl:variable name="state" select="p:lookahead3W(50, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | '*' |
                                                                                             'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                             'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                             'descendant-or-self' | 'div' | 'document-node' | 'element' |
                                                                                             'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                             'following' | 'following-sibling' | 'for' | 'function' | 'ge' |
                                                                                             'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                             'le' | 'let' | 'lt' | 'map' | 'mod' | 'namespace' |
                                                                                             'namespace-node' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                             'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                             'satisfies' | 'schema-attribute' | 'schema-element' | 'self' |
                                                                                             'some' | 'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                                                             'union' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 329903">                                    <!-- 'array' '(' '*' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AnyArrayTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypedArrayTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ArrayTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AtomicOrUnionType.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AtomicOrUnionType" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EQName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AtomicOrUnionType', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TypedMapTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TypedMapTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(80, $input, $state)"/>             <!-- 'map' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AtomicOrUnionType($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(8, $input, $state)"/>          <!-- S^WS | ('(' ':') | ',' -->
    <xsl:variable name="state" select="p:consume(22, $input, $state)"/>             <!-- ',' -->
    <xsl:variable name="state" select="p:lookahead1W(46, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SequenceType($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(6, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TypedMapTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AnyMapTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AnyMapTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(80, $input, $state)"/>             <!-- 'map' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>          <!-- S^WS | ('(' ':') | '*' -->
    <xsl:variable name="state" select="p:consume(20, $input, $state)"/>             <!-- '*' -->
    <xsl:variable name="state" select="p:lookahead1W(6, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AnyMapTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse MapTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MapTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 80">                                       <!-- 'map' -->
          <xsl:variable name="state" select="p:lookahead2W(5, $input, $state)"/>    <!-- S^WS | '(' | ('(' ':') -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:lk] eq 2256">                               <!-- 'map' '(' -->
                <xsl:variable name="state" select="p:lookahead3W(47, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | '*' |
                                                                                             'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                             'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                             'descendant-or-self' | 'div' | 'document-node' | 'element' |
                                                                                             'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                             'following' | 'following-sibling' | 'for' | 'function' | 'ge' |
                                                                                             'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                             'le' | 'let' | 'lt' | 'map' | 'mod' | 'namespace' |
                                                                                             'namespace-node' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                             'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                             'satisfies' | 'schema-attribute' | 'schema-element' | 'self' |
                                                                                             'some' | 'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                                                             'union' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 329936">                                    <!-- 'map' '(' '*' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AnyMapTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypedMapTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'MapTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production TypedFunctionTest (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TypedFunctionTest-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(19, $input, $state)"/>     <!-- S^WS | ('(' ':') | ')' | ',' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(46, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-SequenceType($input, $state)
            "/>
            <xsl:sequence select="p:parse-TypedFunctionTest-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse TypedFunctionTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TypedFunctionTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(67, $input, $state)"/>             <!-- 'function' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(49, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | ')' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 19">                                       <!-- ')' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SequenceType($input, $state)
          "/>
          <xsl:variable name="state" select="p:parse-TypedFunctionTest-1($input, $state)"/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="state" select="p:lookahead1W(11, $input, $state)"/>         <!-- S^WS | ('(' ':') | 'as' -->
    <xsl:variable name="state" select="p:consume(48, $input, $state)"/>             <!-- 'as' -->
    <xsl:variable name="state" select="p:lookahead1W(46, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SequenceType($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TypedFunctionTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AnyFunctionTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AnyFunctionTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(67, $input, $state)"/>             <!-- 'function' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>          <!-- S^WS | ('(' ':') | '*' -->
    <xsl:variable name="state" select="p:consume(20, $input, $state)"/>             <!-- '*' -->
    <xsl:variable name="state" select="p:lookahead1W(6, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AnyFunctionTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FunctionTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 67">                                       <!-- 'function' -->
          <xsl:variable name="state" select="p:lookahead2W(5, $input, $state)"/>    <!-- S^WS | '(' | ('(' ':') -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:lk] eq 2243">                               <!-- 'function' '(' -->
                <xsl:variable name="state" select="p:lookahead3W(52, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | ')' |
                                                                                             '*' | 'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                                                             'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                                                             'descendant' | 'descendant-or-self' | 'div' | 'document-node' |
                                                                                             'element' | 'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                             'following' | 'following-sibling' | 'for' | 'function' | 'ge' |
                                                                                             'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                             'le' | 'let' | 'lt' | 'map' | 'mod' | 'namespace' |
                                                                                             'namespace-node' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                             'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                             'satisfies' | 'schema-attribute' | 'schema-element' | 'self' |
                                                                                             'some' | 'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                                                             'union' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 329923">                                    <!-- 'function' '(' '*' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AnyFunctionTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypedFunctionTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AnyKindTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AnyKindTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(85, $input, $state)"/>             <!-- 'node' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(6, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AnyKindTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse NamespaceNodeTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NamespaceNodeTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(83, $input, $state)"/>             <!-- 'namespace-node' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(6, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NamespaceNodeTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TextTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TextTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(99, $input, $state)"/>             <!-- 'text' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(6, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TextTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse CommentTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-CommentTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(53, $input, $state)"/>             <!-- 'comment' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(6, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'CommentTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse PITest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PITest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(91, $input, $state)"/>             <!-- 'processing-instruction' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(22, $input, $state)"/>         <!-- StringLiteral | NCName | S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 19">                                       <!-- ')' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 7">                                   <!-- NCName -->
                <xsl:variable name="state" select="p:consume(7, $input, $state)"/>  <!-- NCName -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="p:consume(5, $input, $state)"/>  <!-- StringLiteral -->
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(6, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PITest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AttributeDeclaration.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AttributeDeclaration" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AttributeName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AttributeDeclaration', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SchemaAttributeTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SchemaAttributeTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(94, $input, $state)"/>             <!-- 'schema-attribute' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AttributeDeclaration($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(6, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SchemaAttributeTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AttributeName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AttributeName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EQName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AttributeName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AttribNameOrWildcard.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AttribNameOrWildcard" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 20">                                        <!-- '*' -->
          <xsl:variable name="state" select="p:consume(20, $input, $state)"/>       <!-- '*' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AttributeName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AttribNameOrWildcard', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AttributeTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AttributeTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(49, $input, $state)"/>             <!-- 'attribute' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(51, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' | '*' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 19">                                       <!-- ')' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AttribNameOrWildcard($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(19, $input, $state)"/>   <!-- S^WS | ('(' ':') | ')' | ',' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 22">                                  <!-- ',' -->
                <xsl:variable name="state" select="p:consume(22, $input, $state)"/> <!-- ',' -->
                <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                             'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                             'castable' | 'child' | 'comment' | 'descendant' |
                                                                                             'descendant-or-self' | 'div' | 'document-node' | 'element' |
                                                                                             'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                             'following' | 'following-sibling' | 'for' | 'function' | 'ge' |
                                                                                             'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                             'le' | 'let' | 'lt' | 'map' | 'mod' | 'namespace' |
                                                                                             'namespace-node' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                             'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                             'satisfies' | 'schema-attribute' | 'schema-element' | 'self' |
                                                                                             'some' | 'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                                                             'union' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-TypeName($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(6, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AttributeTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ElementDeclaration.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ElementDeclaration" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ElementName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ElementDeclaration', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SchemaElementTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SchemaElementTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(95, $input, $state)"/>             <!-- 'schema-element' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ElementDeclaration($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(6, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SchemaElementTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TypeName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TypeName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EQName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TypeName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ElementName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ElementName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EQName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ElementName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ElementNameOrWildcard.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ElementNameOrWildcard" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 20">                                        <!-- '*' -->
          <xsl:variable name="state" select="p:consume(20, $input, $state)"/>       <!-- '*' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ElementName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ElementNameOrWildcard', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ElementTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ElementTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(58, $input, $state)"/>             <!-- 'element' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(51, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' | '*' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 19">                                       <!-- ')' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ElementNameOrWildcard($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(19, $input, $state)"/>   <!-- S^WS | ('(' ':') | ')' | ',' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 22">                                  <!-- ',' -->
                <xsl:variable name="state" select="p:consume(22, $input, $state)"/> <!-- ',' -->
                <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                             'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                             'castable' | 'child' | 'comment' | 'descendant' |
                                                                                             'descendant-or-self' | 'div' | 'document-node' | 'element' |
                                                                                             'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                             'following' | 'following-sibling' | 'for' | 'function' | 'ge' |
                                                                                             'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                             'le' | 'let' | 'lt' | 'map' | 'mod' | 'namespace' |
                                                                                             'namespace-node' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                             'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                             'satisfies' | 'schema-attribute' | 'schema-element' | 'self' |
                                                                                             'some' | 'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                                                             'union' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-TypeName($input, $state)
                "/>
                <xsl:variable name="state" select="p:lookahead1W(20, $input, $state)"/> <!-- S^WS | ('(' ':') | ')' | '?' -->
                <xsl:variable name="state" as="item()+">
                  <xsl:choose>
                    <xsl:when test="$state[$p:error]">
                      <xsl:sequence select="$state"/>
                    </xsl:when>
                    <xsl:when test="$state[$p:l1] = 40">                            <!-- '?' -->
                      <xsl:variable name="state" select="p:consume(40, $input, $state)"/> <!-- '?' -->
                      <xsl:sequence select="$state"/>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:sequence select="$state"/>
                    </xsl:otherwise>
                  </xsl:choose>
                </xsl:variable>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(6, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ElementTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse DocumentTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-DocumentTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(57, $input, $state)"/>             <!-- 'document-node' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(24, $input, $state)"/>         <!-- S^WS | ('(' ':') | ')' | 'element' | 'schema-element' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 19">                                       <!-- ')' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 58">                                  <!-- 'element' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-ElementTest($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-SchemaElementTest($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(6, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'DocumentTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse KindTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-KindTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 57">                                        <!-- 'document-node' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-DocumentTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 58">                                        <!-- 'element' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ElementTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 49">                                        <!-- 'attribute' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AttributeTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 95">                                        <!-- 'schema-element' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SchemaElementTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 94">                                        <!-- 'schema-attribute' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SchemaAttributeTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 91">                                        <!-- 'processing-instruction' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-PITest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 53">                                        <!-- 'comment' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-CommentTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 99">                                        <!-- 'text' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-TextTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 83">                                        <!-- 'namespace-node' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NamespaceNodeTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AnyKindTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'KindTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ItemType.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ItemType" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] = (47,                                          (: 'array' :)
                                         49,                                          (: 'attribute' :)
                                         53,                                          (: 'comment' :)
                                         57,                                          (: 'document-node' :)
                                         58,                                          (: 'element' :)
                                         67,                                          (: 'function' :)
                                         76,                                          (: 'item' :)
                                         80,                                          (: 'map' :)
                                         83,                                          (: 'namespace-node' :)
                                         85,                                          (: 'node' :)
                                         91,                                          (: 'processing-instruction' :)
                                         94,                                          (: 'schema-attribute' :)
                                         95,                                          (: 'schema-element' :)
                                         99)">                                      <!-- 'text' -->
          <xsl:variable name="state" select="p:lookahead2W(32, $input, $state)"/>   <!-- S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' |
                                                                                         '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' | ']' | 'and' |
                                                                                         'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'union' | '{' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2225                                          (: 'attribute' '(' :)
                     or $state[$p:lk] = 2229                                          (: 'comment' '(' :)
                     or $state[$p:lk] = 2233                                          (: 'document-node' '(' :)
                     or $state[$p:lk] = 2234                                          (: 'element' '(' :)
                     or $state[$p:lk] = 2259                                          (: 'namespace-node' '(' :)
                     or $state[$p:lk] = 2261                                          (: 'node' '(' :)
                     or $state[$p:lk] = 2267                                          (: 'processing-instruction' '(' :)
                     or $state[$p:lk] = 2270                                          (: 'schema-attribute' '(' :)
                     or $state[$p:lk] = 2271                                          (: 'schema-element' '(' :)
                     or $state[$p:lk] = 2275">                                      <!-- 'text' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-KindTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2252">                                      <!-- 'item' '(' -->
          <xsl:variable name="state" select="p:consume(76, $input, $state)"/>       <!-- 'item' -->
          <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>    <!-- S^WS | '(' | ('(' ':') -->
          <xsl:variable name="state" select="p:consume(17, $input, $state)"/>       <!-- '(' -->
          <xsl:variable name="state" select="p:lookahead1W(6, $input, $state)"/>    <!-- S^WS | ('(' ':') | ')' -->
          <xsl:variable name="state" select="p:consume(19, $input, $state)"/>       <!-- ')' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2243">                                      <!-- 'function' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-FunctionTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2256">                                      <!-- 'map' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-MapTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2223">                                      <!-- 'array' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ArrayTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 17">                                        <!-- '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ParenthesizedItemType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AtomicOrUnionType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ItemType', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SequenceType.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SequenceType" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 60">                                       <!-- 'empty-sequence' -->
          <xsl:variable name="state" select="p:lookahead2W(32, $input, $state)"/>   <!-- S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' |
                                                                                         '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' | ']' | 'and' |
                                                                                         'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'union' | '{' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2236">                                      <!-- 'empty-sequence' '(' -->
          <xsl:variable name="state" select="p:consume(60, $input, $state)"/>       <!-- 'empty-sequence' -->
          <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>    <!-- S^WS | '(' | ('(' ':') -->
          <xsl:variable name="state" select="p:consume(17, $input, $state)"/>       <!-- '(' -->
          <xsl:variable name="state" select="p:lookahead1W(6, $input, $state)"/>    <!-- S^WS | ('(' ':') | ')' -->
          <xsl:variable name="state" select="p:consume(19, $input, $state)"/>       <!-- ')' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ItemType($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(30, $input, $state)"/>   <!-- S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' | '<' |
                                                                                         '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' | ']' | 'and' | 'div' |
                                                                                         'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'union' | '{' | '|' | '||' | '}' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 20                                      (: '*' :)
                           or $state[$p:l1] = 21                                      (: '+' :)
                           or $state[$p:l1] = 40">                                  <!-- '?' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-OccurrenceIndicator($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SequenceType', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TypeDeclaration.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TypeDeclaration" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(48, $input, $state)"/>             <!-- 'as' -->
    <xsl:variable name="state" select="p:lookahead1W(46, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SequenceType($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TypeDeclaration', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Param.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Param" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '$' -->
    <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EQName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(23, $input, $state)"/>         <!-- S^WS | ('(' ':') | ')' | ',' | 'as' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 48">                                        <!-- 'as' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeDeclaration($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Param', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production ParamList (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ParamList-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(19, $input, $state)"/>     <!-- S^WS | ('(' ':') | ')' | ',' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>  <!-- S^WS | '$' | ('(' ':') -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-Param($input, $state)
            "/>
            <xsl:sequence select="p:parse-ParamList-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse ParamList.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ParamList" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-Param($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-ParamList-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ParamList', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse InlineFunctionExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-InlineFunctionExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(67, $input, $state)"/>             <!-- 'function' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(18, $input, $state)"/>         <!-- S^WS | '$' | ('(' ':') | ')' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 16">                                        <!-- '$' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ParamList($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="state" select="p:lookahead1W(21, $input, $state)"/>         <!-- S^WS | ('(' ':') | 'as' | '{' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 48">                                        <!-- 'as' -->
          <xsl:variable name="state" select="p:consume(48, $input, $state)"/>       <!-- 'as' -->
          <xsl:variable name="state" select="p:lookahead1W(46, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SequenceType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(15, $input, $state)"/>         <!-- S^WS | ('(' ':') | '{' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-FunctionBody($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'InlineFunctionExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse NamedFunctionRef.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NamedFunctionRef" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-FunctionEQName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '#' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(15, $input, $state)"/>             <!-- '#' -->
    <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>          <!-- IntegerLiteral | S^WS | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(2, $input, $state)"/>              <!-- IntegerLiteral -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NamedFunctionRef', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FunctionItemExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionItemExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 67">                                        <!-- 'function' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-InlineFunctionExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NamedFunctionRef($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionItemExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ArgumentPlaceholder.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArgumentPlaceholder" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(40, $input, $state)"/>             <!-- '?' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ArgumentPlaceholder', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Argument.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Argument" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 40">                                       <!-- '?' -->
          <xsl:variable name="state" select="p:lookahead2W(26, $input, $state)"/>   <!-- IntegerLiteral | NCName | S^WS | '(' | ('(' ':') | ')' | '*' | ',' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2472                                          (: '?' ')' :)
                     or $state[$p:lk] = 2856">                                      <!-- '?' ',' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ArgumentPlaceholder($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ExprSingle($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Argument', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production ArgumentList (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArgumentList-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(19, $input, $state)"/>     <!-- S^WS | ('(' ':') | ')' | ',' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-Argument($input, $state)
            "/>
            <xsl:sequence select="p:parse-ArgumentList-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse ArgumentList.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArgumentList" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(56, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | ')' | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' |
                                                                                         '[' | 'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 19">                                       <!-- ')' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-Argument($input, $state)
          "/>
          <xsl:variable name="state" select="p:parse-ArgumentList-1($input, $state)"/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ArgumentList', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FunctionEQName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionEQName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 6">                                         <!-- URIQualifiedName -->
          <xsl:variable name="state" select="p:consume(6, $input, $state)"/>        <!-- URIQualifiedName -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-FunctionName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionEQName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FunctionCall.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionCall" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-FunctionEQName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ArgumentList($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionCall', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ContextItemExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ContextItemExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(24, $input, $state)"/>             <!-- '.' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ContextItemExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ParenthesizedExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ParenthesizedExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(56, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | ')' | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' |
                                                                                         '[' | 'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 19">                                       <!-- ')' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-Expr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ParenthesizedExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse VarRef.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-VarRef" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '$' -->
    <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-VarName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'VarRef', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse NumericLiteral.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NumericLiteral" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 2">                                         <!-- IntegerLiteral -->
          <xsl:variable name="state" select="p:consume(2, $input, $state)"/>        <!-- IntegerLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 3">                                         <!-- DecimalLiteral -->
          <xsl:variable name="state" select="p:consume(3, $input, $state)"/>        <!-- DecimalLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(4, $input, $state)"/>        <!-- DoubleLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NumericLiteral', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Literal.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Literal" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 5">                                         <!-- StringLiteral -->
          <xsl:variable name="state" select="p:consume(5, $input, $state)"/>        <!-- StringLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NumericLiteral($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Literal', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse PrimaryExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PrimaryExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] = (6,                                           (: URIQualifiedName :)
                                         8,                                           (: QName^Token :)
                                         44,                                          (: 'ancestor' :)
                                         45,                                          (: 'ancestor-or-self' :)
                                         46,                                          (: 'and' :)
                                         50,                                          (: 'cast' :)
                                         51,                                          (: 'castable' :)
                                         52,                                          (: 'child' :)
                                         54,                                          (: 'descendant' :)
                                         55,                                          (: 'descendant-or-self' :)
                                         56,                                          (: 'div' :)
                                         59,                                          (: 'else' :)
                                         61,                                          (: 'eq' :)
                                         62,                                          (: 'every' :)
                                         63,                                          (: 'except' :)
                                         64,                                          (: 'following' :)
                                         65,                                          (: 'following-sibling' :)
                                         66,                                          (: 'for' :)
                                         68,                                          (: 'ge' :)
                                         69,                                          (: 'gt' :)
                                         70,                                          (: 'idiv' :)
                                         73,                                          (: 'instance' :)
                                         74,                                          (: 'intersect' :)
                                         75,                                          (: 'is' :)
                                         77,                                          (: 'le' :)
                                         78,                                          (: 'let' :)
                                         79,                                          (: 'lt' :)
                                         81,                                          (: 'mod' :)
                                         82,                                          (: 'namespace' :)
                                         84,                                          (: 'ne' :)
                                         87,                                          (: 'or' :)
                                         88,                                          (: 'parent' :)
                                         89,                                          (: 'preceding' :)
                                         90,                                          (: 'preceding-sibling' :)
                                         92,                                          (: 'return' :)
                                         93,                                          (: 'satisfies' :)
                                         96,                                          (: 'self' :)
                                         97,                                          (: 'some' :)
                                         101,                                         (: 'to' :)
                                         102,                                         (: 'treat' :)
                                         104)">                                     <!-- 'union' -->
          <xsl:variable name="state" select="p:lookahead2W(17, $input, $state)"/>   <!-- S^WS | '#' | '(' | ('(' ':') -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2                                             (: IntegerLiteral :)
                     or $state[$p:lk] = 3                                             (: DecimalLiteral :)
                     or $state[$p:lk] = 4                                             (: DoubleLiteral :)
                     or $state[$p:lk] = 5">                                         <!-- StringLiteral -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-Literal($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 16">                                        <!-- '$' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-VarRef($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 17">                                        <!-- '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ParenthesizedExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 24">                                        <!-- '.' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ContextItemExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2182                                          (: URIQualifiedName '(' :)
                     or $state[$p:lk] = 2184                                          (: QName^Token '(' :)
                     or $state[$p:lk] = 2220                                          (: 'ancestor' '(' :)
                     or $state[$p:lk] = 2221                                          (: 'ancestor-or-self' '(' :)
                     or $state[$p:lk] = 2222                                          (: 'and' '(' :)
                     or $state[$p:lk] = 2226                                          (: 'cast' '(' :)
                     or $state[$p:lk] = 2227                                          (: 'castable' '(' :)
                     or $state[$p:lk] = 2228                                          (: 'child' '(' :)
                     or $state[$p:lk] = 2230                                          (: 'descendant' '(' :)
                     or $state[$p:lk] = 2231                                          (: 'descendant-or-self' '(' :)
                     or $state[$p:lk] = 2232                                          (: 'div' '(' :)
                     or $state[$p:lk] = 2235                                          (: 'else' '(' :)
                     or $state[$p:lk] = 2237                                          (: 'eq' '(' :)
                     or $state[$p:lk] = 2238                                          (: 'every' '(' :)
                     or $state[$p:lk] = 2239                                          (: 'except' '(' :)
                     or $state[$p:lk] = 2240                                          (: 'following' '(' :)
                     or $state[$p:lk] = 2241                                          (: 'following-sibling' '(' :)
                     or $state[$p:lk] = 2242                                          (: 'for' '(' :)
                     or $state[$p:lk] = 2244                                          (: 'ge' '(' :)
                     or $state[$p:lk] = 2245                                          (: 'gt' '(' :)
                     or $state[$p:lk] = 2246                                          (: 'idiv' '(' :)
                     or $state[$p:lk] = 2249                                          (: 'instance' '(' :)
                     or $state[$p:lk] = 2250                                          (: 'intersect' '(' :)
                     or $state[$p:lk] = 2251                                          (: 'is' '(' :)
                     or $state[$p:lk] = 2253                                          (: 'le' '(' :)
                     or $state[$p:lk] = 2254                                          (: 'let' '(' :)
                     or $state[$p:lk] = 2255                                          (: 'lt' '(' :)
                     or $state[$p:lk] = 2257                                          (: 'mod' '(' :)
                     or $state[$p:lk] = 2258                                          (: 'namespace' '(' :)
                     or $state[$p:lk] = 2260                                          (: 'ne' '(' :)
                     or $state[$p:lk] = 2263                                          (: 'or' '(' :)
                     or $state[$p:lk] = 2264                                          (: 'parent' '(' :)
                     or $state[$p:lk] = 2265                                          (: 'preceding' '(' :)
                     or $state[$p:lk] = 2266                                          (: 'preceding-sibling' '(' :)
                     or $state[$p:lk] = 2268                                          (: 'return' '(' :)
                     or $state[$p:lk] = 2269                                          (: 'satisfies' '(' :)
                     or $state[$p:lk] = 2272                                          (: 'self' '(' :)
                     or $state[$p:lk] = 2273                                          (: 'some' '(' :)
                     or $state[$p:lk] = 2277                                          (: 'to' '(' :)
                     or $state[$p:lk] = 2278                                          (: 'treat' '(' :)
                     or $state[$p:lk] = 2280">                                      <!-- 'union' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-FunctionCall($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 80">                                        <!-- 'map' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-MapConstructor($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 42                                            (: '[' :)
                     or $state[$p:lk] = 47">                                        <!-- 'array' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ArrayConstructor($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 40">                                        <!-- '?' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-UnaryLookup($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-FunctionItemExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PrimaryExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production PostfixExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PostfixExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(41, $input, $state)"/>     <!-- S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                                                         '?' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' | 'eq' |
                                                                                         'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                                                         'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' |
                                                                                         'treat' | 'union' | '|' | '||' | '}' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 17                                         (: '(' :)
                      and $state[$p:l1] != 40                                         (: '?' :)
                      and $state[$p:l1] != 42">                                     <!-- '[' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 42">                                <!-- '[' -->
                  <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                  <xsl:variable name="state" select="
                    if ($state[$p:error]) then
                      $state
                    else
                      p:parse-Predicate($input, $state)
                  "/>
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 17">                                <!-- '(' -->
                  <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                  <xsl:variable name="state" select="
                    if ($state[$p:error]) then
                      $state
                    else
                      p:parse-ArgumentList($input, $state)
                  "/>
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                  <xsl:variable name="state" select="
                    if ($state[$p:error]) then
                      $state
                    else
                      p:parse-Lookup($input, $state)
                  "/>
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:sequence select="p:parse-PostfixExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse PostfixExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PostfixExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-PrimaryExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-PostfixExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PostfixExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse StepExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-StepExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 67">                                       <!-- 'function' -->
          <xsl:variable name="state" select="p:lookahead2W(36, $input, $state)"/>   <!-- S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                                                         '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' | 'eq' |
                                                                                         'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                                                         'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' |
                                                                                         'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = (47,                                          (: 'array' :)
                                         80)">                                      <!-- 'map' -->
          <xsl:variable name="state" select="p:lookahead2W(38, $input, $state)"/>   <!-- S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' |
                                                                                         '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                                                         ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' | 'eq' | 'except' |
                                                                                         'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'lt' |
                                                                                         'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' | 'treat' |
                                                                                         'union' | '{' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = (44,                                          (: 'ancestor' :)
                                         45,                                          (: 'ancestor-or-self' :)
                                         52,                                          (: 'child' :)
                                         54,                                          (: 'descendant' :)
                                         55,                                          (: 'descendant-or-self' :)
                                         64,                                          (: 'following' :)
                                         65,                                          (: 'following-sibling' :)
                                         82,                                          (: 'namespace' :)
                                         88,                                          (: 'parent' :)
                                         89,                                          (: 'preceding' :)
                                         90,                                          (: 'preceding-sibling' :)
                                         96)">                                      <!-- 'self' -->
          <xsl:variable name="state" select="p:lookahead2W(43, $input, $state)"/>   <!-- S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                                                         '-' | '/' | '//' | ':' | '::' | '<' | '<<' | '<=' | '=' | '=>' | '>' |
                                                                                         '>=' | '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' |
                                                                                         'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = (6,                                           (: URIQualifiedName :)
                                         8,                                           (: QName^Token :)
                                         46,                                          (: 'and' :)
                                         50,                                          (: 'cast' :)
                                         51,                                          (: 'castable' :)
                                         56,                                          (: 'div' :)
                                         59,                                          (: 'else' :)
                                         61,                                          (: 'eq' :)
                                         62,                                          (: 'every' :)
                                         63,                                          (: 'except' :)
                                         66,                                          (: 'for' :)
                                         68,                                          (: 'ge' :)
                                         69,                                          (: 'gt' :)
                                         70,                                          (: 'idiv' :)
                                         73,                                          (: 'instance' :)
                                         74,                                          (: 'intersect' :)
                                         75,                                          (: 'is' :)
                                         77,                                          (: 'le' :)
                                         78,                                          (: 'let' :)
                                         79,                                          (: 'lt' :)
                                         81,                                          (: 'mod' :)
                                         84,                                          (: 'ne' :)
                                         87,                                          (: 'or' :)
                                         92,                                          (: 'return' :)
                                         93,                                          (: 'satisfies' :)
                                         97,                                          (: 'some' :)
                                         101,                                         (: 'to' :)
                                         102,                                         (: 'treat' :)
                                         104)">                                     <!-- 'union' -->
          <xsl:variable name="state" select="p:lookahead2W(39, $input, $state)"/>   <!-- S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                                                         '-' | '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' |
                                                                                         '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                                                         'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                                                         'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2                                             (: IntegerLiteral :)
                     or $state[$p:lk] = 3                                             (: DecimalLiteral :)
                     or $state[$p:lk] = 4                                             (: DoubleLiteral :)
                     or $state[$p:lk] = 5                                             (: StringLiteral :)
                     or $state[$p:lk] = 16                                            (: '$' :)
                     or $state[$p:lk] = 17                                            (: '(' :)
                     or $state[$p:lk] = 24                                            (: '.' :)
                     or $state[$p:lk] = 40                                            (: '?' :)
                     or $state[$p:lk] = 42                                            (: '[' :)
                     or $state[$p:lk] = 1926                                          (: URIQualifiedName '#' :)
                     or $state[$p:lk] = 1928                                          (: QName^Token '#' :)
                     or $state[$p:lk] = 1964                                          (: 'ancestor' '#' :)
                     or $state[$p:lk] = 1965                                          (: 'ancestor-or-self' '#' :)
                     or $state[$p:lk] = 1966                                          (: 'and' '#' :)
                     or $state[$p:lk] = 1970                                          (: 'cast' '#' :)
                     or $state[$p:lk] = 1971                                          (: 'castable' '#' :)
                     or $state[$p:lk] = 1972                                          (: 'child' '#' :)
                     or $state[$p:lk] = 1974                                          (: 'descendant' '#' :)
                     or $state[$p:lk] = 1975                                          (: 'descendant-or-self' '#' :)
                     or $state[$p:lk] = 1976                                          (: 'div' '#' :)
                     or $state[$p:lk] = 1979                                          (: 'else' '#' :)
                     or $state[$p:lk] = 1981                                          (: 'eq' '#' :)
                     or $state[$p:lk] = 1982                                          (: 'every' '#' :)
                     or $state[$p:lk] = 1983                                          (: 'except' '#' :)
                     or $state[$p:lk] = 1984                                          (: 'following' '#' :)
                     or $state[$p:lk] = 1985                                          (: 'following-sibling' '#' :)
                     or $state[$p:lk] = 1986                                          (: 'for' '#' :)
                     or $state[$p:lk] = 1988                                          (: 'ge' '#' :)
                     or $state[$p:lk] = 1989                                          (: 'gt' '#' :)
                     or $state[$p:lk] = 1990                                          (: 'idiv' '#' :)
                     or $state[$p:lk] = 1993                                          (: 'instance' '#' :)
                     or $state[$p:lk] = 1994                                          (: 'intersect' '#' :)
                     or $state[$p:lk] = 1995                                          (: 'is' '#' :)
                     or $state[$p:lk] = 1997                                          (: 'le' '#' :)
                     or $state[$p:lk] = 1998                                          (: 'let' '#' :)
                     or $state[$p:lk] = 1999                                          (: 'lt' '#' :)
                     or $state[$p:lk] = 2001                                          (: 'mod' '#' :)
                     or $state[$p:lk] = 2002                                          (: 'namespace' '#' :)
                     or $state[$p:lk] = 2004                                          (: 'ne' '#' :)
                     or $state[$p:lk] = 2007                                          (: 'or' '#' :)
                     or $state[$p:lk] = 2008                                          (: 'parent' '#' :)
                     or $state[$p:lk] = 2009                                          (: 'preceding' '#' :)
                     or $state[$p:lk] = 2010                                          (: 'preceding-sibling' '#' :)
                     or $state[$p:lk] = 2012                                          (: 'return' '#' :)
                     or $state[$p:lk] = 2013                                          (: 'satisfies' '#' :)
                     or $state[$p:lk] = 2016                                          (: 'self' '#' :)
                     or $state[$p:lk] = 2017                                          (: 'some' '#' :)
                     or $state[$p:lk] = 2021                                          (: 'to' '#' :)
                     or $state[$p:lk] = 2022                                          (: 'treat' '#' :)
                     or $state[$p:lk] = 2024                                          (: 'union' '#' :)
                     or $state[$p:lk] = 2182                                          (: URIQualifiedName '(' :)
                     or $state[$p:lk] = 2184                                          (: QName^Token '(' :)
                     or $state[$p:lk] = 2220                                          (: 'ancestor' '(' :)
                     or $state[$p:lk] = 2221                                          (: 'ancestor-or-self' '(' :)
                     or $state[$p:lk] = 2222                                          (: 'and' '(' :)
                     or $state[$p:lk] = 2226                                          (: 'cast' '(' :)
                     or $state[$p:lk] = 2227                                          (: 'castable' '(' :)
                     or $state[$p:lk] = 2228                                          (: 'child' '(' :)
                     or $state[$p:lk] = 2230                                          (: 'descendant' '(' :)
                     or $state[$p:lk] = 2231                                          (: 'descendant-or-self' '(' :)
                     or $state[$p:lk] = 2232                                          (: 'div' '(' :)
                     or $state[$p:lk] = 2235                                          (: 'else' '(' :)
                     or $state[$p:lk] = 2237                                          (: 'eq' '(' :)
                     or $state[$p:lk] = 2238                                          (: 'every' '(' :)
                     or $state[$p:lk] = 2239                                          (: 'except' '(' :)
                     or $state[$p:lk] = 2240                                          (: 'following' '(' :)
                     or $state[$p:lk] = 2241                                          (: 'following-sibling' '(' :)
                     or $state[$p:lk] = 2242                                          (: 'for' '(' :)
                     or $state[$p:lk] = 2243                                          (: 'function' '(' :)
                     or $state[$p:lk] = 2244                                          (: 'ge' '(' :)
                     or $state[$p:lk] = 2245                                          (: 'gt' '(' :)
                     or $state[$p:lk] = 2246                                          (: 'idiv' '(' :)
                     or $state[$p:lk] = 2249                                          (: 'instance' '(' :)
                     or $state[$p:lk] = 2250                                          (: 'intersect' '(' :)
                     or $state[$p:lk] = 2251                                          (: 'is' '(' :)
                     or $state[$p:lk] = 2253                                          (: 'le' '(' :)
                     or $state[$p:lk] = 2254                                          (: 'let' '(' :)
                     or $state[$p:lk] = 2255                                          (: 'lt' '(' :)
                     or $state[$p:lk] = 2257                                          (: 'mod' '(' :)
                     or $state[$p:lk] = 2258                                          (: 'namespace' '(' :)
                     or $state[$p:lk] = 2260                                          (: 'ne' '(' :)
                     or $state[$p:lk] = 2263                                          (: 'or' '(' :)
                     or $state[$p:lk] = 2264                                          (: 'parent' '(' :)
                     or $state[$p:lk] = 2265                                          (: 'preceding' '(' :)
                     or $state[$p:lk] = 2266                                          (: 'preceding-sibling' '(' :)
                     or $state[$p:lk] = 2268                                          (: 'return' '(' :)
                     or $state[$p:lk] = 2269                                          (: 'satisfies' '(' :)
                     or $state[$p:lk] = 2272                                          (: 'self' '(' :)
                     or $state[$p:lk] = 2273                                          (: 'some' '(' :)
                     or $state[$p:lk] = 2277                                          (: 'to' '(' :)
                     or $state[$p:lk] = 2278                                          (: 'treat' '(' :)
                     or $state[$p:lk] = 2280                                          (: 'union' '(' :)
                     or $state[$p:lk] = 13487                                         (: 'array' '{' :)
                     or $state[$p:lk] = 13520">                                     <!-- 'map' '{' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-PostfixExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AxisStep($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'StepExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production RelativePathExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-RelativePathExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 26                                         (: '/' :)
                      and $state[$p:l1] != 27">                                     <!-- '//' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 26">                                <!-- '/' -->
                  <xsl:variable name="state" select="p:consume(26, $input, $state)"/> <!-- '/' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(27, $input, $state)"/> <!-- '//' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '.' | '..' | '?' | '@' | '[' | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-StepExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-RelativePathExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse RelativePathExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-RelativePathExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-StepExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-RelativePathExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'RelativePathExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse PathExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PathExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 26">                                        <!-- '/' -->
          <xsl:variable name="state" select="p:consume(26, $input, $state)"/>       <!-- '/' -->
          <xsl:variable name="state" select="p:lookahead1W(59, $input, $state)"/>   <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '!' | '!=' | '$' |
                                                                                         '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | '.' | '..' | ':' |
                                                                                         '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '?' | '@' | '[' |
                                                                                         ']' | 'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' | '|' | '||' | '}' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 13                                      (: '!' :)
                           or $state[$p:l1] = 14                                      (: '!=' :)
                           or $state[$p:l1] = 19                                      (: ')' :)
                           or $state[$p:l1] = 20                                      (: '*' :)
                           or $state[$p:l1] = 21                                      (: '+' :)
                           or $state[$p:l1] = 22                                      (: ',' :)
                           or $state[$p:l1] = 23                                      (: '-' :)
                           or $state[$p:l1] = 28                                      (: ':' :)
                           or $state[$p:l1] = 32                                      (: '&lt;' :)
                           or $state[$p:l1] = 33                                      (: '&lt;&lt;' :)
                           or $state[$p:l1] = 34                                      (: '&lt;=' :)
                           or $state[$p:l1] = 35                                      (: '=' :)
                           or $state[$p:l1] = 36                                      (: '=>' :)
                           or $state[$p:l1] = 37                                      (: '>' :)
                           or $state[$p:l1] = 38                                      (: '>=' :)
                           or $state[$p:l1] = 39                                      (: '>>' :)
                           or $state[$p:l1] = 43                                      (: ']' :)
                           or $state[$p:l1] = 106                                     (: '|' :)
                           or $state[$p:l1] = 107                                     (: '||' :)
                           or $state[$p:l1] = 108">                                 <!-- '}' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-RelativePathExpr($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 27">                                        <!-- '//' -->
          <xsl:variable name="state" select="p:consume(27, $input, $state)"/>       <!-- '//' -->
          <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/>   <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '.' | '..' | '?' | '@' | '[' | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-RelativePathExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-RelativePathExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PathExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production SimpleMapExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleMapExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 13">                                     <!-- '!' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(13, $input, $state)"/>     <!-- '!' -->
            <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '.' | '..' | '/' | '//' | '?' | '@' | '[' | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-PathExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-SimpleMapExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse SimpleMapExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleMapExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-PathExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-SimpleMapExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SimpleMapExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ValueExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ValueExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SimpleMapExpr($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ValueExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production UnaryExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-UnaryExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/>     <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 21                                         (: '+' :)
                      and $state[$p:l1] != 23">                                     <!-- '-' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 23">                                <!-- '-' -->
                  <xsl:variable name="state" select="p:consume(23, $input, $state)"/> <!-- '-' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(21, $input, $state)"/> <!-- '+' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:sequence select="p:parse-UnaryExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse UnaryExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-UnaryExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:parse-UnaryExpr-1($input, $state)"/>
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ValueExpr($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'UnaryExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production ArrowExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArrowExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(34, $input, $state)"/>     <!-- S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' | '<' |
                                                                                         '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | ']' | 'and' | 'cast' |
                                                                                         'castable' | 'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                                                         'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' |
                                                                                         'return' | 'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' |
                                                                                         '}' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 36">                                     <!-- '=>' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(36, $input, $state)"/>     <!-- '=>' -->
            <xsl:variable name="state" select="p:lookahead1W(48, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | '$' | '(' | ('(' ':') |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ArrowFunctionSpecifier($input, $state)
            "/>
            <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>  <!-- S^WS | '(' | ('(' ':') -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ArgumentList($input, $state)
            "/>
            <xsl:sequence select="p:parse-ArrowExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse ArrowExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArrowExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-UnaryExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-ArrowExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ArrowExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse CastExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-CastExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ArrowExpr($input, $state)
    "/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 50">                                        <!-- 'cast' -->
          <xsl:variable name="state" select="p:consume(50, $input, $state)"/>       <!-- 'cast' -->
          <xsl:variable name="state" select="p:lookahead1W(11, $input, $state)"/>   <!-- S^WS | ('(' ':') | 'as' -->
          <xsl:variable name="state" select="p:consume(48, $input, $state)"/>       <!-- 'as' -->
          <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SingleType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'CastExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse CastableExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-CastableExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-CastExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(31, $input, $state)"/>         <!-- S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' | '<' |
                                                                                         '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' | 'castable' |
                                                                                         'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' | '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 51">                                        <!-- 'castable' -->
          <xsl:variable name="state" select="p:consume(51, $input, $state)"/>       <!-- 'castable' -->
          <xsl:variable name="state" select="p:lookahead1W(11, $input, $state)"/>   <!-- S^WS | ('(' ':') | 'as' -->
          <xsl:variable name="state" select="p:consume(48, $input, $state)"/>       <!-- 'as' -->
          <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SingleType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'CastableExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TreatExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TreatExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-CastableExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(29, $input, $state)"/>         <!-- S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' | '<' |
                                                                                         '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                                                         'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                                                         'to' | 'treat' | 'union' | '|' | '||' | '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 102">                                       <!-- 'treat' -->
          <xsl:variable name="state" select="p:consume(102, $input, $state)"/>      <!-- 'treat' -->
          <xsl:variable name="state" select="p:lookahead1W(11, $input, $state)"/>   <!-- S^WS | ('(' ':') | 'as' -->
          <xsl:variable name="state" select="p:consume(48, $input, $state)"/>       <!-- 'as' -->
          <xsl:variable name="state" select="p:lookahead1W(46, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SequenceType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TreatExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse InstanceofExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-InstanceofExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-TreatExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(28, $input, $state)"/>         <!-- S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' | '<' |
                                                                                         '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                                                         'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                                                         'to' | 'union' | '|' | '||' | '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 73">                                        <!-- 'instance' -->
          <xsl:variable name="state" select="p:consume(73, $input, $state)"/>       <!-- 'instance' -->
          <xsl:variable name="state" select="p:lookahead1W(13, $input, $state)"/>   <!-- S^WS | ('(' ':') | 'of' -->
          <xsl:variable name="state" select="p:consume(86, $input, $state)"/>       <!-- 'of' -->
          <xsl:variable name="state" select="p:lookahead1W(46, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SequenceType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'InstanceofExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-IntersectExceptExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(27, $input, $state)"/>     <!-- S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' | '<' |
                                                                                         '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'intersect' | 'is' | 'le' |
                                                                                         'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' | 'union' |
                                                                                         '|' | '||' | '}' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 63                                         (: 'except' :)
                      and $state[$p:l1] != 74">                                     <!-- 'intersect' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 74">                                <!-- 'intersect' -->
                  <xsl:variable name="state" select="p:consume(74, $input, $state)"/> <!-- 'intersect' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(63, $input, $state)"/> <!-- 'except' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-InstanceofExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-IntersectExceptExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse IntersectExceptExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-IntersectExceptExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-InstanceofExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-IntersectExceptExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'IntersectExceptExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production UnionExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-UnionExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 104                                        (: 'union' :)
                      and $state[$p:l1] != 106">                                    <!-- '|' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 104">                               <!-- 'union' -->
                  <xsl:variable name="state" select="p:consume(104, $input, $state)"/> <!-- 'union' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(106, $input, $state)"/> <!-- '|' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-IntersectExceptExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-UnionExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse UnionExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-UnionExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-IntersectExceptExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-UnionExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'UnionExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MultiplicativeExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 20                                         (: '*' :)
                      and $state[$p:l1] != 56                                         (: 'div' :)
                      and $state[$p:l1] != 70                                         (: 'idiv' :)
                      and $state[$p:l1] != 81">                                     <!-- 'mod' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 20">                                <!-- '*' -->
                  <xsl:variable name="state" select="p:consume(20, $input, $state)"/> <!-- '*' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 56">                                <!-- 'div' -->
                  <xsl:variable name="state" select="p:consume(56, $input, $state)"/> <!-- 'div' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 70">                                <!-- 'idiv' -->
                  <xsl:variable name="state" select="p:consume(70, $input, $state)"/> <!-- 'idiv' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(81, $input, $state)"/> <!-- 'mod' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-UnionExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-MultiplicativeExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse MultiplicativeExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MultiplicativeExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-UnionExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-MultiplicativeExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'MultiplicativeExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production AdditiveExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AdditiveExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 21                                         (: '+' :)
                      and $state[$p:l1] != 23">                                     <!-- '-' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 21">                                <!-- '+' -->
                  <xsl:variable name="state" select="p:consume(21, $input, $state)"/> <!-- '+' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(23, $input, $state)"/> <!-- '-' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-MultiplicativeExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-AdditiveExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse AdditiveExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AdditiveExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-MultiplicativeExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-AdditiveExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AdditiveExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse RangeExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-RangeExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AdditiveExpr($input, $state)
    "/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 101">                                       <!-- 'to' -->
          <xsl:variable name="state" select="p:consume(101, $input, $state)"/>      <!-- 'to' -->
          <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/>   <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AdditiveExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'RangeExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production StringConcatExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-StringConcatExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 107">                                    <!-- '||' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(107, $input, $state)"/>    <!-- '||' -->
            <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-RangeExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-StringConcatExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse StringConcatExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-StringConcatExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-RangeExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-StringConcatExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'StringConcatExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ComparisonExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ComparisonExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-StringConcatExpr($input, $state)
    "/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 19                                           (: ')' :)
                    and $state[$p:l1] != 22                                           (: ',' :)
                    and $state[$p:l1] != 28                                           (: ':' :)
                    and $state[$p:l1] != 43                                           (: ']' :)
                    and $state[$p:l1] != 46                                           (: 'and' :)
                    and $state[$p:l1] != 59                                           (: 'else' :)
                    and $state[$p:l1] != 87                                           (: 'or' :)
                    and $state[$p:l1] != 92                                           (: 'return' :)
                    and $state[$p:l1] != 93                                           (: 'satisfies' :)
                    and $state[$p:l1] != 108">                                      <!-- '}' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 61                                      (: 'eq' :)
                           or $state[$p:l1] = 68                                      (: 'ge' :)
                           or $state[$p:l1] = 69                                      (: 'gt' :)
                           or $state[$p:l1] = 77                                      (: 'le' :)
                           or $state[$p:l1] = 79                                      (: 'lt' :)
                           or $state[$p:l1] = 84">                                  <!-- 'ne' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-ValueComp($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 33                                      (: '&lt;&lt;' :)
                           or $state[$p:l1] = 39                                      (: '>>' :)
                           or $state[$p:l1] = 75">                                  <!-- 'is' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-NodeComp($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-GeneralComp($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/>   <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-StringConcatExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ComparisonExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production AndExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AndExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 46">                                     <!-- 'and' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(46, $input, $state)"/>     <!-- 'and' -->
            <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ComparisonExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-AndExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse AndExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AndExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ComparisonExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-AndExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AndExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production OrExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-OrExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 87">                                     <!-- 'or' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(87, $input, $state)"/>     <!-- 'or' -->
            <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-AndExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-OrExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse OrExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-OrExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AndExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-OrExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'OrExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse IfExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-IfExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(71, $input, $state)"/>             <!-- 'if' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-Expr($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="state" select="p:lookahead1W(14, $input, $state)"/>         <!-- S^WS | ('(' ':') | 'then' -->
    <xsl:variable name="state" select="p:consume(100, $input, $state)"/>            <!-- 'then' -->
    <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(59, $input, $state)"/>             <!-- 'else' -->
    <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'IfExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production QuantifiedExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-QuantifiedExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>  <!-- S^WS | '$' | ('(' ':') -->
            <xsl:variable name="state" select="p:consume(16, $input, $state)"/>     <!-- '$' -->
            <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-VarName($input, $state)
            "/>
            <xsl:variable name="state" select="p:lookahead1W(12, $input, $state)"/> <!-- S^WS | ('(' ':') | 'in' -->
            <xsl:variable name="state" select="p:consume(72, $input, $state)"/>     <!-- 'in' -->
            <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ExprSingle($input, $state)
            "/>
            <xsl:sequence select="p:parse-QuantifiedExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse QuantifiedExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-QuantifiedExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 97">                                        <!-- 'some' -->
          <xsl:variable name="state" select="p:consume(97, $input, $state)"/>       <!-- 'some' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(62, $input, $state)"/>       <!-- 'every' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | '$' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '$' -->
    <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-VarName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(12, $input, $state)"/>         <!-- S^WS | ('(' ':') | 'in' -->
    <xsl:variable name="state" select="p:consume(72, $input, $state)"/>             <!-- 'in' -->
    <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-QuantifiedExpr-1($input, $state)"/>
    <xsl:variable name="state" select="p:consume(93, $input, $state)"/>             <!-- 'satisfies' -->
    <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'QuantifiedExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SimpleLetBinding.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleLetBinding" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '$' -->
    <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-VarName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(10, $input, $state)"/>         <!-- S^WS | ('(' ':') | ':=' -->
    <xsl:variable name="state" select="p:consume(31, $input, $state)"/>             <!-- ':=' -->
    <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SimpleLetBinding', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production SimpleLetClause (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleLetClause-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>  <!-- S^WS | '$' | ('(' ':') -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-SimpleLetBinding($input, $state)
            "/>
            <xsl:sequence select="p:parse-SimpleLetClause-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse SimpleLetClause.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleLetClause" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(78, $input, $state)"/>             <!-- 'let' -->
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | '$' | ('(' ':') -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SimpleLetBinding($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-SimpleLetClause-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SimpleLetClause', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse LetExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-LetExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SimpleLetClause($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(92, $input, $state)"/>             <!-- 'return' -->
    <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'LetExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FunctionName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 8">                                         <!-- QName^Token -->
          <xsl:variable name="state" select="p:consume(8, $input, $state)"/>        <!-- QName^Token -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 44">                                        <!-- 'ancestor' -->
          <xsl:variable name="state" select="p:consume(44, $input, $state)"/>       <!-- 'ancestor' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 45">                                        <!-- 'ancestor-or-self' -->
          <xsl:variable name="state" select="p:consume(45, $input, $state)"/>       <!-- 'ancestor-or-self' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 46">                                        <!-- 'and' -->
          <xsl:variable name="state" select="p:consume(46, $input, $state)"/>       <!-- 'and' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 50">                                        <!-- 'cast' -->
          <xsl:variable name="state" select="p:consume(50, $input, $state)"/>       <!-- 'cast' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 51">                                        <!-- 'castable' -->
          <xsl:variable name="state" select="p:consume(51, $input, $state)"/>       <!-- 'castable' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 52">                                        <!-- 'child' -->
          <xsl:variable name="state" select="p:consume(52, $input, $state)"/>       <!-- 'child' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 54">                                        <!-- 'descendant' -->
          <xsl:variable name="state" select="p:consume(54, $input, $state)"/>       <!-- 'descendant' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 55">                                        <!-- 'descendant-or-self' -->
          <xsl:variable name="state" select="p:consume(55, $input, $state)"/>       <!-- 'descendant-or-self' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 56">                                        <!-- 'div' -->
          <xsl:variable name="state" select="p:consume(56, $input, $state)"/>       <!-- 'div' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 59">                                        <!-- 'else' -->
          <xsl:variable name="state" select="p:consume(59, $input, $state)"/>       <!-- 'else' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 61">                                        <!-- 'eq' -->
          <xsl:variable name="state" select="p:consume(61, $input, $state)"/>       <!-- 'eq' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 62">                                        <!-- 'every' -->
          <xsl:variable name="state" select="p:consume(62, $input, $state)"/>       <!-- 'every' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 63">                                        <!-- 'except' -->
          <xsl:variable name="state" select="p:consume(63, $input, $state)"/>       <!-- 'except' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 64">                                        <!-- 'following' -->
          <xsl:variable name="state" select="p:consume(64, $input, $state)"/>       <!-- 'following' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 65">                                        <!-- 'following-sibling' -->
          <xsl:variable name="state" select="p:consume(65, $input, $state)"/>       <!-- 'following-sibling' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 66">                                        <!-- 'for' -->
          <xsl:variable name="state" select="p:consume(66, $input, $state)"/>       <!-- 'for' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 68">                                        <!-- 'ge' -->
          <xsl:variable name="state" select="p:consume(68, $input, $state)"/>       <!-- 'ge' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 69">                                        <!-- 'gt' -->
          <xsl:variable name="state" select="p:consume(69, $input, $state)"/>       <!-- 'gt' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 70">                                        <!-- 'idiv' -->
          <xsl:variable name="state" select="p:consume(70, $input, $state)"/>       <!-- 'idiv' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 73">                                        <!-- 'instance' -->
          <xsl:variable name="state" select="p:consume(73, $input, $state)"/>       <!-- 'instance' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 74">                                        <!-- 'intersect' -->
          <xsl:variable name="state" select="p:consume(74, $input, $state)"/>       <!-- 'intersect' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 75">                                        <!-- 'is' -->
          <xsl:variable name="state" select="p:consume(75, $input, $state)"/>       <!-- 'is' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 77">                                        <!-- 'le' -->
          <xsl:variable name="state" select="p:consume(77, $input, $state)"/>       <!-- 'le' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 78">                                        <!-- 'let' -->
          <xsl:variable name="state" select="p:consume(78, $input, $state)"/>       <!-- 'let' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 79">                                        <!-- 'lt' -->
          <xsl:variable name="state" select="p:consume(79, $input, $state)"/>       <!-- 'lt' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 81">                                        <!-- 'mod' -->
          <xsl:variable name="state" select="p:consume(81, $input, $state)"/>       <!-- 'mod' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 82">                                        <!-- 'namespace' -->
          <xsl:variable name="state" select="p:consume(82, $input, $state)"/>       <!-- 'namespace' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 84">                                        <!-- 'ne' -->
          <xsl:variable name="state" select="p:consume(84, $input, $state)"/>       <!-- 'ne' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 87">                                        <!-- 'or' -->
          <xsl:variable name="state" select="p:consume(87, $input, $state)"/>       <!-- 'or' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 88">                                        <!-- 'parent' -->
          <xsl:variable name="state" select="p:consume(88, $input, $state)"/>       <!-- 'parent' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 89">                                        <!-- 'preceding' -->
          <xsl:variable name="state" select="p:consume(89, $input, $state)"/>       <!-- 'preceding' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 90">                                        <!-- 'preceding-sibling' -->
          <xsl:variable name="state" select="p:consume(90, $input, $state)"/>       <!-- 'preceding-sibling' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 92">                                        <!-- 'return' -->
          <xsl:variable name="state" select="p:consume(92, $input, $state)"/>       <!-- 'return' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 93">                                        <!-- 'satisfies' -->
          <xsl:variable name="state" select="p:consume(93, $input, $state)"/>       <!-- 'satisfies' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 96">                                        <!-- 'self' -->
          <xsl:variable name="state" select="p:consume(96, $input, $state)"/>       <!-- 'self' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 97">                                        <!-- 'some' -->
          <xsl:variable name="state" select="p:consume(97, $input, $state)"/>       <!-- 'some' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 101">                                       <!-- 'to' -->
          <xsl:variable name="state" select="p:consume(101, $input, $state)"/>      <!-- 'to' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 102">                                       <!-- 'treat' -->
          <xsl:variable name="state" select="p:consume(102, $input, $state)"/>      <!-- 'treat' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(104, $input, $state)"/>      <!-- 'union' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse QName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-QName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 47">                                        <!-- 'array' -->
          <xsl:variable name="state" select="p:consume(47, $input, $state)"/>       <!-- 'array' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 49">                                        <!-- 'attribute' -->
          <xsl:variable name="state" select="p:consume(49, $input, $state)"/>       <!-- 'attribute' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 53">                                        <!-- 'comment' -->
          <xsl:variable name="state" select="p:consume(53, $input, $state)"/>       <!-- 'comment' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 57">                                        <!-- 'document-node' -->
          <xsl:variable name="state" select="p:consume(57, $input, $state)"/>       <!-- 'document-node' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 58">                                        <!-- 'element' -->
          <xsl:variable name="state" select="p:consume(58, $input, $state)"/>       <!-- 'element' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 60">                                        <!-- 'empty-sequence' -->
          <xsl:variable name="state" select="p:consume(60, $input, $state)"/>       <!-- 'empty-sequence' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 67">                                        <!-- 'function' -->
          <xsl:variable name="state" select="p:consume(67, $input, $state)"/>       <!-- 'function' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 71">                                        <!-- 'if' -->
          <xsl:variable name="state" select="p:consume(71, $input, $state)"/>       <!-- 'if' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 76">                                        <!-- 'item' -->
          <xsl:variable name="state" select="p:consume(76, $input, $state)"/>       <!-- 'item' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 80">                                        <!-- 'map' -->
          <xsl:variable name="state" select="p:consume(80, $input, $state)"/>       <!-- 'map' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 83">                                        <!-- 'namespace-node' -->
          <xsl:variable name="state" select="p:consume(83, $input, $state)"/>       <!-- 'namespace-node' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 85">                                        <!-- 'node' -->
          <xsl:variable name="state" select="p:consume(85, $input, $state)"/>       <!-- 'node' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 91">                                        <!-- 'processing-instruction' -->
          <xsl:variable name="state" select="p:consume(91, $input, $state)"/>       <!-- 'processing-instruction' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 94">                                        <!-- 'schema-attribute' -->
          <xsl:variable name="state" select="p:consume(94, $input, $state)"/>       <!-- 'schema-attribute' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 95">                                        <!-- 'schema-element' -->
          <xsl:variable name="state" select="p:consume(95, $input, $state)"/>       <!-- 'schema-element' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 98">                                        <!-- 'switch' -->
          <xsl:variable name="state" select="p:consume(98, $input, $state)"/>       <!-- 'switch' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 99">                                        <!-- 'text' -->
          <xsl:variable name="state" select="p:consume(99, $input, $state)"/>       <!-- 'text' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 103">                                       <!-- 'typeswitch' -->
          <xsl:variable name="state" select="p:consume(103, $input, $state)"/>      <!-- 'typeswitch' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-FunctionName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'QName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse EQName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-EQName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 6">                                         <!-- URIQualifiedName -->
          <xsl:variable name="state" select="p:consume(6, $input, $state)"/>        <!-- URIQualifiedName -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-QName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'EQName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse VarName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-VarName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EQName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'VarName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SimpleForBinding.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleForBinding" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '$' -->
    <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-VarName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(12, $input, $state)"/>         <!-- S^WS | ('(' ':') | 'in' -->
    <xsl:variable name="state" select="p:consume(72, $input, $state)"/>             <!-- 'in' -->
    <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SimpleForBinding', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production SimpleForClause (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleForClause-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>  <!-- S^WS | '$' | ('(' ':') -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-SimpleForBinding($input, $state)
            "/>
            <xsl:sequence select="p:parse-SimpleForClause-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse SimpleForClause.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleForClause" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(66, $input, $state)"/>             <!-- 'for' -->
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | '$' | ('(' ':') -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SimpleForBinding($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-SimpleForClause-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SimpleForClause', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ForExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ForExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SimpleForClause($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(92, $input, $state)"/>             <!-- 'return' -->
    <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ForExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ExprSingle.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ExprSingle" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 71">                                       <!-- 'if' -->
          <xsl:variable name="state" select="p:lookahead2W(36, $input, $state)"/>   <!-- S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                                                         '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' | 'eq' |
                                                                                         'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                                                         'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' |
                                                                                         'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = (62,                                          (: 'every' :)
                                         66,                                          (: 'for' :)
                                         78,                                          (: 'let' :)
                                         97)">                                      <!-- 'some' -->
          <xsl:variable name="state" select="p:lookahead2W(42, $input, $state)"/>   <!-- S^WS | '!' | '!=' | '#' | '$' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                                                         ',' | '-' | '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' |
                                                                                         '>=' | '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' |
                                                                                         'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2114">                                      <!-- 'for' '$' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ForExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2126">                                      <!-- 'let' '$' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-LetExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2110                                          (: 'every' '$' :)
                     or $state[$p:lk] = 2145">                                      <!-- 'some' '$' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-QuantifiedExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2247">                                      <!-- 'if' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-IfExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-OrExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ExprSingle', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production Expr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Expr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ExprSingle($input, $state)
            "/>
            <xsl:sequence select="p:parse-Expr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse Expr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Expr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-Expr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Expr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AVTVar.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AVTVar" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(105, $input, $state)"/>            <!-- '{' -->
    <xsl:variable name="state" select="p:lookahead1W(58, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' | '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 108">                                      <!-- '}' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-Expr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(108, $input, $state)"/>            <!-- '}' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AVTVar', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production AVTExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AVTExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1(0, $input, $state)"/>       <!-- EOF | '{' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 105">                                    <!-- '{' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-AVTVar($input, $state)
            "/>
            <xsl:variable name="state" select="p:lookahead1(1, $input, $state)"/>   <!-- AVTFix | EOF | '{' -->
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 1">                                 <!-- AVTFix -->
                  <xsl:variable name="state" select="p:consume(1, $input, $state)"/> <!-- AVTFix -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:sequence select="p:parse-AVTExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse AVTExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AVTExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:lookahead1(1, $input, $state)"/>           <!-- AVTFix | EOF | '{' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 1">                                         <!-- AVTFix -->
          <xsl:variable name="state" select="p:consume(1, $input, $state)"/>        <!-- AVTFix -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:parse-AVTExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AVTExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AVT.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AVT" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AVTExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(12, $input, $state)"/>             <!-- EOF -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AVT', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Create a textual error message from a parsing error.
   !
   ! @param $input the input string.
   ! @param $error the parsing error descriptor.
   ! @return the error message.
  -->
  <xsl:function name="p:error-message" as="xs:string">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="error" as="element(error)"/>

    <xsl:variable name="begin" select="xs:integer($error/@b)"/>
    <xsl:variable name="context" select="string-to-codepoints(substring($input, 1, $begin - 1))"/>
    <xsl:variable name="linefeeds" select="index-of($context, 10)"/>
    <xsl:variable name="line" select="count($linefeeds) + 1"/>
    <xsl:variable name="column" select="($begin - $linefeeds[last()], $begin)[1]"/>
    <xsl:variable name="expected" select="if ($error/@x or $error/@ambiguous-input) then () else p:expected-token-set($error/@s)"/>
    <xsl:sequence select="
      string-join
      (
        (
          if ($error/@o) then
            ('syntax error, found ', $p:TOKEN[$error/@o + 1])
          else
            'lexical analysis failed',
          '&#10;',
          'while expecting ',
          if ($error/@x) then
            $p:TOKEN[$error/@x + 1]
          else
          (
            '['[exists($expected[2])],
            string-join($expected, ', '),
            ']'[exists($expected[2])]
          ),
          '&#10;',
          if ($error/@o or $error/@e = $begin) then
            ()
          else
            ('after successfully scanning ', string($error/@e - $begin), ' characters beginning '),
          'at line ', string($line), ', column ', string($column), ':&#10;',
          '...', substring($input, $begin, 64), '...'
        ),
        ''
      )
    "/>
  </xsl:function>

  <!--~
   ! Consume one token, i.e. compare lookahead token 1 with expected
   ! token and in case of a match, shift lookahead tokens down such that
   ! l1 becomes the current token, and higher lookahead tokens move down.
   ! When lookahead token 1 does not match the expected token, raise an
   ! error by saving the expected token code in the error field of the
   ! lexer state.
   !
   ! @param $code the expected token.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:consume" as="item()+">
    <xsl:param name="code" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:when test="$state[$p:l1] eq $code">
        <xsl:variable name="begin" select="$state[$p:e0]"/>
        <xsl:variable name="end" select="$state[$p:b1]"/>
        <xsl:variable name="whitespace">
          <xsl:if test="$begin ne $end">
            <xsl:value-of select="substring($input, $begin, $end - $begin)"/>
          </xsl:if>
        </xsl:variable>
        <xsl:variable name="token" select="$p:TOKEN[1 + $state[$p:l1]]"/>
        <xsl:variable name="name" select="if (starts-with($token, &quot;'&quot;)) then 'TOKEN' else $token"/>
        <xsl:variable name="begin" select="$state[$p:b1]"/>
        <xsl:variable name="end" select="$state[$p:e1]"/>
        <xsl:variable name="node">
          <xsl:element name="{$name}">
            <xsl:sequence select="substring($input, $begin, $end - $begin)"/>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="
          subsequence($state, $p:l1, 9),
          0, 0, 0,
          subsequence($state, 13),
          $whitespace/node(),
          $node/node()
        "/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="error">
          <xsl:element name="error">
            <xsl:attribute name="b" select="$state[$p:b1]"/>
            <xsl:attribute name="e" select="$state[$p:e1]"/>
            <xsl:choose>
              <xsl:when test="$state[$p:l1] lt 0">
                <xsl:attribute name="s" select="- $state[$p:l1]"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:attribute name="o" select="$state[$p:l1]"/>
                <xsl:attribute name="x" select="$code"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="
          subsequence($state, 1, $p:error - 1),
          $error/node(),
          subsequence($state, $p:error + 1)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Consume one token, i.e. compare lookahead token 1 with expected
   ! token and in case of a match, shift lookahead tokens down such that
   ! l1 becomes the current token, and higher lookahead tokens move down.
   ! When lookahead token 1 does not match the expected token, raise an
   ! error by saving the expected token code in the error field of the
   ! lexer state. In contrast to p:consume, do not create any output.
   !
   ! @param $code the expected token.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:consumeT" as="item()+">
    <xsl:param name="code" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:when test="$state[$p:l1] eq $code">
        <xsl:sequence select="
          subsequence($state, $p:l1, 9),
          0, 0, 0,
          subsequence($state, 13)
        "/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="error">
          <xsl:element name="error">
            <xsl:attribute name="b" select="$state[$p:b1]"/>
            <xsl:attribute name="e" select="$state[$p:e1]"/>
            <xsl:choose>
              <xsl:when test="$state[$p:l1] lt 0">
                <xsl:attribute name="s" select="- $state[$p:l1]"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:attribute name="o" select="$state[$p:l1]"/>
                <xsl:attribute name="x" select="$code"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="
          subsequence($state, 1, $p:error - 1),
          $error/node(),
          subsequence($state, $p:error + 1)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Consume whitespace.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:whitespace" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="end" select="$state[$p:b1]"/>
    <xsl:choose>
      <xsl:when test="$begin eq $end">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="whitespace">
          <xsl:value-of select="substring($input, $begin, $end - $begin)"/>
        </xsl:variable>
        <xsl:sequence select="
          0,
          $state[$p:b0],
          $end,
          subsequence($state, $p:e0 + 1),
          $whitespace/node()
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Use p:match to fetch the next token, but skip any leading
   ! whitespace.
   !
   ! @param $input the input string.
   ! @param $begin the index where to start.
   ! @param $token-set the valid token set id.
   ! @return a sequence of three values: the token code of the result
   ! token, with input string positions of token begin and end.
  -->
  <xsl:function name="p:matchW">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="token-set" as="xs:integer"/>

    <xsl:variable name="match" select="p:match($input, $begin, $token-set)"/>
    <xsl:choose>
      <xsl:when test="$match[1] = 9">                                               <!-- S^WS -->
        <xsl:sequence select="p:matchW($input, $match[3], $token-set)"/>
      </xsl:when>
      <xsl:when test="$match[1] = 18">                                              <!-- ('(' ':') -->
        <xsl:variable name="state" select="p:try-Whitespace($input, (0, $begin, $begin, $match, 0, 0, 0, 0, 0, 0, false()))"/>
        <xsl:sequence select="p:matchW($input, $state[$p:e0], $token-set)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="$match"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Lookahead one token on level 1 with whitespace skipping.
   !
   ! @param $set the code of the DFA entry state for the set of valid tokens.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result stack.
   ! @return the updated state.
  -->
  <xsl:function name="p:lookahead1W" as="item()+">
    <xsl:param name="set" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:l1] ne 0">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="match" select="
          p:matchW($input, $state[$p:e0], $set),
          0, 0, 0
        "/>
        <xsl:sequence select="
          $match[1],
          subsequence($state, $p:b0, 2),
          $match,
          subsequence($state, 10)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Lookahead one token on level 2 with whitespace skipping.
   !
   ! @param $set the code of the DFA entry state for the set of valid tokens.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result stack.
   ! @return the updated state.
  -->
  <xsl:function name="p:lookahead2W" as="item()+">
    <xsl:param name="set" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="match" select="
      if ($state[$p:l2] ne 0) then
        subsequence($state, $p:l2, 6)
      else
      (
        p:matchW($input, $state[$p:e1], $set),
        0, 0, 0
      )
    "/>
    <xsl:sequence select="
      $match[1] * 128 + $state[$p:l1],
      subsequence($state, $p:b0, 5),
      $match,
      subsequence($state, 13)
    "/>
  </xsl:function>

  <!--~
   ! Lookahead one token on level 3 with whitespace skipping.
   !
   ! @param $set the code of the DFA entry state for the set of valid tokens.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result stack.
   ! @return the updated state.
  -->
  <xsl:function name="p:lookahead3W" as="item()+">
    <xsl:param name="set" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="match" select="
      if ($state[$p:l3] ne 0) then
        subsequence($state, $p:l3, 3)
      else
        p:matchW($input, $state[$p:e2], $set)
    "/>
    <xsl:sequence select="
      $match[1] * 16384 + $state[$p:lk],
      subsequence($state, $p:b0, 8),
      $match,
      subsequence($state, 13)
    "/>
  </xsl:function>

  <!--~
   ! Lookahead one token on level 1.
   !
   ! @param $set the code of the DFA entry state for the set of valid tokens.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result stack.
   ! @return the updated state.
  -->
  <xsl:function name="p:lookahead1" as="item()+">
    <xsl:param name="set" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:l1] ne 0">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="match" select="
          p:match($input, $state[$p:e0], $set),
          0, 0, 0
        "/>
        <xsl:sequence select="
          $match[1],
          subsequence($state, $p:b0, 2),
          $match,
          subsequence($state, 10)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Reduce the result stack, creating a nonterminal element. Pop
   ! $count elements off the stack, wrap them in a new element
   ! named $name, and push the new element.
   !
   ! @param $state lexer state, error indicator, and result.
   ! @param $name the name of the result node.
   ! @param $count the number of child nodes.
   ! @param $begin the input index where the nonterminal begins.
   ! @param $end the input index where the nonterminal ends.
   ! @return the updated state.
  -->
  <xsl:function name="p:reduce" as="item()+">
    <xsl:param name="state" as="item()+"/>
    <xsl:param name="name" as="xs:string"/>
    <xsl:param name="count" as="xs:integer"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="end" as="xs:integer"/>

    <xsl:variable name="node">
      <xsl:element name="{$name}">
        <xsl:sequence select="subsequence($state, $count + 1)"/>
      </xsl:element>
    </xsl:variable>
    <xsl:sequence select="subsequence($state, 1, $count), $node/node()"/>
  </xsl:function>

  <!--~
   ! Parse start symbol AVT from given string.
   !
   ! @param $s the string to be parsed.
   ! @return the result as generated by parser actions.
  -->
  <xsl:function name="p:parse-AVT" as="item()*">
    <xsl:param name="s" as="xs:string"/>

    <xsl:variable name="state" select="0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, false()"/>
    <xsl:variable name="state" select="p:parse-AVT($s, $state)"/>
    <xsl:variable name="error" select="$state[$p:error]"/>
    <xsl:choose>
      <xsl:when test="$error">
        <xsl:variable name="ERROR">
          <xsl:element name="ERROR">
            <xsl:sequence select="$error/@*, p:error-message($s, $error)"/>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="$ERROR/node()"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="subsequence($state, $p:result)"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

</xsl:stylesheet>