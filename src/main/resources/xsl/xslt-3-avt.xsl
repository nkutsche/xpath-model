<?xml version="1.0" encoding="UTF-8"?>
<!-- This file was generated on Wed Jan 12, 2022 11:33 (UTC+01) by REx v5.55 which is Copyright (c) 1979-2022 by Gunther Rademacher <grd@gmx.net> -->
<!-- REx command line: xslt-3-avt.ebnf -xslt -tree -->

<xsl:stylesheet version="2.0"
                xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:p="xslt-3-avt">
  <!--~
   ! The index of the lexer state for accessing the combined
   ! (i.e. level > 1) lookahead code.
  -->
  <xsl:variable name="p:lk" as="xs:integer" select="1"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the begin of the token that has been consumed.
  -->
  <xsl:variable name="p:b0" as="xs:integer" select="2"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the end of the token that has been consumed.
  -->
  <xsl:variable name="p:e0" as="xs:integer" select="3"/>

  <!--~
   ! The index of the lexer state for accessing the code of the
   ! level-1-lookahead token.
  -->
  <xsl:variable name="p:l1" as="xs:integer" select="4"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the begin of the level-1-lookahead token.
  -->
  <xsl:variable name="p:b1" as="xs:integer" select="5"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the end of the level-1-lookahead token.
  -->
  <xsl:variable name="p:e1" as="xs:integer" select="6"/>

  <!--~
   ! The index of the lexer state for accessing the code of the
   ! level-2-lookahead token.
  -->
  <xsl:variable name="p:l2" as="xs:integer" select="7"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the begin of the level-2-lookahead token.
  -->
  <xsl:variable name="p:b2" as="xs:integer" select="8"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the end of the level-2-lookahead token.
  -->
  <xsl:variable name="p:e2" as="xs:integer" select="9"/>

  <!--~
   ! The index of the lexer state for accessing the code of the
   ! level-3-lookahead token.
  -->
  <xsl:variable name="p:l3" as="xs:integer" select="10"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the begin of the level-3-lookahead token.
  -->
  <xsl:variable name="p:b3" as="xs:integer" select="11"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the end of the level-3-lookahead token.
  -->
  <xsl:variable name="p:e3" as="xs:integer" select="12"/>

  <!--~
   ! The index of the lexer state for accessing the token code that
   ! was expected when an error was found.
  -->
  <xsl:variable name="p:error" as="xs:integer" select="13"/>

  <!--~
   ! The index of the lexer state that points to the first entry
   ! used for collecting action results.
  -->
  <xsl:variable name="p:result" as="xs:integer" select="14"/>

  <!--~
   ! The codepoint to charclass mapping for 7 bit codepoints.
  -->
  <xsl:variable name="p:MAP0" as="xs:integer+" select="
    55, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 6, 18, 19, 20, 21, 22, 23, 23, 23, 23, 24, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 25, 23, 23, 23, 23, 23, 23,
    23, 23, 23, 26, 6, 27, 6, 23, 6, 28, 29, 30, 31, 32, 33, 34, 35, 36, 23, 23, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 23, 51, 52, 53, 6, 6
  "/>

  <!--~
   ! The codepoint to charclass mapping for codepoints below the surrogate block.
  -->
  <xsl:variable name="p:MAP1" as="xs:integer+" select="
    108, 124, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 156, 181, 181, 181, 181, 181, 214, 215, 213, 214, 214, 214, 214, 214, 214,
    214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
    214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
    214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 247, 261, 277, 293, 309, 331, 370, 386, 422, 422, 422, 414, 354, 346, 354, 346,
    354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 439, 439, 439, 439, 439, 439, 439, 315, 354, 354, 354, 354, 354, 354, 354,
    354, 400, 422, 422, 423, 421, 422, 422, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 422, 422, 422, 422, 422,
    422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 353, 354, 354, 354,
    354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 422, 55, 0,
    0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 17, 6, 18, 19, 20, 21, 22, 23, 23, 23, 23, 24, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 6, 23, 23, 25, 23, 23, 23,
    23, 23, 23, 23, 23, 23, 26, 6, 27, 6, 23, 23, 23, 23, 23, 23, 23, 6, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 6, 28, 29, 30, 31, 32,
    33, 34, 35, 36, 23, 23, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 23, 51, 52, 53, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 23, 23, 6, 6, 6, 6, 6,
    6, 6, 54, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54
  "/>

  <!--~
   ! The codepoint to charclass mapping for codepoints above the surrogate block.
  -->
  <xsl:variable name="p:MAP2" as="xs:integer+" select="
    57344, 63744, 64976, 65008, 65536, 983040, 63743, 64975, 65007, 65533, 983039, 1114111, 6, 23, 6, 23, 23, 6
  "/>

  <!--~
   ! The token-set-id to DFA-initial-state mapping.
  -->
  <xsl:variable name="p:INITIAL" as="xs:integer+" select="
    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 2069, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
    42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59
  "/>

  <!--~
   ! The DFA transition table.
  -->
  <xsl:variable name="p:TRANSITION" as="xs:integer+" select="
    4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779,
    4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779,
    4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 3607, 3584, 3605, 3589, 9508, 4779, 5444, 3895, 5181, 3623, 3654, 3700, 4660, 3716,
    3733, 4661, 3717, 3770, 3797, 3748, 9846, 3803, 3754, 10976, 10965, 3850, 3819, 3848, 12206, 3866, 3679, 3871, 3684, 12159, 3887, 3911, 3667, 3832, 3965,
    3928, 3927, 3944, 3981, 4029, 3958, 3895, 5179, 4065, 4042, 4049, 4079, 4095, 4122, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642,
    4278, 4292, 11374, 8006, 4779, 5444, 3895, 5181, 3623, 3654, 3700, 4660, 3716, 3733, 4661, 3717, 3770, 3797, 3748, 9846, 3803, 3754, 10976, 10965, 3850,
    3819, 3848, 12206, 3866, 3679, 3871, 3684, 12159, 3887, 3911, 3667, 3832, 3965, 3928, 3927, 3944, 3981, 4029, 3958, 3895, 5179, 4065, 4042, 4049, 4079,
    4095, 4122, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642, 10635, 4779, 10951, 9006, 4779, 5444, 3895, 5181, 4142, 3654, 3700,
    4660, 3716, 3733, 4661, 3717, 3770, 3797, 3748, 9846, 3803, 3754, 10976, 10965, 3850, 3819, 3848, 12206, 3866, 3679, 3871, 3684, 12159, 3887, 3911, 3667,
    3832, 3965, 3928, 3927, 3944, 3981, 4029, 3958, 3895, 5179, 4065, 4042, 4049, 4079, 4095, 4122, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779,
    4779, 4190, 4221, 8864, 4226, 8006, 4779, 5444, 3895, 5181, 3623, 3654, 3700, 4660, 3716, 3733, 4661, 3717, 3770, 3797, 3748, 9846, 3803, 3754, 10976,
    10965, 3850, 3819, 3848, 12206, 3866, 3679, 3871, 3684, 12159, 3887, 3911, 3667, 3832, 3965, 3928, 3927, 3944, 3981, 4029, 3958, 3895, 5179, 4065, 4042,
    4049, 4079, 4095, 4122, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4206, 4242, 5061, 5072, 8006, 4779, 5444, 3895, 5181, 3623, 3654,
    3700, 4660, 3716, 3733, 4661, 3717, 3770, 3797, 3748, 9846, 3803, 3754, 10976, 10965, 3850, 3819, 3848, 12206, 3866, 3679, 3871, 3684, 12159, 3887, 3911,
    3667, 3832, 3965, 3928, 3927, 3944, 3981, 4029, 3958, 3895, 5179, 4065, 4042, 4049, 4079, 4095, 4122, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779,
    4779, 4779, 8642, 4221, 4779, 4226, 8006, 4779, 5444, 3895, 5181, 3623, 3654, 3700, 4660, 3716, 3733, 4661, 3717, 3770, 3797, 3748, 9846, 3803, 3754, 10976,
    10965, 3850, 3819, 3848, 12206, 3866, 3679, 3871, 3684, 12159, 3887, 3911, 3667, 3832, 3965, 3928, 3927, 3944, 3981, 4029, 3958, 3895, 5179, 4065, 4042,
    4049, 4079, 4095, 4122, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642, 10730, 4779, 11705, 8564, 4779, 5444, 3895, 5181, 4263,
    3654, 3700, 4660, 3716, 3733, 4661, 3717, 3770, 3797, 3748, 9846, 3803, 3754, 10976, 10965, 3850, 3819, 3848, 12206, 3866, 3679, 3871, 3684, 12159, 3887,
    3911, 3667, 3832, 3965, 3928, 3927, 3944, 3981, 4029, 3958, 3895, 5179, 4065, 4042, 4049, 4079, 4095, 4122, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779,
    4779, 4779, 4779, 4331, 4319, 4347, 4362, 12081, 4779, 5444, 3895, 5181, 4398, 3654, 3700, 4660, 3716, 3733, 4661, 3717, 3770, 3797, 3748, 9846, 3803, 3754,
    10976, 10965, 3850, 3819, 3848, 12206, 3866, 3679, 3871, 3684, 12159, 3887, 3911, 3667, 3832, 3965, 3928, 3927, 3944, 3981, 4029, 3958, 3895, 5179, 4065,
    4042, 4049, 4079, 4095, 4122, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4439, 4480, 4489, 4505, 9876, 4779, 5444, 3895, 5181, 4535,
    3654, 3700, 4660, 3716, 3733, 4661, 3717, 3770, 3797, 3748, 9846, 3803, 3754, 10976, 10965, 3850, 3819, 3848, 12206, 3866, 3679, 3871, 3684, 12159, 3887,
    3911, 3667, 3832, 3965, 3928, 3927, 3944, 3981, 4029, 3958, 3895, 5179, 4065, 4042, 4049, 4079, 4095, 4122, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779,
    4779, 4779, 4779, 11675, 10073, 10081, 4576, 8006, 4779, 5444, 3895, 5181, 3623, 3654, 3700, 4660, 3716, 4645, 4661, 3717, 3770, 3797, 3748, 4106, 3803,
    3754, 10976, 10965, 3850, 3819, 3848, 12206, 3866, 3679, 3871, 3684, 12159, 3887, 3911, 3667, 3832, 3965, 3928, 3927, 3944, 3981, 4029, 3958, 3895, 5179,
    4065, 4042, 4049, 4079, 4095, 4122, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642, 4413, 4423, 9130, 8006, 4779, 5444, 3895, 5181,
    3623, 3654, 3700, 4660, 3716, 3733, 4661, 3717, 4677, 3797, 3748, 9846, 3803, 3754, 10976, 10965, 3850, 3819, 3848, 12206, 3866, 3679, 3871, 3684, 12159,
    3887, 3911, 3667, 3832, 3965, 3928, 3927, 3944, 3981, 4029, 3958, 3895, 5179, 4065, 4042, 4049, 4079, 4095, 4122, 4779, 4779, 4779, 4779, 4779, 4779, 4779,
    4779, 4779, 4779, 4779, 9462, 4714, 4723, 11498, 8006, 4779, 5444, 3895, 5181, 3623, 3654, 3700, 4660, 3716, 3733, 4661, 3717, 3770, 3797, 3748, 9846, 3803,
    3754, 10976, 10965, 3850, 3819, 3848, 12206, 3866, 3679, 3871, 3684, 12159, 3887, 3911, 3667, 3832, 3965, 3928, 3927, 3944, 3981, 4029, 3958, 3895, 5179,
    4065, 4042, 4049, 4079, 4095, 4122, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642, 4454, 4464, 9734, 6038, 4779, 6111, 6803, 6858,
    4376, 4779, 4739, 6396, 6396, 4759, 6157, 11221, 4778, 4796, 6396, 5948, 6157, 6157, 7571, 7837, 6396, 9771, 6157, 7974, 6733, 6396, 9369, 9582, 6117, 8590,
    10554, 6115, 9773, 7408, 4816, 4832, 4852, 10689, 4896, 4925, 4949, 9774, 4971, 4955, 10159, 10163, 11622, 4876, 4779, 4779, 4779, 4779, 4779, 4779, 4779,
    4779, 4779, 4779, 4779, 8642, 4221, 4779, 5008, 6038, 4779, 6111, 6803, 4836, 4376, 4779, 4739, 6396, 6396, 4759, 6157, 11221, 4779, 4796, 6396, 5948, 6157,
    6157, 7571, 7837, 6396, 9771, 6157, 7974, 6115, 6396, 6157, 7974, 6117, 9771, 6158, 6115, 9773, 7976, 6397, 6157, 6117, 8748, 9769, 4954, 6618, 9774, 8809,
    4955, 10159, 10163, 11622, 4876, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642, 4221, 5050, 5034, 8006, 4779, 10509, 3895, 5181,
    3623, 3654, 3700, 4660, 3716, 3733, 4661, 3717, 3770, 3797, 3748, 9846, 3803, 3754, 10976, 10965, 3850, 3819, 3848, 12206, 3866, 3679, 3871, 3684, 12159,
    3887, 3911, 3667, 3832, 3965, 3928, 3927, 3944, 3981, 4029, 3958, 3895, 5179, 4065, 4042, 4049, 4079, 4095, 4122, 4779, 4779, 4779, 4779, 4779, 4779, 4779,
    4779, 4779, 4779, 4779, 9643, 9634, 4779, 11915, 6038, 4779, 6111, 6803, 6443, 4376, 4779, 4739, 6396, 6396, 4759, 6157, 6442, 4991, 4796, 6396, 5948, 6157,
    6157, 4984, 7837, 6396, 9771, 6157, 7974, 6115, 6396, 6157, 7974, 6117, 9771, 6158, 6115, 9773, 7976, 6397, 6157, 6117, 8748, 9769, 4954, 6618, 9774, 8809,
    4955, 10159, 10163, 11622, 4876, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 6512, 5088, 5100, 7579, 3638, 4779, 5975, 5417, 5574,
    5127, 3654, 5197, 5226, 5213, 5255, 5293, 5309, 3770, 5325, 5239, 11730, 5352, 5270, 5493, 11719, 5368, 5339, 5396, 5433, 5466, 5380, 5482, 5518, 5981,
    5509, 5534, 4617, 4629, 5277, 5550, 5566, 5590, 5727, 5625, 5410, 5697, 5692, 5654, 5638, 5684, 5668, 5713, 5605, 4779, 4779, 4779, 4779, 4779, 4779, 4779,
    4779, 4779, 4779, 4779, 8642, 4550, 4560, 7661, 8006, 5743, 5444, 3895, 5181, 3623, 3654, 3700, 4660, 3716, 3733, 4661, 3717, 3770, 3797, 3748, 9846, 3803,
    3754, 10976, 10965, 3850, 3819, 3848, 12206, 3866, 3679, 3871, 3684, 12159, 3887, 3911, 3667, 3832, 3965, 3928, 3927, 3944, 3981, 4029, 3958, 3895, 5179,
    4065, 4042, 4049, 4079, 4095, 4122, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642, 5142, 5157, 8287, 8006, 5763, 5444, 3895, 5181,
    3623, 3654, 3700, 4660, 3716, 3733, 4661, 3717, 3770, 3797, 3748, 9846, 3803, 3754, 10976, 10965, 3850, 3819, 3848, 12206, 3866, 3679, 3871, 3684, 12159,
    3887, 3911, 3667, 3832, 3965, 3928, 3927, 3944, 3981, 4029, 3958, 3895, 5179, 4065, 4042, 4049, 4079, 4095, 4122, 4779, 4779, 4779, 4779, 4779, 4779, 4779,
    4779, 4779, 4779, 4779, 8642, 11108, 11118, 6713, 8006, 5784, 9837, 3895, 5181, 3623, 3654, 3700, 4660, 3716, 3733, 4661, 3717, 3770, 3797, 3748, 9846,
    3803, 3754, 10976, 10965, 3850, 3819, 3848, 12206, 3866, 3679, 3871, 3684, 12159, 3887, 3911, 3667, 3832, 3965, 3928, 3927, 3944, 3981, 4029, 3958, 3895,
    5179, 4065, 4042, 4049, 4079, 4095, 4122, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642, 5805, 5820, 5845, 8006, 4779, 5444, 3895,
    5181, 3623, 3654, 3700, 4660, 3716, 3733, 4661, 3717, 3770, 3797, 3748, 9846, 3803, 3754, 10976, 10965, 3850, 3819, 3848, 12206, 3866, 3679, 3871, 3684,
    12159, 3887, 3911, 3667, 3832, 3965, 3928, 3927, 3944, 3981, 4029, 3958, 3895, 5179, 4065, 4042, 4049, 4079, 4095, 4122, 4779, 4779, 4779, 4779, 4779, 4779,
    4779, 4779, 4779, 4779, 4779, 8642, 4221, 4779, 5875, 8006, 4779, 5444, 3895, 5181, 3623, 3654, 3700, 4660, 3716, 3733, 4661, 3717, 3770, 3797, 3748, 9846,
    3803, 3754, 10976, 10965, 3850, 3819, 3848, 12206, 3866, 3679, 3871, 3684, 12159, 3887, 3911, 3667, 3832, 3965, 3928, 3927, 3944, 3981, 4029, 3958, 3895,
    5179, 4065, 4042, 4049, 4079, 4095, 4122, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642, 11007, 12238, 6229, 6038, 4779, 6111,
    6803, 6159, 4376, 4779, 5905, 6396, 6396, 5925, 6157, 6158, 4779, 5944, 6396, 9562, 6157, 6157, 6234, 7837, 6396, 9771, 6157, 7974, 6115, 6396, 6157, 7974,
    6117, 9771, 6158, 6115, 9773, 7976, 6397, 6157, 6117, 8748, 9769, 4954, 6618, 9774, 8809, 4955, 10159, 10163, 11622, 4876, 4779, 4779, 4779, 4779, 4779,
    4779, 4779, 4779, 4779, 4779, 4779, 8642, 11007, 12238, 6229, 6038, 4779, 6111, 6803, 8749, 4376, 4779, 5905, 6396, 6396, 5925, 6157, 8766, 4779, 5944,
    6396, 9562, 6157, 6157, 6234, 7837, 6396, 9771, 6157, 7974, 6115, 6396, 6157, 7974, 6117, 9771, 6158, 6115, 9773, 7976, 6397, 6157, 6117, 8748, 9769, 4954,
    6618, 9774, 8809, 4955, 10159, 10163, 11622, 4876, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642, 11007, 10641, 5964, 6038, 4779,
    6111, 6803, 6159, 4376, 4779, 5905, 6396, 6396, 5925, 6157, 6158, 4779, 5944, 6396, 9562, 6157, 6157, 6234, 7837, 6396, 9771, 6157, 7974, 6115, 6396, 6157,
    7974, 6117, 9771, 6158, 6115, 9773, 7976, 6397, 6157, 6117, 8748, 9769, 4954, 6618, 9774, 8809, 4955, 10159, 10163, 11622, 4876, 4779, 4779, 4779, 4779,
    4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642, 4221, 5997, 6024, 8006, 4779, 5444, 3895, 5181, 3623, 3654, 3700, 4660, 3716, 3733, 4661, 3717, 3770, 3797,
    3748, 9846, 3803, 3754, 10976, 10965, 3850, 3819, 3848, 12206, 3866, 3679, 3871, 3684, 12159, 3887, 3911, 3667, 3832, 3965, 3928, 3927, 3944, 3981, 4029,
    3958, 3895, 5179, 4065, 4042, 4049, 4079, 4095, 4122, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642, 7891, 7901, 6331, 8006, 4779,
    5444, 3895, 5181, 3623, 3654, 3700, 4660, 3716, 3733, 4661, 3717, 3770, 3797, 3748, 9846, 3803, 3754, 10976, 10965, 3850, 3819, 3848, 12206, 3866, 3679,
    3871, 3684, 12159, 3887, 3911, 3667, 3832, 3965, 3928, 3927, 3944, 3981, 4029, 3958, 3895, 5179, 4065, 4042, 4049, 4079, 4095, 4122, 4779, 4779, 4779, 4779,
    4779, 4779, 4779, 4779, 4779, 4779, 4779, 5829, 6054, 6064, 6080, 6038, 4780, 10341, 6378, 11340, 4376, 4779, 5905, 6396, 6396, 5925, 6157, 6158, 6349,
    6133, 6396, 10262, 6156, 6157, 6175, 6197, 7012, 6140, 7466, 9528, 6115, 4013, 6157, 10498, 6117, 6224, 8417, 6648, 9961, 10405, 6397, 6157, 6117, 8748,
    9769, 4954, 6618, 9774, 8809, 4955, 10159, 10163, 11622, 4876, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642, 11007, 12238, 6229,
    6038, 4779, 6111, 6803, 6159, 4376, 4779, 5905, 6396, 6396, 5925, 6157, 6158, 4779, 5944, 6396, 9562, 6157, 6157, 6234, 7837, 6396, 9771, 6157, 7974, 4157,
    6396, 6250, 7974, 6117, 9771, 6158, 6115, 9773, 7976, 6397, 6157, 6117, 8748, 9769, 4954, 6618, 6270, 8809, 4955, 10159, 10163, 11622, 4876, 4779, 4779,
    4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642, 11093, 6307, 6320, 6038, 6347, 6111, 4933, 12003, 4519, 4779, 6365, 6394, 6396, 6413, 6441,
    6158, 4779, 6459, 8528, 6487, 11796, 8128, 6234, 7837, 6396, 11304, 6157, 6501, 6115, 6396, 6157, 7974, 6528, 9771, 6569, 6594, 6612, 6639, 8325, 10042,
    6117, 8748, 9769, 4954, 8679, 8193, 8809, 4955, 10159, 10163, 6664, 4876, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642, 11529,
    11539, 6694, 6038, 8875, 6729, 6749, 6777, 5022, 7653, 6798, 10123, 6819, 6837, 6254, 6857, 4779, 5944, 6396, 9562, 6157, 6157, 6234, 7955, 6396, 11885,
    6157, 7974, 6115, 11411, 6157, 6874, 6895, 7844, 6158, 6115, 9773, 7976, 6397, 6157, 6117, 8748, 9769, 8426, 6919, 6957, 8809, 4955, 10159, 10163, 11622,
    4876, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642, 7036, 7046, 7062, 6038, 6008, 4698, 7097, 7125, 7141, 4992, 7167, 7202, 6471,
    7237, 9379, 7253, 7269, 7295, 7311, 9343, 7476, 7327, 7364, 10239, 12100, 8811, 7390, 7406, 10414, 6396, 10151, 8306, 6596, 9771, 7562, 7424, 11824, 7440,
    7221, 7456, 7492, 8387, 11450, 9673, 7508, 10816, 7547, 7595, 10792, 7617, 11622, 4876, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779,
    8642, 11007, 10736, 7642, 7677, 4779, 6111, 7693, 7729, 4376, 4779, 5905, 6396, 6396, 5925, 6157, 6158, 4779, 5944, 6396, 9184, 6157, 12020, 6234, 7837,
    6396, 9771, 6157, 7974, 7753, 11766, 6157, 11480, 6117, 9771, 6158, 6115, 9773, 7976, 6397, 6157, 6117, 8748, 9769, 4954, 6618, 9774, 8809, 4955, 11566,
    10163, 7774, 4876, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642, 12269, 12279, 7826, 6038, 4779, 6111, 6803, 6159, 4376, 4779,
    5905, 6396, 6396, 5925, 6157, 6158, 4779, 5944, 6396, 9562, 6157, 6157, 6234, 7837, 6396, 9771, 6157, 7974, 6115, 6396, 6157, 7974, 6117, 9771, 6158, 6115,
    9773, 7976, 11852, 10910, 8976, 7626, 9769, 4954, 6618, 9774, 8809, 4955, 10159, 6761, 11622, 4876, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779,
    4779, 4779, 8642, 11007, 12238, 6229, 7860, 4779, 12217, 7758, 6159, 11929, 4779, 5905, 6396, 4166, 5925, 6157, 4909, 4779, 5944, 6396, 9562, 6157, 6157,
    6234, 7837, 6396, 9771, 6157, 7974, 6115, 5909, 6157, 10228, 6117, 9771, 6158, 6115, 9773, 7976, 6397, 6157, 6117, 7876, 9769, 4954, 6618, 9774, 8809, 4955,
    10159, 10163, 11622, 4876, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 11243, 7917, 7928, 7944, 6038, 11491, 3781, 6803, 7971, 4376,
    7992, 8022, 8256, 8534, 8047, 9804, 9389, 5768, 5944, 6396, 10484, 6157, 8724, 6234, 8246, 6396, 8263, 6157, 7974, 6115, 8071, 9897, 7974, 8090, 8119, 8144,
    6115, 8673, 8965, 6397, 6157, 6117, 8748, 9769, 6623, 7788, 9774, 8809, 10699, 8185, 10163, 9211, 4876, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779,
    4779, 4779, 4779, 8642, 8209, 8219, 8235, 6038, 8279, 8885, 6803, 8303, 4376, 4779, 5905, 8322, 4174, 5925, 8341, 7109, 4779, 8359, 9558, 9562, 8403, 6157,
    6234, 7837, 6396, 9771, 6157, 7974, 6115, 6396, 6157, 7974, 8442, 9066, 6158, 6115, 9773, 10604, 4743, 9025, 6117, 8748, 9769, 4954, 6618, 9774, 9707, 8464,
    10159, 6969, 11622, 4876, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642, 8480, 8490, 8506, 6038, 4779, 7151, 6803, 8550, 4376,
    4779, 8580, 6821, 9103, 8614, 4762, 10921, 8639, 8658, 10879, 9562, 8695, 8720, 7737, 11940, 6396, 8740, 8765, 8782, 6115, 6396, 6157, 7974, 6117, 9771,
    6158, 6115, 9773, 7976, 6397, 6157, 6117, 7531, 11040, 8803, 6618, 9774, 8809, 4955, 10159, 10163, 11622, 4876, 4779, 4779, 4779, 4779, 4779, 4779, 4779,
    4779, 4779, 4779, 4779, 8642, 8827, 8837, 8853, 8901, 10190, 8917, 8950, 8992, 4376, 4779, 5905, 7181, 6396, 5925, 9022, 6158, 9041, 5944, 6396, 9562, 6157,
    6157, 6234, 9059, 4800, 10578, 5928, 8704, 9082, 6543, 11465, 9119, 7003, 7601, 6158, 10377, 9146, 9162, 9200, 9227, 9263, 11596, 10679, 9286, 9331, 12051,
    8809, 4955, 11151, 9359, 11622, 9405, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 5789, 9425, 9435, 9451, 6038, 6181, 9478, 8103,
    9494, 4376, 4779, 5905, 6396, 8929, 5925, 6157, 9524, 5747, 5944, 6396, 8934, 6157, 6157, 6285, 7837, 4008, 9771, 10547, 7974, 6115, 6396, 6157, 7974, 9544,
    10759, 9578, 6115, 9773, 7976, 6397, 6157, 9598, 9619, 9659, 6578, 9696, 9774, 8809, 4955, 10159, 10163, 11863, 4876, 4779, 4779, 4779, 4779, 4779, 4779,
    4779, 4779, 4779, 4779, 4779, 8642, 11007, 4382, 9723, 6038, 4779, 6111, 6803, 6159, 4376, 4779, 9750, 10003, 8074, 9790, 12121, 6841, 4779, 5944, 6396,
    9562, 6157, 6157, 8787, 7837, 11760, 9771, 7342, 7974, 6115, 9308, 6157, 9826, 6117, 9771, 6158, 6115, 9773, 7976, 6397, 6157, 6117, 8748, 9769, 4954, 6618,
    9774, 8809, 4955, 10159, 10163, 11622, 4876, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642, 11007, 12238, 6229, 6038, 6705, 7279,
    6803, 9862, 4376, 4779, 5905, 6396, 6396, 5925, 6157, 6158, 4779, 5944, 6396, 9562, 6157, 6157, 6234, 7837, 6396, 9771, 6157, 7974, 6115, 6396, 6157, 7974,
    6117, 9771, 6158, 6115, 9773, 7976, 9765, 9892, 6117, 8748, 9769, 4954, 6618, 9774, 8809, 4955, 10159, 10163, 11622, 4876, 4779, 4779, 4779, 4779, 4779,
    4779, 4779, 4779, 4779, 4779, 4779, 8642, 9913, 9923, 9939, 6038, 5609, 3996, 6208, 6941, 4376, 4779, 9977, 10000, 9096, 10019, 10040, 10058, 4779, 10097,
    10121, 9562, 10139, 6157, 6879, 7837, 10105, 9771, 8623, 10179, 6115, 6396, 6157, 7974, 6117, 9771, 6158, 10872, 11143, 7976, 6397, 6157, 6117, 8748, 10216,
    10255, 8598, 10784, 8809, 4955, 8055, 10278, 11622, 4876, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642, 10304, 10314, 10330,
    10357, 4688, 10373, 10393, 10430, 4590, 4126, 10470, 11419, 6396, 10534, 11995, 6158, 4779, 5944, 6396, 9562, 6157, 6157, 6234, 10570, 8448, 10594, 7348,
    10620, 6115, 11402, 8343, 10657, 9173, 7523, 10715, 6115, 9773, 6782, 9603, 11276, 6117, 8748, 11968, 10752, 11312, 11269, 7799, 10775, 10808, 10163, 11622,
    4876, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4247, 10832, 10848, 10861, 6038, 6091, 4303, 10895, 10937, 4376, 10992, 11033, 6903,
    7213, 11056, 6981, 11078, 4880, 11134, 11167, 8031, 11192, 11219, 11237, 11259, 9297, 8379, 9239, 7810, 10668, 11292, 11328, 11356, 11390, 9680, 6158, 9950,
    6553, 6992, 11176, 11203, 11435, 11514, 9769, 4954, 6618, 9774, 11555, 11582, 11612, 10163, 4864, 4876, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779,
    4779, 4779, 4779, 8642, 11638, 11648, 11664, 6038, 4779, 11017, 6803, 11691, 4376, 4779, 5905, 6396, 6396, 5925, 6157, 6158, 6291, 11746, 6396, 11782, 7705,
    9810, 6234, 7837, 6396, 9771, 6157, 7974, 6115, 6396, 6157, 7974, 11812, 9315, 6158, 6115, 9773, 7976, 6397, 6157, 11840, 6678, 9769, 4954, 6618, 9774,
    6930, 11879, 10159, 6425, 11622, 4876, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642, 11007, 12238, 6229, 6038, 4779, 7374, 6803,
    11901, 4604, 4779, 11956, 6396, 6396, 11984, 6157, 6158, 6102, 5944, 8369, 9562, 6157, 12019, 6234, 7837, 6396, 9771, 6157, 7974, 6115, 6396, 6157, 7974,
    6117, 9771, 6158, 6115, 9773, 7976, 6397, 6157, 6117, 8748, 9769, 4954, 6618, 9774, 8809, 4955, 10159, 10163, 11622, 4876, 4779, 4779, 4779, 4779, 4779,
    4779, 4779, 4779, 4779, 4779, 4779, 8642, 11007, 12238, 6229, 6038, 4779, 6111, 7020, 9247, 4376, 4779, 5905, 6396, 6396, 5925, 6157, 6158, 4779, 5944,
    6396, 9562, 6157, 6157, 6234, 7837, 6396, 9771, 6157, 7974, 6115, 12036, 11062, 10288, 6117, 9771, 6158, 6115, 9773, 7976, 6397, 6157, 6117, 8748, 9769,
    4954, 6618, 9774, 8809, 4955, 10159, 10163, 11622, 4876, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642, 11007, 12238, 6229, 6038,
    7073, 10200, 6803, 12067, 4376, 4779, 5905, 6396, 7186, 5925, 6157, 7713, 4779, 5944, 6396, 9562, 6157, 6157, 6234, 7837, 6396, 9771, 6157, 7974, 6115,
    6396, 6157, 7974, 6117, 9771, 6158, 6115, 9773, 7976, 6397, 6157, 6117, 8748, 9769, 4954, 6618, 9774, 8809, 4955, 10159, 10163, 11622, 4876, 4779, 4779,
    4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642, 11007, 12238, 6229, 6038, 4779, 6111, 9984, 10024, 4376, 4779, 5905, 6396, 6396, 5925, 6157,
    6158, 4779, 5944, 6396, 9562, 6157, 6157, 6234, 8517, 12097, 9270, 12116, 7974, 6115, 6396, 6157, 7974, 6117, 9771, 6158, 6115, 9773, 7976, 6397, 6157,
    6117, 8748, 9769, 4954, 6618, 9774, 8809, 4955, 10159, 10163, 11622, 4876, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 9409, 12137,
    11368, 4226, 5859, 4779, 5168, 10518, 5181, 3623, 3654, 5449, 4660, 3716, 5450, 4661, 3717, 3770, 3797, 3748, 9846, 3803, 3754, 10976, 10965, 3850, 3819,
    3848, 12206, 3866, 3679, 3871, 3684, 12159, 3887, 3911, 3667, 3832, 3965, 3928, 3927, 3944, 3981, 4029, 3958, 3895, 5179, 4065, 4042, 4049, 4079, 4095,
    4122, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642, 8159, 8169, 7081, 8006, 4779, 12153, 3895, 5181, 3623, 3654, 3700, 4660, 3716,
    3733, 4661, 3717, 3770, 3797, 3748, 9846, 3803, 3754, 10976, 10965, 3850, 3819, 3848, 12206, 3866, 3679, 3871, 3684, 12159, 3887, 3911, 3667, 3832, 3965,
    3928, 3927, 3944, 3981, 4029, 3958, 3895, 5179, 4065, 4042, 4049, 4079, 4095, 4122, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642,
    10444, 10454, 5111, 5889, 4779, 5444, 3895, 5181, 3623, 3654, 12175, 4660, 3716, 12191, 4661, 3717, 3770, 3797, 3748, 9846, 3803, 3754, 10976, 10965, 3850,
    3819, 3848, 12206, 3866, 3679, 3871, 3684, 12159, 3887, 3911, 3667, 3832, 3965, 3928, 3927, 3944, 3981, 4029, 3958, 3895, 5179, 4065, 4042, 4049, 4079,
    4095, 4122, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 8642, 4221, 4779, 4779, 6038, 4779, 6111, 6803, 6159, 4376, 4779, 4739, 6396,
    6396, 4759, 6157, 6158, 4779, 4796, 6396, 5948, 6157, 6157, 6234, 7837, 6396, 9771, 6157, 7974, 6115, 6396, 6157, 7974, 6117, 9771, 6158, 6115, 9773, 7976,
    6397, 6157, 6117, 8748, 9769, 4954, 6618, 9774, 8809, 4955, 10159, 10163, 11622, 4876, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779,
    4779, 12233, 4779, 4226, 9043, 4779, 5444, 3895, 5181, 12254, 3654, 5449, 4660, 3716, 5450, 4661, 3717, 3770, 3797, 3748, 9846, 3803, 3754, 10976, 10965,
    3850, 3819, 3848, 12206, 3866, 3679, 3871, 3684, 12159, 3887, 3911, 3667, 3832, 3965, 3928, 3927, 3944, 3981, 4029, 3958, 3895, 5179, 4065, 4042, 4049,
    4079, 4095, 4122, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 4779, 10300, 10300, 10300, 10300, 10312, 10300, 10300, 10300, 10300, 10300,
    10300, 10300, 10300, 10300, 10300, 10300, 10300, 0, 134144, 0, 0, 10300, 10300, 10300, 10300, 10300, 10300, 10300, 10300, 10300, 10300, 10300, 10300, 10300,
    10300, 10300, 10300, 69, 10300, 181248, 205824, 220160, 0, 69, 69, 0, 0, 0, 0, 0, 0, 0, 0, 194560, 0, 0, 0, 0, 150, 19607, 150, 2121, 2121, 19529, 2121, 0,
    0, 78, 79, 139264, 201728, 202752, 0, 0, 208896, 210944, 212992, 0, 218112, 221184, 0, 0, 235520, 0, 0, 0, 0, 0, 140288, 140288, 140288, 186368, 140288,
    140288, 191488, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 236544, 140288, 238592, 0, 0,
    196608, 0, 226304, 0, 0, 0, 180, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 194560, 218112, 140288, 221184,
    140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 235520, 140288, 140288, 140288, 135168, 0, 0, 227, 140288, 140288, 140288, 140288,
    140288, 140288, 140288, 140288, 140288, 140288, 140288, 194560, 140288, 140288, 140288, 140288, 199680, 140288, 140288, 140288, 140288, 140288, 211968,
    214016, 215040, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 0, 0, 0, 0, 179200, 189440, 0, 0, 0, 0, 215040, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 106, 106, 106, 106, 188, 106, 106, 0, 0, 140288, 0, 140288, 179200, 140288, 140288, 140288, 140288, 140288, 140288, 189440, 140288, 140288, 140288,
    140288, 140288, 140288, 140288, 199680, 140288, 140288, 140288, 230400, 231424, 140288, 233472, 140288, 140288, 140288, 140288, 140288, 140288, 183296,
    140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 186368, 140288, 140288, 191488, 140288, 140288, 140288, 140288, 192512,
    140288, 140288, 140288, 140288, 140288, 203776, 140288, 140288, 209920, 140288, 219136, 140288, 140288, 140288, 140288, 0, 238592, 0, 236544, 0, 140288,
    180224, 140288, 140288, 185344, 140288, 140288, 140288, 140288, 140288, 195584, 140288, 140288, 140288, 140288, 140288, 140288, 222208, 140288, 140288,
    226304, 140288, 140288, 232448, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 0, 140288, 140288, 140288, 140288,
    140288, 196608, 140288, 140288, 140288, 140288, 140288, 222208, 140288, 140288, 226304, 140288, 140288, 232448, 140288, 191488, 140288, 184320, 140288,
    140288, 140288, 140288, 200704, 206848, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 177152, 0, 207872, 227328, 140288, 182272, 140288,
    140288, 140288, 197632, 207872, 216064, 223232, 140288, 227328, 140288, 140288, 140288, 140288, 140288, 237568, 0, 140288, 140288, 140288, 140288, 140288,
    140288, 140288, 140288, 140288, 0, 0, 0, 206848, 184320, 177152, 140288, 140288, 140288, 182272, 140288, 140288, 140288, 197632, 207872, 216064, 223232,
    140288, 227328, 140288, 140288, 140288, 0, 0, 0, 0, 176, 0, 0, 0, 0, 106, 106, 182, 106, 106, 106, 106, 482, 106, 106, 106, 106, 106, 106, 106, 106, 106,
    106, 106, 551, 106, 106, 106, 106, 140288, 187392, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 237568, 140288, 187392, 140288, 140288,
    140288, 140288, 140288, 229376, 140288, 140288, 193536, 140288, 217088, 140288, 140288, 140288, 229376, 140288, 140288, 140288, 140288, 140288, 140288,
    140288, 140288, 0, 140288, 140288, 190464, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 190464, 140288, 140288, 140288, 140288,
    178176, 140288, 140288, 140288, 140288, 228352, 178176, 140288, 140288, 140288, 140288, 228352, 140288, 198656, 224256, 140288, 140288, 198656, 224256,
    140288, 188416, 140288, 188416, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 0, 12288, 140288, 179200,
    140288, 140288, 225280, 225280, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 287, 0, 181248, 205824, 220160, 0, 69, 69, 0, 78, 0, 0, 0, 0, 0, 0, 194560, 0, 0,
    0, 0, 531, 106, 106, 533, 534, 106, 106, 106, 106, 106, 106, 106, 325, 106, 106, 106, 106, 106, 106, 106, 106, 326, 106, 106, 106, 106, 106, 106, 106, 0,
    16384, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 69, 16384, 0, 0, 17408, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 69, 0, 0, 0, 0, 2121, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 134144, 0, 0, 17408, 0, 0, 0, 2121, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68, 0, 69, 0, 181248, 205824, 220160, 0, 69, 69, 0, 0, 79, 0, 0, 0, 0, 0,
    194560, 0, 0, 0, 0, 2121, 0, 0, 0, 0, 0, 83, 83, 83, 83, 83, 83, 14419, 14419, 14419, 14419, 14419, 14419, 14419, 14419, 14419, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    106, 106, 183, 106, 106, 106, 106, 61, 61, 61, 61, 2122, 61, 61, 61, 18493, 18493, 61, 61, 61, 61, 61, 18493, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 70,
    18493, 61, 61, 61, 18493, 61, 61, 18493, 18493, 18493, 18493, 18493, 61, 61, 18493, 61, 18493, 18493, 61, 18493, 18493, 18493, 18493, 18493, 18493, 18493,
    18493, 0, 0, 134144, 0, 0, 0, 0, 69, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 119, 138, 119, 119, 119, 181248, 205824, 220160, 0, 149, 149, 0, 0, 0, 0, 0, 0, 0,
    0, 194560, 0, 0, 0, 0, 2121, 0, 0, 0, 0, 0, 22528, 22528, 22528, 22528, 22528, 22528, 22528, 22528, 22528, 22528, 22528, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20480,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 69, 0, 0, 0, 0, 2121, 0, 0, 0, 0, 0, 24576, 24576, 24576, 24576, 24576, 24576, 24576, 24576, 24576, 24576, 24576, 0, 0, 0, 0, 0,
    20480, 20480, 20480, 0, 2121, 20480, 20480, 20480, 0, 20480, 20480, 20480, 20480, 20480, 20480, 20480, 20480, 20480, 20480, 20480, 0, 0, 0, 0, 0, 20480, 0,
    20480, 20480, 0, 0, 0, 20480, 0, 0, 20480, 0, 0, 134144, 0, 0, 0, 0, 69, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 280, 181248, 205824, 220160, 0, 69, 273408, 273408,
    0, 0, 0, 0, 0, 0, 0, 194560, 0, 0, 0, 0, 2121, 0, 0, 0, 0, 0, 33876, 33876, 33876, 33876, 33876, 33876, 33876, 33876, 33876, 33876, 33876, 0, 0, 0, 0, 0, 0,
    21504, 21504, 21504, 12412, 12412, 12412, 12412, 12412, 12412, 12412, 0, 0, 134144, 0, 0, 0, 0, 69, 69, 0, 0, 0, 0, 0, 0, 0, 279, 0, 0, 0, 0, 69, 69, 0, 0,
    0, 0, 0, 0, 278, 0, 0, 0, 0, 0, 140467, 140467, 140467, 186547, 140467, 140467, 191667, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 140514,
    140514, 140514, 186594, 140514, 140514, 191714, 140514, 140514, 0, 12288, 227, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288,
    140288, 140288, 194560, 140288, 140288, 140288, 140288, 201728, 202752, 140288, 204800, 140288, 208896, 140288, 210944, 212992, 140288, 140288, 140288,
    218112, 375, 0, 0, 0, 179200, 189440, 0, 0, 0, 0, 215040, 0, 0, 0, 0, 0, 0, 0, 0, 0, 165, 0, 0, 0, 0, 0, 0, 0, 0, 0, 106, 106, 106, 106, 187, 106, 106, 0,
    23552, 0, 0, 2121, 0, 23552, 0, 0, 23552, 23552, 23552, 23552, 23552, 23552, 23552, 23552, 23552, 23552, 23552, 0, 0, 0, 0, 0, 0, 0, 0, 180, 106, 106, 106,
    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 672, 106, 125, 0, 0, 227, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 360, 125,
    375, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 172, 0, 0, 291, 0, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 487, 106, 106, 106, 106,
    106, 663, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 674, 125, 125, 125, 677, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,
    125, 125, 26624, 134416, 0, 0, 0, 106, 106, 106, 106, 106, 693, 106, 694, 695, 106, 106, 106, 106, 125, 125, 125, 125, 106, 829, 125, 830, 106, 125, 106,
    125, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 387, 0, 106, 713, 106, 106, 106, 106, 106, 719, 106, 106, 106, 125, 723, 125, 125, 125, 125, 125, 125, 367,
    125, 125, 125, 125, 125, 125, 125, 125, 0, 125, 125, 729, 125, 125, 125, 0, 733, 106, 106, 106, 106, 106, 106, 106, 106, 216, 106, 106, 0, 125, 125, 125,
    125, 106, 743, 125, 125, 125, 125, 125, 125, 125, 125, 125, 0, 106, 106, 106, 106, 106, 106, 106, 106, 106, 125, 0, 106, 776, 106, 106, 106, 106, 106, 106,
    106, 106, 125, 785, 125, 125, 125, 125, 125, 125, 376, 376, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 288, 0, 0, 0, 0, 25743, 25743, 25743, 25743, 25743,
    25743, 25743, 0, 0, 134144, 0, 0, 0, 0, 69, 69, 0, 0, 0, 0, 0, 277, 0, 0, 0, 0, 0, 27753, 27753, 27753, 27753, 27753, 0, 0, 0, 134144, 0, 0, 0, 0, 27753,
    27753, 27753, 27753, 27753, 27753, 27753, 27753, 27753, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17408, 0, 0, 0, 0, 0, 17408, 17408, 17408, 17408, 17408, 17408, 17408, 0,
    0, 134144, 0, 0, 0, 0, 0, 0, 2123, 0, 0, 0, 0, 0, 29696, 29696, 29696, 29696, 29696, 29696, 29759, 29696, 29696, 29759, 29696, 29696, 29759, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 111616, 111616, 0, 0, 134144, 0, 0, 181248, 205824, 220160, 0, 273559, 150, 0, 0, 0, 0, 0, 0, 0, 0, 194560, 0, 0, 0, 0, 2121, 0, 0, 0, 0, 0,
    36864, 36864, 36864, 36864, 36864, 36864, 36967, 36967, 36967, 36967, 36967, 36967, 36967, 36967, 36967, 36967, 0, 0, 0, 0, 0, 0, 0, 0, 0, 140288, 140468,
    140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 0, 134144, 0, 0, 0, 180,
    140467, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 194739, 218291, 140467, 221363, 140467, 140467, 140467, 140467,
    140467, 140467, 140467, 140467, 140467, 235699, 140467, 140467, 140467, 140467, 201907, 202931, 140467, 204979, 140467, 209075, 140467, 211123, 213171,
    140467, 140467, 140467, 140467, 199859, 140467, 140467, 140467, 140467, 140467, 212147, 214195, 215219, 140467, 140467, 140467, 0, 0, 227, 140514, 140514,
    140514, 140514, 140514, 140514, 140514, 140514, 140514, 140514, 140514, 194786, 140514, 140514, 140514, 140514, 212194, 214242, 215266, 140514, 140514,
    140514, 140514, 140514, 140514, 140514, 140514, 140514, 0, 0, 0, 206848, 184320, 177331, 140467, 140514, 140514, 140514, 201954, 202978, 140514, 205026,
    140514, 209122, 140514, 211170, 213218, 140514, 140514, 140514, 218338, 140514, 221410, 140514, 140514, 140514, 140514, 140514, 140514, 140514, 140514,
    140514, 235746, 140514, 140514, 140514, 135168, 0, 0, 140288, 0, 140467, 179379, 140467, 140467, 140467, 140467, 140467, 140467, 189619, 140467, 140467,
    140467, 230579, 231603, 140467, 233651, 140467, 140467, 140467, 140514, 140514, 140514, 183522, 140514, 140514, 140514, 140514, 140514, 140514, 189666,
    140514, 140514, 140514, 140514, 140514, 140514, 140514, 199906, 140514, 192691, 140467, 140467, 140467, 140467, 140467, 203955, 140467, 140467, 210099,
    140467, 219315, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 236723, 140467, 238771, 140514,
    140514, 192738, 140514, 140514, 140514, 140514, 140514, 204002, 140514, 140514, 210146, 140514, 219362, 140514, 140514, 140514, 140514, 140514, 237794, 0,
    140467, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 225, 140514, 140514, 140514, 140514, 140514, 140514, 140514, 140514,
    230626, 231650, 140514, 233698, 140514, 140514, 140514, 0, 0, 0, 0, 0, 0, 0, 0, 0, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288,
    140288, 140288, 194560, 140288, 0, 238592, 0, 236544, 0, 140467, 180403, 140467, 140467, 185523, 140467, 140467, 140467, 140467, 140467, 195763, 140514,
    180450, 140514, 140514, 185570, 140514, 140514, 140514, 140514, 140514, 195810, 140514, 140514, 140514, 140514, 140514, 140514, 0, 136192, 234496, 0, 0,
    192512, 0, 203776, 0, 0, 140467, 222387, 140467, 140467, 226483, 140467, 140467, 232627, 140467, 140514, 140514, 140514, 140514, 140514, 140514, 140514,
    140514, 236770, 140514, 238818, 0, 0, 196608, 0, 226304, 140514, 196834, 140514, 140514, 140514, 140514, 140514, 222434, 140514, 140514, 226530, 140514,
    140514, 232674, 140514, 191488, 184499, 140467, 140467, 140467, 140467, 200883, 207027, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 140467,
    177378, 140514, 184546, 140514, 140514, 140514, 140514, 200930, 207074, 140514, 140514, 140514, 140514, 140514, 140514, 140514, 140514, 140514, 140514,
    140514, 140514, 140514, 140514, 0, 134144, 0, 207872, 227328, 140467, 182451, 140467, 140467, 140467, 197811, 208051, 216243, 223411, 140467, 227507,
    140467, 140467, 140514, 225459, 225506, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 170, 0, 0, 140467, 187571, 140467, 140467, 140467, 140467, 140467, 140467,
    140467, 140467, 237747, 140514, 187618, 140514, 140514, 140514, 140514, 140514, 229376, 140467, 140467, 193715, 140467, 217267, 140467, 140467, 140467,
    229555, 140514, 0, 140467, 140467, 190643, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 140514, 140514, 190690, 140514, 140514, 140514, 140514,
    178355, 140467, 140467, 140467, 140467, 228531, 178402, 140514, 140514, 140514, 140514, 228578, 140514, 193762, 140514, 217314, 140514, 140514, 140514,
    229602, 140467, 140467, 140467, 140467, 140467, 140467, 140514, 140514, 140514, 140514, 140514, 140514, 140514, 140514, 140514, 140514, 0, 140467, 140467,
    140467, 140467, 140467, 198835, 224435, 140467, 140514, 198882, 224482, 140514, 188595, 140467, 188642, 140514, 140467, 140514, 140467, 140514, 182498,
    140514, 140514, 140514, 197858, 208098, 216290, 223458, 140514, 227554, 140514, 140514, 140514, 0, 0, 0, 0, 34816, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    386, 0, 0, 0, 0, 15360, 35840, 39936, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 385, 0, 0, 0, 0, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 0, 0, 69, 0,
    0, 0, 41984, 0, 2121, 0, 0, 0, 0, 0, 0, 0, 0, 41984, 0, 41984, 0, 0, 0, 0, 0, 0, 0, 41984, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65, 0, 0, 0, 0, 69, 0, 0, 0, 0, 0,
    41984, 41984, 41984, 41984, 41984, 41984, 41984, 0, 0, 134144, 0, 0, 0, 0, 69, 69, 69, 76, 76, 76, 76, 2121, 0, 78, 79, 139264, 0, 0, 0, 0, 43008, 43008,
    43008, 43008, 43008, 43008, 43008, 0, 0, 134144, 0, 0, 0, 0, 69, 69, 69, 77, 77, 77, 77, 0, 2121, 78, 79, 139264, 0, 0, 291, 180, 106, 106, 106, 106, 106,
    106, 106, 106, 106, 106, 106, 106, 552, 106, 106, 106, 12621, 291, 227, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 514, 125, 0,
    0, 291, 391, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 12621, 0, 125, 125, 107, 107, 107, 107, 126, 126, 126, 126, 126, 126, 126, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 196787, 140467, 140467, 140467, 140467, 0, 0, 44032, 44032, 44032, 44032,
    44032, 44032, 44032, 44032, 44032, 0, 0, 0, 0, 0, 0, 0, 0, 161, 0, 166, 0, 169, 0, 171, 0, 0, 0, 0, 0, 44032, 44032, 44032, 44032, 44032, 44032, 44032, 0,
    0, 134144, 0, 0, 0, 0, 69, 69, 69, 2121, 2121, 2121, 2121, 0, 0, 78, 79, 80, 0, 0, 0, 65, 2121, 80, 65, 0, 80, 80, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
    86, 108, 127, 108, 108, 108, 108, 108, 108, 108, 127, 127, 127, 127, 127, 127, 127, 0, 0, 0, 0, 0, 0, 0, 0, 162, 0, 167, 0, 0, 0, 0, 0, 0, 0, 0, 382, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 0, 0, 291, 391, 106, 106, 393, 106, 106, 106, 106, 106, 106, 106, 106,
    106, 125, 125, 125, 500, 125, 125, 125, 427, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 0, 0, 125, 125, 125, 457, 125,
    125, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 168, 0, 0, 0, 0, 0, 0, 467, 0, 469, 469, 391, 106, 106, 106, 473, 106, 106, 106, 106, 106, 211, 213, 106, 106, 222,
    106, 0, 125, 125, 229, 125, 594, 106, 106, 106, 106, 106, 106, 106, 106, 125, 125, 125, 125, 125, 125, 125, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 125, 125, 555,
    556, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 359, 125, 125, 758, 106, 760, 106, 762, 106, 125, 125, 125, 125, 768, 125, 770, 125,
    772, 125, 125, 125, 125, 125, 459, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 384, 0, 0, 0, 0, 102, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 109, 128, 109,
    109, 109, 109, 128, 128, 128, 128, 128, 128, 128, 0, 0, 0, 0, 0, 0, 0, 0, 45056, 0, 45056, 0, 0, 134144, 0, 0, 0, 155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 388, 0, 0, 291, 180, 293, 106, 106, 106, 106, 106, 106, 106, 302, 106, 106, 106, 206, 208, 106, 212, 106, 215, 106, 106, 0, 125, 125, 125, 231,
    106, 307, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 125, 12621, 291, 227, 335, 125, 125, 125, 125, 125, 125, 125, 344,
    125, 125, 125, 125, 106, 106, 106, 106, 820, 106, 125, 125, 125, 125, 824, 125, 349, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,
    125, 272, 144, 0, 0, 291, 391, 106, 106, 106, 106, 106, 106, 106, 398, 106, 106, 106, 106, 321, 106, 106, 106, 106, 106, 106, 106, 106, 330, 106, 106, 414,
    415, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 12621, 391, 125, 125, 125, 125, 125, 125, 520, 125, 125, 125, 125, 0, 0, 0, 0, 0, 0, 0, 63, 64, 0, 0,
    0, 0, 0, 71, 0, 0, 580, 0, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 592, 106, 106, 106, 543, 106, 106, 106, 106, 106, 549, 106, 106, 106, 106,
    106, 106, 639, 125, 641, 125, 125, 125, 644, 125, 125, 125, 125, 125, 125, 125, 610, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 0, 106, 734, 106,
    106, 106, 738, 106, 106, 106, 0, 619, 0, 0, 0, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 593, 632, 633, 106, 106, 106, 106, 106, 125, 125,
    125, 125, 125, 125, 125, 125, 125, 125, 0, 106, 106, 106, 106, 737, 106, 739, 740, 741, 125, 125, 649, 650, 125, 125, 125, 125, 125, 0, 0, 0, 0, 0, 106,
    106, 106, 106, 626, 106, 106, 106, 106, 106, 106, 106, 106, 106, 826, 125, 125, 125, 828, 106, 106, 125, 125, 106, 125, 106, 125, 125, 125, 125, 703, 125,
    125, 125, 125, 125, 125, 125, 125, 125, 0, 110, 110, 110, 110, 129, 129, 129, 129, 129, 129, 129, 0, 0, 0, 0, 0, 0, 0, 159, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    38997, 0, 0, 134144, 0, 0, 0, 0, 0, 163, 0, 0, 0, 0, 0, 106, 106, 106, 106, 106, 106, 106, 106, 106, 539, 106, 106, 199, 106, 106, 106, 106, 106, 106, 106,
    106, 106, 0, 125, 125, 125, 125, 106, 106, 818, 819, 106, 106, 125, 125, 822, 823, 125, 125, 125, 125, 125, 125, 246, 125, 125, 125, 125, 125, 125, 125,
    125, 125, 0, 0, 659, 0, 0, 106, 106, 0, 0, 291, 180, 294, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 0, 125, 125, 125, 125, 106, 319, 106, 106,
    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 318, 12621, 291, 227, 336, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,
    373, 125, 0, 361, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 0, 134144, 125, 125, 569, 125, 125, 125, 125, 125, 125, 125, 125, 0,
    0, 0, 0, 0, 0, 0, 0, 463, 464, 0, 0, 0, 106, 106, 106, 106, 586, 106, 106, 106, 106, 106, 106, 106, 106, 313, 106, 106, 315, 106, 106, 106, 106, 106, 125,
    125, 745, 125, 125, 125, 125, 125, 125, 125, 0, 106, 106, 106, 106, 106, 106, 106, 106, 782, 106, 125, 125, 125, 125, 125, 125, 125, 125, 258, 260, 125,
    125, 269, 125, 0, 0, 106, 759, 106, 106, 106, 106, 125, 125, 125, 125, 125, 769, 125, 125, 125, 125, 106, 817, 106, 106, 106, 106, 125, 821, 125, 125, 125,
    125, 125, 125, 125, 355, 125, 125, 357, 125, 125, 125, 125, 125, 125, 125, 125, 656, 0, 658, 0, 0, 0, 106, 106, 106, 106, 106, 587, 106, 106, 106, 106, 106,
    106, 106, 484, 106, 106, 106, 106, 106, 106, 106, 106, 219, 106, 106, 0, 125, 125, 125, 125, 0, 0, 0, 0, 2121, 80, 0, 81, 80, 80, 88, 88, 88, 88, 88, 88,
    88, 88, 88, 88, 88, 111, 130, 111, 111, 111, 111, 111, 111, 111, 130, 130, 130, 130, 130, 130, 130, 0, 0, 0, 0, 0, 0, 0, 160, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    109667, 0, 0, 134144, 0, 0, 197, 106, 204, 106, 209, 106, 106, 214, 217, 220, 106, 0, 125, 125, 125, 125, 125, 125, 125, 368, 125, 125, 125, 125, 125, 125,
    125, 0, 234, 125, 125, 244, 125, 251, 125, 256, 125, 125, 261, 264, 267, 125, 0, 273, 0, 0, 0, 274, 69, 69, 0, 0, 0, 275, 0, 0, 0, 0, 0, 0, 0, 0, 0, 106,
    106, 106, 106, 106, 191, 106, 0, 0, 291, 180, 106, 106, 106, 106, 106, 106, 106, 106, 106, 303, 106, 106, 106, 310, 106, 106, 106, 106, 106, 106, 106, 106,
    106, 106, 106, 106, 329, 106, 106, 106, 106, 306, 106, 106, 106, 106, 106, 106, 106, 106, 106, 314, 106, 106, 106, 106, 106, 323, 324, 106, 106, 106, 106,
    106, 106, 106, 106, 106, 667, 106, 106, 106, 106, 106, 106, 125, 12621, 291, 227, 125, 125, 125, 125, 125, 125, 125, 125, 125, 345, 125, 125, 348, 125, 125,
    125, 363, 125, 125, 125, 125, 125, 125, 125, 125, 372, 125, 125, 273, 0, 0, 0, 379, 0, 0, 380, 381, 0, 383, 0, 0, 0, 0, 0, 0, 0, 0, 0, 106, 106, 106, 106,
    106, 192, 106, 0, 0, 291, 391, 392, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 401, 106, 106, 404, 106, 106, 106, 106, 106, 409, 106, 106, 106, 106,
    411, 412, 413, 125, 125, 443, 125, 125, 125, 125, 445, 446, 447, 125, 125, 125, 125, 452, 125, 125, 125, 125, 125, 508, 125, 125, 125, 125, 125, 125, 125,
    125, 125, 125, 125, 125, 513, 125, 125, 125, 454, 125, 125, 125, 458, 125, 0, 0, 0, 460, 0, 0, 0, 0, 0, 0, 0, 0, 0, 106, 106, 106, 106, 106, 193, 106, 125,
    505, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 515, 516, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 0, 0, 0, 0, 0, 660, 106,
    618, 0, 620, 621, 622, 106, 106, 625, 106, 106, 106, 106, 628, 106, 106, 631, 125, 648, 125, 125, 125, 125, 653, 655, 125, 0, 0, 0, 0, 0, 106, 661, 675,
    125, 125, 125, 125, 125, 125, 125, 125, 681, 125, 125, 125, 125, 125, 125, 125, 125, 125, 511, 125, 125, 125, 125, 125, 125, 125, 125, 125, 435, 125, 125,
    438, 125, 125, 125, 688, 0, 0, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 698, 742, 125, 125, 125, 125, 125, 125, 125, 125, 125, 752, 0,
    106, 106, 756, 106, 106, 106, 596, 106, 106, 106, 106, 106, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 711, 0, 775, 106, 106,
    777, 106, 779, 106, 106, 106, 106, 784, 125, 125, 786, 125, 125, 125, 125, 125, 611, 125, 125, 125, 125, 125, 125, 125, 125, 125, 0, 136192, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 29696, 0, 19456, 134144, 31744, 0, 788, 125, 125, 125, 125, 0, 106, 106, 106, 106, 106, 106, 106, 106, 106, 125, 125, 125, 125, 125, 605,
    125, 125, 125, 125, 816, 106, 106, 106, 106, 106, 106, 125, 125, 125, 125, 125, 125, 125, 125, 125, 707, 125, 125, 125, 125, 0, 112, 112, 112, 112, 131,
    131, 131, 131, 131, 131, 131, 0, 0, 0, 0, 0, 0, 0, 283, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33876, 0, 0, 134144, 0, 0, 0, 0, 147, 0, 69, 69, 69, 2121, 2121, 2121,
    2121, 0, 0, 78, 79, 80, 106, 200, 106, 106, 106, 106, 106, 106, 106, 106, 106, 0, 125, 125, 125, 125, 125, 125, 125, 433, 125, 125, 125, 125, 125, 125, 125,
    125, 125, 125, 371, 125, 125, 125, 125, 0, 125, 125, 125, 125, 247, 125, 125, 125, 125, 125, 125, 125, 125, 125, 0, 0, 0, 0, 461, 0, 0, 0, 0, 0, 529, 0, 0,
    0, 0, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 0, 125, 125, 125, 232, 825, 106, 106, 106, 827, 125, 125, 125, 106, 106, 125, 125, 106, 125,
    106, 125, 125, 125, 125, 747, 125, 749, 750, 751, 125, 0, 106, 106, 106, 106, 106, 106, 106, 781, 106, 106, 125, 125, 125, 125, 125, 125, 125, 125, 521,
    125, 125, 0, 0, 526, 0, 0, 113, 113, 113, 113, 132, 132, 132, 132, 132, 132, 132, 0, 0, 0, 0, 0, 0, 391, 106, 106, 106, 106, 106, 106, 106, 106, 106, 125,
    125, 125, 125, 604, 125, 125, 0, 0, 0, 148, 69, 69, 69, 2121, 2121, 2121, 2121, 0, 0, 78, 79, 80, 699, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,
    125, 125, 125, 710, 0, 0, 0, 0, 2121, 0, 0, 0, 0, 0, 45056, 45056, 45056, 45056, 45056, 45056, 45056, 45056, 45056, 45056, 45056, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    2121, 80, 0, 0, 80, 80, 90, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 114, 133, 114, 114, 114, 114, 114, 114, 114, 133, 133, 133, 133, 133,
    133, 133, 0, 0, 0, 0, 0, 0, 391, 106, 106, 106, 106, 474, 106, 106, 106, 106, 235, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 0, 0, 0,
    0, 0, 106, 106, 0, 0, 281, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 286, 0, 0, 0, 0, 69, 69, 69, 2121, 2121, 2121, 2121, 0, 0, 78, 79, 139264, 0, 0, 291, 180, 106,
    106, 106, 106, 298, 106, 106, 106, 106, 106, 106, 106, 421, 422, 106, 106, 106, 12621, 391, 125, 125, 12621, 291, 227, 125, 125, 125, 125, 340, 125, 125,
    125, 125, 125, 125, 125, 125, 106, 106, 106, 106, 809, 106, 125, 125, 106, 106, 542, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,
    331, 106, 579, 0, 0, 106, 106, 106, 106, 106, 106, 106, 106, 106, 590, 106, 106, 106, 207, 210, 106, 106, 106, 218, 221, 106, 0, 125, 125, 125, 233, 106,
    106, 595, 106, 106, 597, 106, 106, 599, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 448, 449, 125, 125, 125, 125, 125, 125, 608, 125, 125, 125, 125,
    125, 613, 125, 125, 615, 125, 125, 617, 0, 0, 0, 0, 2121, 0, 0, 0, 0, 0, 109667, 109667, 109667, 109667, 109667, 109667, 109667, 109667, 109667, 109667,
    109667, 0, 0, 0, 0, 0, 125, 125, 801, 125, 802, 125, 125, 125, 106, 106, 106, 106, 106, 106, 125, 125, 125, 767, 125, 125, 125, 125, 125, 125, 0, 0, 0, 0,
    2121, 80, 0, 0, 80, 80, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 115, 134, 115, 115, 115, 115, 115, 115, 115, 134, 134, 134, 134, 134, 134, 134, 0, 0, 0,
    0, 0, 0, 391, 106, 106, 472, 106, 106, 106, 106, 106, 106, 311, 106, 106, 106, 106, 106, 106, 106, 106, 106, 125, 125, 499, 125, 125, 125, 125, 154, 0, 0,
    0, 0, 0, 0, 158, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36967, 0, 0, 134144, 0, 32768, 125, 237, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 0, 0, 0,
    578, 0, 106, 106, 308, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 673, 125, 125, 350, 125, 125, 125, 125, 125, 125, 125, 125,
    125, 125, 125, 125, 125, 125, 125, 566, 0, 0, 291, 391, 106, 106, 106, 106, 106, 396, 106, 106, 106, 106, 106, 106, 407, 106, 106, 106, 106, 106, 106, 106,
    106, 106, 494, 106, 106, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 709, 125, 0, 125, 125, 125, 430, 125, 125, 125, 125, 125, 125, 125,
    125, 125, 439, 125, 125, 125, 125, 125, 125, 612, 125, 125, 125, 125, 125, 125, 125, 125, 0, 106, 106, 735, 106, 106, 106, 106, 106, 106, 0, 0, 581, 106,
    106, 584, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 486, 106, 106, 106, 106, 106, 125, 789, 125, 125, 125, 0, 793, 106, 106, 106, 106, 106, 106,
    106, 106, 799, 0, 0, 0, 0, 2121, 80, 0, 0, 80, 80, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 116, 135, 116, 116, 116, 116, 116, 116, 116, 135, 135, 135,
    135, 135, 135, 135, 0, 0, 0, 0, 0, 0, 391, 106, 471, 106, 106, 106, 106, 106, 106, 106, 406, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 328, 106,
    106, 106, 106, 332, 125, 238, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 0, 0, 0, 0, 69, 69, 69, 2121, 2121, 2121, 2121, 0, 0, 78, 6297,
    139264, 0, 0, 291, 180, 106, 106, 106, 106, 106, 299, 106, 106, 106, 106, 106, 106, 598, 106, 106, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 0, 106,
    755, 106, 106, 12621, 291, 227, 125, 125, 125, 125, 125, 341, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 512, 125, 125, 125, 125, 125, 0, 0, 378, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 69, 0, 0, 0, 291, 391, 106, 106, 106, 106, 106, 106, 397, 106, 106, 106, 400, 106, 106, 106, 635, 106, 106, 106, 125,
    125, 125, 125, 125, 125, 125, 125, 125, 125, 0, 106, 106, 106, 757, 125, 125, 125, 125, 431, 125, 125, 125, 434, 125, 125, 125, 125, 125, 125, 125, 125,
    125, 125, 523, 524, 0, 0, 0, 528, 125, 125, 125, 444, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 451, 125, 125, 106, 492, 106, 106,
    106, 106, 106, 106, 106, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 0, 273, 504, 125, 125, 125, 125, 125, 125, 125, 125, 125,
    125, 125, 125, 125, 125, 125, 273, 125, 125, 125, 519, 125, 125, 125, 125, 125, 125, 125, 0, 0, 0, 0, 0, 0, 462, 0, 0, 0, 125, 125, 125, 125, 731, 125, 0,
    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 125, 125, 125, 125, 125, 502, 503, 0, 0, 0, 0, 2121, 80, 0, 0, 80, 80, 93, 93, 93, 93, 93, 93, 93, 93, 93,
    93, 93, 117, 136, 117, 117, 117, 117, 117, 117, 117, 136, 136, 136, 136, 136, 136, 136, 0, 0, 0, 0, 0, 0, 16384, 0, 0, 16384, 16384, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 163, 0, 0, 0, 0, 0, 0, 0, 0, 0, 106, 106, 106, 106, 106, 190, 106, 0, 146, 0, 0, 69, 69, 69, 2121, 2121, 2121, 2121, 0, 0, 78, 79, 80, 0, 174, 0, 175, 0,
    0, 0, 0, 0, 106, 106, 181, 106, 106, 106, 106, 322, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 425, 12621, 391, 125, 125, 106, 201, 106, 106,
    106, 106, 106, 106, 106, 106, 224, 0, 125, 125, 228, 125, 125, 125, 125, 125, 652, 125, 125, 125, 0, 0, 0, 0, 0, 106, 106, 106, 106, 106, 106, 106, 106,
    106, 696, 106, 106, 106, 125, 125, 125, 125, 248, 125, 125, 125, 125, 125, 125, 125, 125, 271, 0, 0, 0, 0, 69, 69, 69, 2121, 2121, 2121, 2121, 0, 0, 6296,
    79, 139264, 125, 125, 352, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 686, 125, 0, 377, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 139264, 0, 466, 0, 0, 0, 0, 391, 106, 106, 106, 106, 106, 106, 106, 106, 106, 125, 125, 602, 125, 125, 125, 125, 0, 0, 530, 0, 0, 106, 106, 106, 106,
    106, 535, 536, 106, 538, 106, 106, 106, 320, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 327, 106, 106, 106, 106, 106, 106, 125, 125, 125,
    125, 571, 125, 125, 125, 125, 125, 125, 0, 0, 0, 0, 0, 0, 22528, 22528, 22528, 22528, 22528, 0, 0, 134144, 0, 0, 106, 106, 634, 106, 106, 106, 106, 125,
    125, 125, 125, 125, 125, 125, 125, 646, 647, 125, 125, 125, 651, 125, 125, 125, 125, 0, 0, 0, 0, 0, 106, 106, 106, 106, 106, 106, 106, 589, 106, 106, 106,
    106, 106, 419, 106, 106, 106, 106, 106, 106, 12621, 391, 125, 125, 106, 662, 106, 106, 106, 106, 106, 106, 106, 106, 669, 106, 106, 106, 106, 125, 125, 125,
    125, 106, 106, 125, 125, 831, 832, 106, 125, 125, 125, 676, 125, 125, 125, 125, 125, 125, 125, 125, 683, 125, 125, 125, 125, 125, 125, 125, 510, 125, 125,
    125, 125, 125, 125, 125, 125, 125, 125, 125, 266, 125, 125, 0, 0, 0, 0, 0, 106, 106, 106, 691, 106, 106, 106, 106, 106, 106, 106, 106, 106, 125, 498, 125,
    125, 125, 125, 125, 727, 125, 125, 125, 125, 125, 0, 106, 106, 106, 736, 106, 106, 106, 106, 106, 483, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,
    545, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 125, 601, 125, 125, 125, 125, 125, 106, 125, 125, 125, 746, 125, 125, 125, 125, 125, 125, 753, 106,
    106, 106, 106, 418, 106, 420, 106, 106, 106, 424, 106, 12621, 391, 426, 125, 813, 814, 125, 125, 106, 106, 106, 106, 106, 106, 125, 125, 125, 125, 125, 125,
    125, 125, 125, 561, 125, 125, 125, 125, 125, 125, 125, 125, 125, 356, 125, 125, 125, 125, 125, 125, 125, 125, 125, 370, 125, 125, 125, 125, 374, 0, 835,
    836, 106, 125, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 108544, 69, 0, 0, 0, 0, 0, 2121, 80, 0, 0, 80, 80, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 118,
    137, 118, 118, 118, 118, 118, 118, 118, 137, 137, 137, 137, 137, 137, 137, 0, 0, 0, 0, 0, 0, 23552, 0, 0, 0, 0, 0, 0, 0, 69, 0, 173, 0, 0, 0, 173, 0, 0, 0,
    0, 106, 106, 106, 186, 189, 106, 195, 236, 125, 242, 125, 125, 125, 254, 257, 125, 125, 125, 265, 268, 125, 0, 0, 0, 0, 69, 69, 69, 10312, 2121, 2121, 2121,
    0, 0, 78, 79, 139264, 125, 125, 125, 364, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 0, 525, 0, 0, 0, 0, 0, 0, 582, 106, 106, 106, 106, 106,
    106, 106, 106, 106, 591, 106, 106, 106, 405, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 12621, 391, 125, 125, 125, 125, 125, 609, 125, 125,
    125, 125, 125, 125, 125, 125, 125, 125, 125, 0, 577, 0, 0, 0, 0, 0, 0, 689, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 670, 106, 106, 106,
    125, 106, 700, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 0, 0, 0, 0, 2121, 0, 0, 0, 62, 62, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    69, 0, 106, 106, 714, 106, 106, 106, 106, 106, 106, 106, 106, 125, 125, 724, 125, 125, 125, 125, 125, 125, 732, 106, 106, 106, 106, 106, 106, 106, 106, 106,
    125, 125, 125, 603, 125, 125, 606, 106, 125, 744, 125, 125, 125, 748, 125, 125, 125, 125, 0, 106, 106, 106, 106, 778, 106, 780, 106, 106, 106, 125, 125,
    125, 125, 787, 119, 119, 119, 119, 138, 138, 138, 138, 138, 138, 138, 0, 0, 0, 0, 0, 0, 24576, 24576, 24576, 24576, 24576, 0, 0, 134144, 0, 0, 0, 0, 291,
    180, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 305, 106, 106, 106, 664, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 125, 125, 125, 125,
    125, 125, 125, 125, 125, 125, 12621, 291, 227, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 347, 125, 125, 125, 125, 125, 353, 125, 125, 125, 125, 125,
    125, 125, 125, 125, 125, 125, 125, 450, 125, 125, 125, 567, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 0, 0, 0, 0, 0, 0, 37888, 0, 0, 140288, 140288,
    140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 0, 0, 140288, 179200, 125, 239, 125, 125, 125, 125, 125, 125, 125, 125, 125,
    125, 125, 125, 0, 0, 0, 0, 69, 69, 30720, 2121, 2121, 2121, 73, 0, 0, 78, 79, 139264, 125, 125, 125, 125, 678, 125, 125, 125, 125, 125, 125, 125, 125, 125,
    125, 125, 125, 125, 564, 125, 125, 0, 0, 0, 0, 2121, 80, 0, 0, 80, 80, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 120, 139, 120, 120, 120, 120, 120, 120,
    120, 139, 139, 139, 139, 139, 139, 139, 0, 0, 0, 0, 0, 106, 624, 106, 106, 106, 627, 106, 106, 106, 106, 106, 637, 106, 125, 125, 125, 125, 643, 125, 125,
    125, 125, 0, 0, 291, 180, 106, 295, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 223, 106, 0, 125, 125, 125, 125, 106, 106, 309, 106, 106, 106, 106,
    106, 106, 106, 106, 106, 106, 106, 106, 106, 316, 106, 106, 12621, 291, 227, 125, 337, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 270, 125,
    0, 0, 125, 351, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 687, 125, 125, 362, 125, 125, 125, 125, 125, 125, 125, 125, 125,
    125, 125, 125, 0, 0, 0, 0, 2121, 0, 0, 0, 21504, 21504, 21504, 21504, 21504, 21504, 21504, 21504, 21504, 21504, 21504, 0, 12412, 0, 21504, 0, 0, 0, 291,
    391, 106, 106, 106, 394, 106, 106, 106, 106, 106, 106, 106, 106, 485, 106, 106, 106, 106, 106, 106, 490, 106, 403, 106, 106, 106, 106, 106, 106, 106, 106,
    106, 106, 106, 106, 106, 106, 317, 106, 125, 428, 125, 125, 125, 125, 125, 125, 125, 125, 125, 437, 125, 125, 125, 125, 125, 125, 125, 559, 125, 125, 125,
    125, 125, 125, 125, 125, 106, 106, 106, 106, 106, 106, 125, 125, 125, 125, 125, 125, 125, 517, 125, 125, 125, 125, 125, 125, 125, 125, 125, 0, 0, 0, 0, 0,
    156, 0, 0, 0, 164, 0, 0, 0, 0, 0, 0, 0, 0, 0, 106, 106, 106, 106, 106, 194, 106, 712, 106, 106, 106, 106, 106, 106, 106, 720, 106, 106, 722, 125, 125, 125,
    125, 125, 125, 125, 574, 125, 125, 125, 0, 0, 0, 0, 0, 0, 391, 106, 106, 106, 106, 106, 475, 476, 106, 478, 125, 125, 125, 730, 125, 125, 0, 106, 106, 106,
    106, 106, 106, 106, 106, 106, 423, 106, 106, 12621, 391, 125, 125, 125, 125, 815, 125, 106, 106, 106, 106, 106, 106, 125, 125, 125, 125, 125, 125, 125, 125,
    125, 575, 125, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2121, 80, 0, 82, 80, 80, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 121, 140, 121, 121, 121, 121, 121, 121, 121,
    140, 140, 140, 140, 140, 140, 140, 0, 0, 0, 0, 0, 177, 0, 178, 0, 106, 106, 106, 184, 106, 106, 106, 145, 0, 0, 0, 69, 69, 69, 2121, 2121, 2121, 2121, 0, 0,
    78, 79, 80, 0, 0, 0, 165, 0, 0, 0, 0, 0, 106, 106, 106, 106, 106, 106, 106, 106, 629, 630, 106, 106, 202, 106, 106, 106, 106, 106, 106, 106, 106, 106, 0,
    125, 125, 125, 125, 125, 125, 125, 654, 125, 0, 0, 0, 0, 0, 106, 106, 106, 106, 106, 106, 106, 537, 106, 106, 106, 125, 125, 125, 125, 249, 125, 125, 125,
    125, 125, 125, 125, 125, 125, 0, 0, 0, 0, 77, 0, 0, 0, 0, 0, 111616, 111616, 111616, 111616, 111616, 111616, 111616, 111616, 111616, 111616, 111616, 0, 0,
    0, 0, 0, 289, 290, 291, 180, 106, 106, 106, 297, 106, 106, 300, 106, 106, 304, 106, 106, 106, 417, 106, 106, 106, 106, 106, 106, 106, 106, 12621, 391, 125,
    125, 125, 125, 125, 125, 573, 125, 125, 125, 125, 0, 0, 0, 0, 0, 0, 0, 0, 28672, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288,
    140288, 140288, 0, 140288, 140515, 140288, 140288, 12621, 291, 227, 125, 125, 125, 339, 125, 125, 342, 125, 125, 346, 125, 125, 125, 125, 125, 125, 509,
    125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 616, 125, 125, 0, 465, 0, 0, 0, 0, 0, 391, 470, 106, 106, 106, 106, 106, 106, 106, 106, 496,
    125, 125, 125, 125, 125, 125, 125, 491, 106, 106, 106, 106, 106, 106, 495, 106, 497, 125, 125, 125, 125, 125, 125, 125, 125, 125, 657, 0, 0, 0, 0, 106, 106,
    125, 125, 518, 125, 125, 125, 125, 125, 125, 522, 125, 0, 0, 0, 527, 0, 0, 0, 0, 2121, 78, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 107, 126, 107, 107, 107, 125,
    125, 125, 570, 125, 125, 125, 125, 125, 125, 125, 0, 0, 0, 0, 0, 532, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 717, 106, 106, 106, 106, 106, 125,
    125, 125, 125, 125, 704, 125, 705, 706, 125, 125, 125, 125, 125, 0, 106, 106, 106, 795, 106, 796, 106, 106, 106, 125, 607, 125, 125, 125, 125, 125, 125,
    125, 125, 614, 125, 125, 125, 125, 125, 0, 0, 0, 0, 2121, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 112, 131, 112, 112, 112, 125, 728, 125, 125, 125, 125, 0,
    106, 106, 106, 106, 106, 106, 106, 106, 106, 600, 125, 125, 125, 125, 125, 125, 125, 125, 790, 125, 125, 0, 106, 794, 106, 106, 106, 106, 106, 106, 106,
    125, 765, 125, 125, 125, 125, 125, 125, 125, 125, 106, 806, 106, 106, 106, 810, 125, 812, 800, 125, 125, 125, 125, 125, 125, 125, 106, 106, 106, 106, 106,
    106, 125, 125, 766, 125, 125, 125, 125, 125, 125, 125, 0, 0, 0, 0, 2121, 80, 0, 0, 80, 80, 97, 97, 101, 97, 101, 97, 101, 101, 101, 101, 101, 101, 101, 101,
    101, 101, 101, 122, 141, 122, 122, 122, 122, 141, 141, 141, 141, 141, 141, 141, 0, 0, 0, 0, 0, 623, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 410,
    106, 106, 106, 106, 106, 106, 198, 203, 205, 106, 106, 106, 106, 106, 106, 106, 106, 0, 125, 125, 230, 125, 125, 125, 125, 125, 679, 125, 125, 125, 125,
    682, 125, 125, 125, 125, 125, 125, 125, 125, 369, 125, 125, 125, 125, 125, 125, 0, 125, 125, 125, 245, 250, 252, 125, 125, 125, 125, 125, 125, 125, 125, 0,
    0, 0, 0, 78, 78, 78, 78, 78, 78, 78, 0, 0, 134144, 0, 0, 0, 0, 0, 183296, 138240, 140288, 140288, 140288, 183296, 140288, 140288, 140288, 140288, 140288,
    140288, 0, 136192, 234496, 0, 0, 192512, 0, 203776, 0, 0, 0, 0, 0, 282, 0, 0, 0, 0, 0, 0, 284, 285, 0, 0, 282, 0, 0, 0, 0, 2121, 80, 0, 0, 80, 80, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 106, 106, 106, 106, 106, 106, 196, 0, 0, 291, 180, 106, 106, 296, 106, 106, 106, 106, 106, 106, 106, 106, 106, 721, 106, 125, 125, 125,
    125, 125, 12621, 291, 227, 125, 125, 338, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 563, 125, 125, 125, 125, 125, 125, 125, 365, 366, 125,
    125, 125, 125, 125, 125, 125, 125, 125, 0, 0, 0, 0, 2121, 80, 0, 0, 80, 80, 0, 0, 0, 0, 102, 0, 0, 0, 0, 2121, 0, 0, 0, 0, 0, 38997, 38997, 38997, 38997,
    38997, 38997, 38997, 38997, 38997, 38997, 38997, 0, 0, 0, 0, 0, 389, 390, 291, 391, 106, 106, 106, 106, 395, 106, 106, 106, 106, 106, 106, 106, 640, 125,
    125, 125, 125, 125, 125, 125, 125, 106, 106, 807, 808, 106, 106, 125, 125, 402, 106, 106, 106, 106, 106, 106, 408, 106, 106, 106, 106, 106, 106, 106, 106,
    666, 106, 106, 106, 106, 671, 106, 106, 125, 125, 125, 429, 125, 125, 125, 125, 125, 125, 125, 436, 125, 125, 125, 125, 125, 125, 125, 125, 680, 125, 125,
    125, 125, 685, 125, 125, 125, 442, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 135168, 125, 455, 456, 125, 125, 125, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 66, 0, 0, 0, 69, 0, 0, 0, 0, 468, 0, 0, 391, 106, 106, 106, 106, 106, 106, 106, 106, 106, 764, 125, 125, 125, 125, 125, 125, 125, 125,
    125, 125, 125, 125, 684, 125, 125, 125, 540, 106, 106, 106, 106, 106, 546, 106, 106, 106, 106, 106, 106, 106, 106, 106, 493, 106, 106, 106, 106, 125, 125,
    125, 125, 125, 125, 125, 125, 125, 125, 0, 754, 106, 106, 106, 554, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 562, 125, 125, 125, 125, 125, 125,
    253, 255, 125, 259, 125, 262, 125, 125, 0, 0, 125, 568, 125, 125, 125, 125, 125, 125, 125, 125, 125, 576, 0, 0, 0, 0, 0, 108544, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 14419, 0, 0, 134144, 0, 0, 0, 0, 0, 106, 106, 106, 585, 106, 106, 588, 106, 106, 106, 106, 106, 106, 544, 106, 106, 106, 548, 106, 106, 106, 106, 106,
    106, 106, 547, 106, 106, 106, 106, 106, 106, 106, 106, 312, 106, 106, 106, 106, 106, 106, 106, 0, 0, 0, 106, 106, 690, 106, 106, 106, 106, 106, 106, 106,
    106, 697, 106, 106, 106, 715, 106, 106, 106, 106, 106, 106, 106, 125, 125, 125, 725, 125, 125, 125, 125, 125, 557, 558, 125, 560, 125, 125, 125, 125, 125,
    565, 125, 125, 125, 125, 125, 572, 125, 125, 125, 125, 125, 0, 0, 0, 0, 0, 0, 157, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23552, 0, 0, 134144, 0, 0, 106, 125, 125,
    701, 125, 125, 125, 125, 125, 125, 125, 125, 708, 125, 125, 0, 0, 0, 0, 2121, 80, 0, 0, 80, 80, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 110, 129, 110,
    110, 110, 774, 106, 106, 106, 106, 106, 106, 106, 106, 106, 783, 125, 125, 125, 125, 125, 125, 125, 125, 805, 106, 106, 106, 106, 106, 811, 125, 125, 125,
    125, 125, 792, 0, 106, 106, 106, 106, 106, 106, 797, 798, 106, 125, 125, 125, 702, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 0, 125, 125, 125, 125,
    125, 803, 804, 125, 106, 106, 106, 106, 106, 106, 125, 125, 125, 125, 106, 106, 125, 125, 106, 125, 106, 125, 0, 0, 0, 0, 2121, 80, 0, 0, 80, 80, 98, 98,
    98, 98, 98, 98, 98, 98, 98, 98, 98, 123, 142, 123, 123, 123, 123, 123, 123, 123, 142, 142, 142, 142, 142, 142, 142, 0, 0, 0, 0, 0, 21504, 0, 0, 0, 0, 0, 0,
    0, 0, 69, 0, 125, 125, 243, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 0, 0, 0, 0, 79, 79, 79, 79, 79, 79, 79, 0, 0, 134144, 0, 0, 0, 0, 0,
    183296, 138240, 140467, 140467, 140467, 183475, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 140467, 0, 0,
    140514, 179426, 0, 0, 291, 391, 106, 106, 106, 106, 106, 106, 106, 106, 106, 399, 106, 106, 106, 481, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,
    106, 550, 106, 106, 106, 106, 106, 106, 106, 416, 106, 106, 106, 106, 106, 106, 106, 106, 106, 12621, 391, 125, 125, 125, 125, 125, 432, 125, 125, 125, 125,
    125, 125, 125, 125, 125, 440, 0, 0, 0, 106, 583, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 636, 638, 106, 125, 125, 642, 125, 125, 125, 125,
    645, 125, 0, 0, 0, 106, 106, 106, 106, 692, 106, 106, 106, 106, 106, 106, 106, 106, 665, 106, 106, 106, 106, 668, 106, 106, 106, 106, 106, 125, 125, 125,
    125, 106, 106, 125, 125, 106, 125, 833, 834, 125, 125, 125, 791, 125, 0, 106, 106, 106, 106, 106, 106, 106, 106, 106, 125, 125, 125, 125, 501, 125, 125,
    125, 240, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 0, 0, 0, 0, 144, 144, 144, 144, 144, 144, 144, 0, 0, 62, 0, 0, 0, 0, 69, 69, 0, 0, 0,
    0, 276, 0, 0, 0, 0, 0, 0, 391, 106, 106, 106, 106, 106, 106, 106, 477, 106, 0, 0, 291, 180, 106, 106, 106, 106, 106, 106, 106, 301, 106, 106, 106, 106, 716,
    106, 718, 106, 106, 106, 106, 125, 125, 125, 125, 726, 12621, 291, 227, 125, 125, 125, 125, 125, 125, 125, 343, 125, 125, 125, 125, 125, 125, 125, 354, 125,
    125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 263, 125, 125, 0, 0, 441, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 453,
    106, 541, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 553, 106, 106, 106, 761, 106, 763, 125, 125, 125, 125, 125, 125, 125, 771, 125, 773,
    125, 241, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 0, 0, 0, 0, 149, 149, 149, 2121, 2121, 2121, 2121, 0, 0, 78, 79, 139264, 106, 479,
    480, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 488, 489, 106, 125, 125, 125, 506, 507, 125, 125, 125, 125, 125, 125, 125, 125, 125,
    125, 125, 125, 358, 125, 125, 125, 0, 0, 0, 108544, 108620, 0, 0, 0, 0, 0, 0, 0, 0, 108544, 0, 108544, 0, 0, 110592, 0, 0, 0, 0, 0, 0, 140288, 140288,
    140288, 140288, 140288, 140288, 140288, 140288, 196608, 140288, 140288, 140288, 140288, 0, 0, 0, 292, 140288, 140288, 140288, 140288, 140288, 140288,
    140288, 140288, 140288, 140288, 140288, 194560, 0, 0, 334, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 194560,
    140288, 140288, 140288, 140288, 230400, 231424, 140288, 233472, 140288, 140288, 140288, 0, 0, 0, 0, 0, 0, 0, 0, 0, 106, 106, 106, 185, 106, 106, 106, 0, 0,
    0, 0, 13312, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 106, 125, 106, 106, 106, 181248, 205824, 220160, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 194560, 0, 0, 0, 0, 2121,
    80, 0, 0, 80, 80, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 113, 132, 113, 113, 113
  "/>

  <!--~
   ! The DFA-state to expected-token-set mapping.
  -->
  <xsl:variable name="p:EXPECTED" as="xs:integer+" select="
    209, 213, 217, 221, 463, 225, 382, 555, 237, 460, 226, 231, 257, 257, 236, 241, 247, 251, 231, 257, 232, 241, 241, 285, 553, 257, 347, 241, 243, 345, 257,
    241, 243, 256, 347, 242, 345, 260, 264, 258, 241, 256, 349, 259, 268, 278, 299, 282, 293, 297, 298, 271, 274, 694, 303, 307, 487, 457, 355, 311, 316, 565,
    322, 470, 327, 226, 633, 333, 226, 339, 481, 353, 226, 359, 334, 252, 363, 389, 312, 484, 546, 289, 367, 539, 546, 376, 323, 380, 386, 408, 395, 400, 406,
    590, 562, 588, 412, 419, 426, 430, 415, 433, 437, 687, 226, 441, 446, 450, 454, 287, 467, 532, 474, 478, 493, 497, 318, 503, 226, 329, 507, 442, 511, 402,
    517, 226, 704, 523, 529, 396, 536, 649, 543, 550, 499, 545, 575, 559, 575, 650, 519, 581, 569, 573, 579, 585, 594, 598, 614, 602, 611, 607, 618, 605, 622,
    626, 630, 513, 637, 641, 644, 226, 372, 648, 654, 422, 226, 525, 226, 226, 342, 226, 226, 660, 656, 226, 226, 664, 226, 489, 670, 226, 227, 674, 226, 680,
    226, 666, 226, 684, 226, 691, 676, 226, 371, 701, 369, 391, 335, 369, 370, 698, 226, 226, 226, 226, 226, 226, 226, 708, 725, 712, 714, 718, 722, 729, 731,
    735, 742, 738, 746, 750, 754, 758, 762, 1284, 799, 799, 799, 799, 805, 1084, 826, 826, 826, 819, 812, 821, 821, 821, 815, 821, 821, 821, 821, 822, 799, 821,
    821, 821, 1037, 1262, 799, 799, 799, 951, 1083, 826, 826, 826, 826, 1034, 821, 821, 821, 821, 1182, 1032, 821, 823, 826, 826, 821, 1035, 1179, 799, 799,
    831, 1036, 821, 822, 826, 825, 826, 1034, 821, 791, 799, 799, 802, 799, 964, 968, 821, 824, 826, 1034, 821, 821, 826, 1035, 821, 821, 846, 850, 852, 856,
    859, 859, 863, 867, 892, 799, 799, 799, 959, 768, 893, 799, 799, 834, 1098, 897, 799, 799, 799, 994, 919, 1155, 799, 799, 835, 1121, 920, 803, 799, 799,
    799, 1082, 799, 1168, 924, 799, 807, 1099, 799, 825, 826, 826, 1036, 821, 821, 822, 941, 945, 799, 799, 883, 767, 990, 915, 888, 943, 803, 799, 957, 915,
    974, 803, 799, 799, 1080, 799, 799, 799, 1234, 802, 979, 996, 985, 970, 987, 799, 799, 1176, 826, 1167, 799, 981, 970, 944, 799, 799, 1079, 799, 1000, 799,
    799, 799, 1145, 980, 932, 799, 799, 1183, 1131, 989, 931, 935, 799, 989, 996, 933, 799, 1242, 1246, 799, 1243, 935, 799, 1244, 935, 799, 833, 1251, 1025,
    1245, 799, 1243, 934, 799, 1244, 935, 1242, 1017, 799, 1023, 1243, 799, 1023, 1243, 1229, 799, 799, 800, 799, 1041, 1044, 1044, 1044, 1045, 1049, 1049,
    1049, 1050, 799, 1230, 799, 842, 879, 799, 795, 798, 799, 772, 776, 785, 1054, 1058, 904, 799, 908, 914, 887, 1078, 799, 937, 1069, 1074, 799, 1230, 799,
    908, 928, 886, 942, 1155, 799, 832, 799, 799, 804, 779, 801, 799, 1088, 1094, 1058, 1226, 799, 799, 1185, 1189, 1124, 1107, 1112, 1117, 1125, 1108, 1113,
    1194, 1090, 1061, 799, 799, 1201, 1103, 1135, 1139, 1192, 1196, 900, 799, 1141, 1194, 799, 799, 1255, 799, 801, 1257, 1061, 799, 936, 1068, 1073, 1149,
    1191, 1195, 799, 960, 969, 975, 1133, 1140, 1193, 799, 799, 799, 1167, 799, 1161, 1061, 799, 1003, 826, 826, 827, 789, 799, 1161, 902, 799, 1007, 934, 799,
    832, 799, 1169, 799, 1183, 1187, 875, 1287, 903, 799, 1186, 1190, 1194, 874, 1155, 799, 1185, 873, 1195, 873, 1154, 1288, 799, 1013, 799, 1242, 1009, 799,
    872, 1153, 799, 870, 874, 946, 799, 1266, 1263, 1267, 803, 1265, 1159, 1264, 1268, 803, 1265, 1269, 799, 1266, 1155, 1263, 1267, 947, 1159, 1263, 1267, 765,
    1203, 1165, 1205, 1203, 1165, 1205, 1204, 1204, 953, 1173, 1173, 799, 1019, 915, 888, 903, 1237, 1209, 1215, 1213, 1216, 1220, 1220, 1223, 799, 1025, 1241,
    799, 799, 799, 1184, 1188, 799, 1250, 799, 799, 1273, 799, 804, 808, 1100, 1261, 806, 781, 799, 799, 1277, 799, 1101, 1262, 799, 1273, 780, 1102, 799, 799,
    1281, 799, 807, 1100, 799, 1273, 1197, 1100, 799, 799, 1024, 1024, 1029, 1197, 1082, 799, 799, 1064, 839, 910, 1081, 799, 799, 799, 1082, 799, 799, 1129,
    1133, 1137, 262660, 295424, 328192, 393728, -2147220992, 262656, 262656, 262656, 537134080, 426496, 852480, 4981248, 786944, 262656, 266754, 787104,
    4981248, 786944, 1311232, 4456960, 1074004480, 1442436, 6161028, 284967424, 284967424, 284967424, 285098496, 284967424, 284967424, 486302208, 486433280,
    486531584, 1560207872, 262976, 1560044032, 486302208, 486466048, 1560175104, 265024, 394048, 1311552, 459584, 918336, 1442624, 1835840, 1966912, 50793340,
    252119932, 262605692, 263129980, 262605692, 262605692, 334457724, 512, 262144, 4, 1073741824, -2147483648, -2147483648, 0, 0, 0, 192512, 3932160, 1024,
    263168, 536871936, 514, 2, 262146, 2, 2, 4, 8, 64, 128, 256, 2, 32, 32, 128, 2304, 2368, 2304, 2304, 16, 16, 1024, 1024, 1024, 32, 0, 0, 0, 0, -2147483648,
    0, 0, 0, 1, 2, 4, 8, 32, 2048, 2304, 2112, 2304, 2304, 33554456, 28, 2048, 2112, 2304, 2304, 2304, 2304, 0, 256, 256, 256, 256, 2048, 0, 65536, 0, 0, 0, 7,
    8, 16, 0, 0, 65536, 67108864, 0, 0, 6, -1459599121, -1459598865, -1459074833, -1459598865, -1459074577, -1458812673, -1458811649, -1458811649, -1458811649,
    -1458811649, -1458811393, -1458811649, -1458811649, -69632, -69632, -69632, -69632, -67840, -67840, -67840, -67840, -65792, -67840, -65537, 0, 0, 3, 1024,
    786432, 100663296, 134217728, 536870912, -1073741824, 192, 16384, 16777216, -1476395008, 0, 524288, 16, 786432, 1048576, 2097152, 12582912, 16777216,
    33554432, 3932160, 62914560, -67108864, 0, 0, 16777216, 134217728, 536870912, -2147483648, 1024, 536870912, 512, 0, 0, 0, 3648, 524288, 786432, 0, 0,
    -1459599121, -1459599121, 28672, 32768, 131072, 786432, 1048576, 33554432, 201326592, 268435456, 536870912, 1073741824, 16384, 16777216, 134217728,
    -2147483648, 12288, 16384, 32768, 131072, 524288, 12582912, 33554432, 268435456, 0, 0, 0, 15, 48, 16777216, 33554432, 67108864, 134217728, 268435456,
    1073741824, -2147483648, 0, -2147483648, 0, 0, 67108864, 0, 134217728, 0, 134217728, 524288, 786432, 0, 12288, 32768, 131072, 524288, 524288, 12288, 32768,
    131072, 524288, 1048576, 2097152, 12582912, 33554432, 67108864, 33554432, 67108864, 268435456, 1073741824, -2147483648, 0, 0, 524288, 12288, 131072, 524288,
    33554432, 67108864, 268435456, -2147483648, 0, 0, 0, 12288, 16384, 0, 12288, 131072, 524288, 2097152, 12582912, 33554432, 67108864, 268435456, 0, 0, 64,
    256, 0, 8192, 131072, 12582912, 33554432, 268435456, 8192, 12582912, 33554432, 268435456, 8388608, 268435456, 0, 0, 0, 28672, 8192, 8388608, 0, 0, 0, 16,
    8388608, 0, 8388608, 0, 0, 256, 256, 256, 2304, 2304, 2304, 24, 0, 0, 814918768, 814919280, 814919280, 814919280, 814919280, -4194561, -4194561, -4194561,
    -4194561, -4194561, 0, 48, 3136, 40960, 131072, 1048576, 8388608, 268435456, 536870912, 0, 512, 0, 0, 256, 65536, 48, 7872, 57344, 196608, 3932160, 3932160,
    8388608, 251658240, 268435456, -536870912, -536870912, 0, 0, 0, 128, 0, 0, 0, 256, 64, 16, 32, 64, 1024, 131072, 268435456, 2048, 8192, 32768, 131072, 16,
    32, 64, 128, 256, 0, 0, 0, 512, 32768, 65536, 131072, 786432, 1048576, 1048576, 2097152, 8388608, 16777216, 234881024, 234881024, 268435456, 536870912,
    -1073741824, 32, 64, 128, 1536, 2048, 4096, 24576, 32768, 0, 3, 4, 8, 64, 512, 1024, 4096, 16384, 65536, 131072, 786432, 2097152, 16777216, 100663296,
    134217728, 3, 8, 64, 512, 1024, 4096, 786432, 2097152, 134217728, 536870912, 1073741824, -2147483648, 0, 0, 134217728, 1073741824, -2147483648, 0, 1024,
    268435456, 134217728, 1073741824, 0, 0, 0, 67108864, 0, 16384, 134217728, 134217728, 134217728, 134217728, 256, 320, 256, 2304, 256, 2304, 0, 0, 0, 3, 8,
    512, 1024, 786432, 16777216, 100663296, 134217728, 268435456, 536870912, -1073741824, 0, 0, 0, 4, 16, 512, 0, 0, 2, 67108864, 134217728, 1073741824, 7520,
    7968, 7520, 7968, 7520, 8032, 7520, 7520, 7520, 7520, 495, 495, 495, 495, 495, 4591, 7663, 0, 0, 1536, 0, 0, 256, 4194304, 0, 32, 256, 2048, 0, 0, 7456,
    7456, 96, 0, 0, 0, 8192, 8388608, 33554432, 268435456, 0, 7, 232, 256, 0, 0, 32, 256, 0, 64, 1024, 268435456, 0, 16, 0, 0, 0, 2, 524288, 67108864,
    134217728, 1073741824, -2147483648, -2147483648, 0, 256, 0, 64, 4, 64, 128, 256, 0, 4, 128, 0, 0, 16384, 0, -2147483648, 1024, 536870912, 0
  "/>

  <!--~
   ! The token-string table.
  -->
  <xsl:variable name="p:TOKEN" as="xs:string+" select="
    '(0)',
    'AVTFixChar',
    'IntegerLiteral',
    'DecimalLiteral',
    'DoubleLiteral',
    'StringLiteral',
    'URIQualifiedName',
    'NCName',
    'QName',
    'S',
    'CommentContents',
    'Wildcard',
    'EOF',
    &quot;'!'&quot;,
    &quot;'!='&quot;,
    &quot;'#'&quot;,
    &quot;'$'&quot;,
    &quot;'('&quot;,
    &quot;'(:'&quot;,
    &quot;')'&quot;,
    &quot;'*'&quot;,
    &quot;'+'&quot;,
    &quot;','&quot;,
    &quot;'-'&quot;,
    &quot;'.'&quot;,
    &quot;'..'&quot;,
    &quot;'/'&quot;,
    &quot;'//'&quot;,
    &quot;':'&quot;,
    &quot;':)'&quot;,
    &quot;'::'&quot;,
    &quot;':='&quot;,
    &quot;'&lt;'&quot;,
    &quot;'&lt;&lt;'&quot;,
    &quot;'&lt;='&quot;,
    &quot;'='&quot;,
    &quot;'=&gt;'&quot;,
    &quot;'&gt;'&quot;,
    &quot;'&gt;='&quot;,
    &quot;'&gt;&gt;'&quot;,
    &quot;'?'&quot;,
    &quot;'@'&quot;,
    &quot;'['&quot;,
    &quot;']'&quot;,
    &quot;'ancestor'&quot;,
    &quot;'ancestor-or-self'&quot;,
    &quot;'and'&quot;,
    &quot;'array'&quot;,
    &quot;'as'&quot;,
    &quot;'attribute'&quot;,
    &quot;'cast'&quot;,
    &quot;'castable'&quot;,
    &quot;'child'&quot;,
    &quot;'comment'&quot;,
    &quot;'descendant'&quot;,
    &quot;'descendant-or-self'&quot;,
    &quot;'div'&quot;,
    &quot;'document-node'&quot;,
    &quot;'element'&quot;,
    &quot;'else'&quot;,
    &quot;'empty-sequence'&quot;,
    &quot;'eq'&quot;,
    &quot;'every'&quot;,
    &quot;'except'&quot;,
    &quot;'following'&quot;,
    &quot;'following-sibling'&quot;,
    &quot;'for'&quot;,
    &quot;'function'&quot;,
    &quot;'ge'&quot;,
    &quot;'gt'&quot;,
    &quot;'idiv'&quot;,
    &quot;'if'&quot;,
    &quot;'in'&quot;,
    &quot;'instance'&quot;,
    &quot;'intersect'&quot;,
    &quot;'is'&quot;,
    &quot;'item'&quot;,
    &quot;'le'&quot;,
    &quot;'let'&quot;,
    &quot;'lt'&quot;,
    &quot;'map'&quot;,
    &quot;'mod'&quot;,
    &quot;'namespace'&quot;,
    &quot;'namespace-node'&quot;,
    &quot;'ne'&quot;,
    &quot;'node'&quot;,
    &quot;'of'&quot;,
    &quot;'or'&quot;,
    &quot;'parent'&quot;,
    &quot;'preceding'&quot;,
    &quot;'preceding-sibling'&quot;,
    &quot;'processing-instruction'&quot;,
    &quot;'return'&quot;,
    &quot;'satisfies'&quot;,
    &quot;'schema-attribute'&quot;,
    &quot;'schema-element'&quot;,
    &quot;'self'&quot;,
    &quot;'some'&quot;,
    &quot;'switch'&quot;,
    &quot;'text'&quot;,
    &quot;'then'&quot;,
    &quot;'to'&quot;,
    &quot;'treat'&quot;,
    &quot;'typeswitch'&quot;,
    &quot;'union'&quot;,
    &quot;'{'&quot;,
    &quot;'|'&quot;,
    &quot;'||'&quot;,
    &quot;'}'&quot;
  "/>

  <!--~
   ! Match next token in input string, starting at given index, using
   ! the DFA entry state for the set of tokens that are expected in
   ! the current context.
   !
   ! @param $input the input string.
   ! @param $begin the index where to start in input string.
   ! @param $token-set the expected token set id.
   ! @return a sequence of three: the token code of the result token,
   ! with input string begin and end positions. If there is no valid
   ! token, return the negative id of the DFA state that failed, along
   ! with begin and end positions of the longest viable prefix.
  -->
  <xsl:function name="p:match" as="xs:integer+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="token-set" as="xs:integer"/>

    <xsl:variable name="result" select="$p:INITIAL[1 + $token-set]"/>
    <xsl:sequence select="p:transition($input, $begin, $begin, $begin, $result, $result mod 1024, 0)"/>
  </xsl:function>

  <!--~
   ! The DFA state transition function. If we are in a valid DFA state, save
   ! it's result annotation, consume one input codepoint, calculate the next
   ! state, and use tail recursion to do the same again. Otherwise, return
   ! any valid result or a negative DFA state id in case of an error.
   !
   ! @param $input the input string.
   ! @param $begin the begin index of the current token in the input string.
   ! @param $current the index of the current position in the input string.
   ! @param $end the end index of the result in the input string.
   ! @param $result the result code.
   ! @param $current-state the current DFA state.
   ! @param $previous-state the  previous DFA state.
   ! @return a sequence of three: the token code of the result token,
   ! with input string begin and end positions. If there is no valid
   ! token, return the negative id of the DFA state that failed, along
   ! with begin and end positions of the longest viable prefix.
  -->
  <xsl:function name="p:transition">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="current" as="xs:integer"/>
    <xsl:param name="end" as="xs:integer"/>
    <xsl:param name="result" as="xs:integer"/>
    <xsl:param name="current-state" as="xs:integer"/>
    <xsl:param name="previous-state" as="xs:integer"/>

    <xsl:choose>
      <xsl:when test="$current-state eq 0">
        <xsl:variable name="result" select="$result idiv 1024"/>
        <xsl:variable name="end" select="$end - $result idiv 128"/>
        <xsl:variable name="end" select="if ($end gt string-length($input)) then string-length($input) + 1 else $end"/>
        <xsl:sequence select="
          if ($result ne 0) then
          (
            $result mod 128 - 1,
            $begin,
            $end
          )
          else
          (
            - $previous-state,
            $begin,
            $current - 1
          )
        "/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="c0" select="(string-to-codepoints(substring($input, $current, 1)), 0)[1]"/>
        <xsl:variable name="c1" as="xs:integer">
          <xsl:choose>
            <xsl:when test="$c0 &lt; 128">
              <xsl:sequence select="$p:MAP0[1 + $c0]"/>
            </xsl:when>
            <xsl:when test="$c0 &lt; 55296">
              <xsl:variable name="c1" select="$c0 idiv 16"/>
              <xsl:variable name="c2" select="$c1 idiv 32"/>
              <xsl:sequence select="$p:MAP1[1 + $c0 mod 16 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:sequence select="p:map2($c0, 1, 6)"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:variable name="current" select="$current + 1"/>
        <xsl:variable name="i0" select="1024 * $c1 + $current-state - 1"/>
        <xsl:variable name="i1" select="$i0 idiv 16"/>
        <xsl:variable name="next-state" select="$p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]"/>
        <xsl:sequence select="
          if ($next-state &gt; 1023) then
            p:transition($input, $begin, $current, $current, $next-state, $next-state mod 1024, $current-state)
          else
            p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Recursively translate one 32-bit chunk of an expected token bitset
   ! to the corresponding sequence of token strings.
   !
   ! @param $result the result of previous recursion levels.
   ! @param $chunk the 32-bit chunk of the expected token bitset.
   ! @param $base-token-code the token code of bit 0 in the current chunk.
   ! @return the set of token strings.
  -->
  <xsl:function name="p:token">
    <xsl:param name="result" as="xs:string*"/>
    <xsl:param name="chunk" as="xs:integer"/>
    <xsl:param name="base-token-code" as="xs:integer"/>

    <xsl:sequence select="
      if ($chunk = 0) then
        $result
      else
        p:token
        (
          ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
          if ($chunk &lt; 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
          $base-token-code + 1
        )
    "/>
  </xsl:function>

  <!--~
   ! Calculate expected token set for a given DFA state as a sequence
   ! of strings.
   !
   ! @param $state the DFA state.
   ! @return the set of token strings
  -->
  <xsl:function name="p:expected-token-set" as="xs:string*">
    <xsl:param name="state" as="xs:integer"/>

    <xsl:if test="$state > 0">
      <xsl:for-each select="0 to 3">
        <xsl:variable name="i0" select=". * 836 + $state - 1"/>
        <xsl:variable name="i1" select="$i0 idiv 4"/>
        <xsl:variable name="i2" select="$i1 idiv 4"/>
        <xsl:sequence select="p:token((), $p:EXPECTED[$i0 mod 4 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 + 1] + 1] + 1], . * 32 + 1)"/>
      </xsl:for-each>
    </xsl:if>
  </xsl:function>

  <!--~
   ! Classify codepoint by doing a tail recursive binary search for a
   ! matching codepoint range entry in MAP2, the codepoint to charclass
   ! map for codepoints above the surrogate block.
   !
   ! @param $c the codepoint.
   ! @param $lo the binary search lower bound map index.
   ! @param $hi the binary search upper bound map index.
   ! @return the character class.
  -->
  <xsl:function name="p:map2" as="xs:integer">
    <xsl:param name="c" as="xs:integer"/>
    <xsl:param name="lo" as="xs:integer"/>
    <xsl:param name="hi" as="xs:integer"/>

    <xsl:variable name="m" select="($hi + $lo) idiv 2"/>
    <xsl:choose>
      <xsl:when test="$lo &gt; $hi">
        <xsl:sequence select="0"/>
      </xsl:when>
      <xsl:when test="$p:MAP2[$m] &gt; $c">
        <xsl:sequence select="p:map2($c, $lo, $m - 1)"/>
      </xsl:when>
      <xsl:when test="$p:MAP2[6 + $m] &lt; $c">
        <xsl:sequence select="p:map2($c, $m + 1, $hi)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="$p:MAP2[12 + $m]"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Try parsing the 1st loop of production Comment (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:try-Comment-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1(14, $input, $state)"/>      <!-- CommentContents | ('(' ':') | (':' ')') -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] = 29">                                      <!-- (':' ')') -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 10">                                <!-- CommentContents -->
                  <xsl:variable name="state" select="p:consumeT(10, $input, $state)"/> <!-- CommentContents -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="
                    if ($state[$p:error]) then
                      $state
                    else
                      p:try-Comment($input, $state)
                  "/>
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:sequence select="p:try-Comment-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Try parsing Comment.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:try-Comment" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="state" select="p:consumeT(18, $input, $state)"/>            <!-- ('(' ':') -->
    <xsl:variable name="state" select="p:try-Comment-1($input, $state)"/>
    <xsl:variable name="state" select="p:consumeT(29, $input, $state)"/>            <!-- (':' ')') -->
    <xsl:sequence select="$state"/>
  </xsl:function>

  <!--~
   ! Try parsing Whitespace.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:try-Whitespace" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 9">                                         <!-- S^WS -->
          <xsl:variable name="state" select="p:consumeT(9, $input, $state)"/>       <!-- S^WS -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:try-Comment($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:sequence select="$state"/>
  </xsl:function>

  <!--~
   ! Parse NodeComp.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NodeComp" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 75">                                        <!-- 'is' -->
          <xsl:variable name="state" select="p:consume(75, $input, $state)"/>       <!-- 'is' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 33">                                        <!-- '<<' -->
          <xsl:variable name="state" select="p:consume(33, $input, $state)"/>       <!-- '<<' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(39, $input, $state)"/>       <!-- '>>' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NodeComp', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse GeneralComp.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-GeneralComp" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 35">                                        <!-- '=' -->
          <xsl:variable name="state" select="p:consume(35, $input, $state)"/>       <!-- '=' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 14">                                        <!-- '!=' -->
          <xsl:variable name="state" select="p:consume(14, $input, $state)"/>       <!-- '!=' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 32">                                        <!-- '<' -->
          <xsl:variable name="state" select="p:consume(32, $input, $state)"/>       <!-- '<' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 34">                                        <!-- '<=' -->
          <xsl:variable name="state" select="p:consume(34, $input, $state)"/>       <!-- '<=' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 37">                                        <!-- '>' -->
          <xsl:variable name="state" select="p:consume(37, $input, $state)"/>       <!-- '>' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(38, $input, $state)"/>       <!-- '>=' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'GeneralComp', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ValueComp.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ValueComp" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 61">                                        <!-- 'eq' -->
          <xsl:variable name="state" select="p:consume(61, $input, $state)"/>       <!-- 'eq' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 84">                                        <!-- 'ne' -->
          <xsl:variable name="state" select="p:consume(84, $input, $state)"/>       <!-- 'ne' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 79">                                        <!-- 'lt' -->
          <xsl:variable name="state" select="p:consume(79, $input, $state)"/>       <!-- 'lt' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 77">                                        <!-- 'le' -->
          <xsl:variable name="state" select="p:consume(77, $input, $state)"/>       <!-- 'le' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 69">                                        <!-- 'gt' -->
          <xsl:variable name="state" select="p:consume(69, $input, $state)"/>       <!-- 'gt' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(68, $input, $state)"/>       <!-- 'ge' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ValueComp', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SimpleTypeName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleTypeName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-TypeName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SimpleTypeName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SingleType.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SingleType" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SimpleTypeName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(32, $input, $state)"/>         <!-- S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' | '<' |
                                                                                         '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' | ']' | 'and' |
                                                                                         'castable' | 'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                                                         'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' |
                                                                                         'return' | 'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' |
                                                                                         '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 40">                                        <!-- '?' -->
          <xsl:variable name="state" select="p:consume(40, $input, $state)"/>       <!-- '?' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SingleType', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ArrowFunctionSpecifier.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArrowFunctionSpecifier" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 16">                                        <!-- '$' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-VarRef($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 17">                                        <!-- '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ParenthesizedExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-EQName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ArrowFunctionSpecifier', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production PredicateList (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PredicateList-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(34, $input, $state)"/>     <!-- S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' |
                                                                                         '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                                                         ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' | 'eq' | 'except' |
                                                                                         'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'lt' |
                                                                                         'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' | 'treat' |
                                                                                         'union' | '|' | '||' | '}' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 42">                                     <!-- '[' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-Predicate($input, $state)
            "/>
            <xsl:sequence select="p:parse-PredicateList-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse PredicateList.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PredicateList" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:parse-PredicateList-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PredicateList', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AbbrevForwardStep.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AbbrevForwardStep" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 41">                                        <!-- '@' -->
          <xsl:variable name="state" select="p:consume(41, $input, $state)"/>       <!-- '@' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | Wildcard | ('(' ':') |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-NodeTest($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AbbrevForwardStep', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ForwardAxis.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ForwardAxis" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 52">                                        <!-- 'child' -->
          <xsl:variable name="state" select="p:consume(52, $input, $state)"/>       <!-- 'child' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 54">                                        <!-- 'descendant' -->
          <xsl:variable name="state" select="p:consume(54, $input, $state)"/>       <!-- 'descendant' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 49">                                        <!-- 'attribute' -->
          <xsl:variable name="state" select="p:consume(49, $input, $state)"/>       <!-- 'attribute' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 96">                                        <!-- 'self' -->
          <xsl:variable name="state" select="p:consume(96, $input, $state)"/>       <!-- 'self' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 55">                                        <!-- 'descendant-or-self' -->
          <xsl:variable name="state" select="p:consume(55, $input, $state)"/>       <!-- 'descendant-or-self' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 65">                                        <!-- 'following-sibling' -->
          <xsl:variable name="state" select="p:consume(65, $input, $state)"/>       <!-- 'following-sibling' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 64">                                        <!-- 'following' -->
          <xsl:variable name="state" select="p:consume(64, $input, $state)"/>       <!-- 'following' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(82, $input, $state)"/>       <!-- 'namespace' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ForwardAxis', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ForwardStep.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ForwardStep" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 49">                                       <!-- 'attribute' -->
          <xsl:variable name="state" select="p:lookahead2W(39, $input, $state)"/>   <!-- S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         '/' | '//' | ':' | '::' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' |
                                                                                         '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                                                         'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                                                         'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = (52,                                          (: 'child' :)
                                         54,                                          (: 'descendant' :)
                                         55,                                          (: 'descendant-or-self' :)
                                         64,                                          (: 'following' :)
                                         65,                                          (: 'following-sibling' :)
                                         82,                                          (: 'namespace' :)
                                         96)">                                      <!-- 'self' -->
          <xsl:variable name="state" select="p:lookahead2W(36, $input, $state)"/>   <!-- S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' |
                                                                                         '//' | ':' | '::' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' |
                                                                                         '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                                                         'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                                                         'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 3889                                          (: 'attribute' '::' :)
                     or $state[$p:lk] = 3892                                          (: 'child' '::' :)
                     or $state[$p:lk] = 3894                                          (: 'descendant' '::' :)
                     or $state[$p:lk] = 3895                                          (: 'descendant-or-self' '::' :)
                     or $state[$p:lk] = 3904                                          (: 'following' '::' :)
                     or $state[$p:lk] = 3905                                          (: 'following-sibling' '::' :)
                     or $state[$p:lk] = 3922                                          (: 'namespace' '::' :)
                     or $state[$p:lk] = 3936">                                      <!-- 'self' '::' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ForwardAxis($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | Wildcard | ('(' ':') |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NodeTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AbbrevForwardStep($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ForwardStep', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AbbrevReverseStep.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AbbrevReverseStep" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(25, $input, $state)"/>             <!-- '..' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AbbrevReverseStep', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse NameTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NameTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 11">                                        <!-- Wildcard -->
          <xsl:variable name="state" select="p:consume(11, $input, $state)"/>       <!-- Wildcard -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-EQName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NameTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse NodeTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NodeTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] = (49,                                          (: 'attribute' :)
                                         53,                                          (: 'comment' :)
                                         57,                                          (: 'document-node' :)
                                         58,                                          (: 'element' :)
                                         83,                                          (: 'namespace-node' :)
                                         85,                                          (: 'node' :)
                                         91,                                          (: 'processing-instruction' :)
                                         94,                                          (: 'schema-attribute' :)
                                         95,                                          (: 'schema-element' :)
                                         99)">                                      <!-- 'text' -->
          <xsl:variable name="state" select="p:lookahead2W(35, $input, $state)"/>   <!-- S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                                                         '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' | 'eq' |
                                                                                         'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                                                         'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' |
                                                                                         'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2225                                          (: 'attribute' '(' :)
                     or $state[$p:lk] = 2229                                          (: 'comment' '(' :)
                     or $state[$p:lk] = 2233                                          (: 'document-node' '(' :)
                     or $state[$p:lk] = 2234                                          (: 'element' '(' :)
                     or $state[$p:lk] = 2259                                          (: 'namespace-node' '(' :)
                     or $state[$p:lk] = 2261                                          (: 'node' '(' :)
                     or $state[$p:lk] = 2267                                          (: 'processing-instruction' '(' :)
                     or $state[$p:lk] = 2270                                          (: 'schema-attribute' '(' :)
                     or $state[$p:lk] = 2271                                          (: 'schema-element' '(' :)
                     or $state[$p:lk] = 2275">                                      <!-- 'text' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-KindTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NameTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NodeTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ReverseAxis.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ReverseAxis" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 88">                                        <!-- 'parent' -->
          <xsl:variable name="state" select="p:consume(88, $input, $state)"/>       <!-- 'parent' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 44">                                        <!-- 'ancestor' -->
          <xsl:variable name="state" select="p:consume(44, $input, $state)"/>       <!-- 'ancestor' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 90">                                        <!-- 'preceding-sibling' -->
          <xsl:variable name="state" select="p:consume(90, $input, $state)"/>       <!-- 'preceding-sibling' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 89">                                        <!-- 'preceding' -->
          <xsl:variable name="state" select="p:consume(89, $input, $state)"/>       <!-- 'preceding' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(45, $input, $state)"/>       <!-- 'ancestor-or-self' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ReverseAxis', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ReverseStep.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ReverseStep" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 25">                                        <!-- '..' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AbbrevReverseStep($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ReverseAxis($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | Wildcard | ('(' ':') |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NodeTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ReverseStep', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AxisStep.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AxisStep" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] = (44,                                          (: 'ancestor' :)
                                         45,                                          (: 'ancestor-or-self' :)
                                         88,                                          (: 'parent' :)
                                         89,                                          (: 'preceding' :)
                                         90)">                                      <!-- 'preceding-sibling' -->
          <xsl:variable name="state" select="p:lookahead2W(36, $input, $state)"/>   <!-- S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' |
                                                                                         '//' | ':' | '::' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' |
                                                                                         '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                                                         'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                                                         'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 25                                            (: '..' :)
                     or $state[$p:lk] = 3884                                          (: 'ancestor' '::' :)
                     or $state[$p:lk] = 3885                                          (: 'ancestor-or-self' '::' :)
                     or $state[$p:lk] = 3928                                          (: 'parent' '::' :)
                     or $state[$p:lk] = 3929                                          (: 'preceding' '::' :)
                     or $state[$p:lk] = 3930">                                      <!-- 'preceding-sibling' '::' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ReverseStep($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ForwardStep($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(34, $input, $state)"/>         <!-- S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' |
                                                                                         '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                                                         ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' | 'eq' | 'except' |
                                                                                         'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'lt' |
                                                                                         'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' | 'treat' |
                                                                                         'union' | '|' | '||' | '}' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-PredicateList($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AxisStep', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Lookup.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Lookup" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(40, $input, $state)"/>             <!-- '?' -->
    <xsl:variable name="state" select="p:lookahead1W(24, $input, $state)"/>         <!-- IntegerLiteral | NCName | S^WS | '(' | ('(' ':') | '*' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-KeySpecifier($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Lookup', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Predicate.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Predicate" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(42, $input, $state)"/>             <!-- '[' -->
    <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-Expr($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(43, $input, $state)"/>             <!-- ']' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Predicate', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse KeySpecifier.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-KeySpecifier" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 7">                                         <!-- NCName -->
          <xsl:variable name="state" select="p:consume(7, $input, $state)"/>        <!-- NCName -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 2">                                         <!-- IntegerLiteral -->
          <xsl:variable name="state" select="p:consume(2, $input, $state)"/>        <!-- IntegerLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 17">                                        <!-- '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ParenthesizedExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(20, $input, $state)"/>       <!-- '*' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'KeySpecifier', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse UnaryLookup.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-UnaryLookup" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(40, $input, $state)"/>             <!-- '?' -->
    <xsl:variable name="state" select="p:lookahead1W(24, $input, $state)"/>         <!-- IntegerLiteral | NCName | S^WS | '(' | ('(' ':') | '*' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-KeySpecifier($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'UnaryLookup', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse CurlyArrayConstructor.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-CurlyArrayConstructor" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(47, $input, $state)"/>             <!-- 'array' -->
    <xsl:variable name="state" select="p:lookahead1W(13, $input, $state)"/>         <!-- S^WS | ('(' ':') | '{' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EnclosedExpr($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'CurlyArrayConstructor', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production SquareArrayConstructor (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SquareArrayConstructor-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ExprSingle($input, $state)
            "/>
            <xsl:sequence select="p:parse-SquareArrayConstructor-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse SquareArrayConstructor.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SquareArrayConstructor" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(42, $input, $state)"/>             <!-- '[' -->
    <xsl:variable name="state" select="p:lookahead1W(56, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         ']' | 'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 43">                                       <!-- ']' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ExprSingle($input, $state)
          "/>
          <xsl:variable name="state" select="p:parse-SquareArrayConstructor-1($input, $state)"/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(43, $input, $state)"/>             <!-- ']' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SquareArrayConstructor', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ArrayConstructor.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArrayConstructor" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 42">                                        <!-- '[' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SquareArrayConstructor($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-CurlyArrayConstructor($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ArrayConstructor', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse MapValueExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MapValueExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'MapValueExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse MapKeyExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MapKeyExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'MapKeyExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse MapConstructorEntry.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MapConstructorEntry" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-MapKeyExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(28, $input, $state)"/>             <!-- ':' -->
    <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-MapValueExpr($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'MapConstructorEntry', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production MapConstructor (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MapConstructor-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-MapConstructorEntry($input, $state)
            "/>
            <xsl:sequence select="p:parse-MapConstructor-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse MapConstructor.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MapConstructor" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(80, $input, $state)"/>             <!-- 'map' -->
    <xsl:variable name="state" select="p:lookahead1W(13, $input, $state)"/>         <!-- S^WS | ('(' ':') | '{' -->
    <xsl:variable name="state" select="p:consume(105, $input, $state)"/>            <!-- '{' -->
    <xsl:variable name="state" select="p:lookahead1W(57, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' | '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 108">                                      <!-- '}' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-MapConstructorEntry($input, $state)
          "/>
          <xsl:variable name="state" select="p:parse-MapConstructor-1($input, $state)"/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(108, $input, $state)"/>            <!-- '}' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'MapConstructor', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse EnclosedExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-EnclosedExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(105, $input, $state)"/>            <!-- '{' -->
    <xsl:variable name="state" select="p:lookahead1W(57, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' | '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 108">                                      <!-- '}' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-Expr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(108, $input, $state)"/>            <!-- '}' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'EnclosedExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FunctionBody.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionBody" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EnclosedExpr($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionBody', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse OccurrenceIndicator.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-OccurrenceIndicator" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 40">                                        <!-- '?' -->
          <xsl:variable name="state" select="p:consume(40, $input, $state)"/>       <!-- '?' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 20">                                        <!-- '*' -->
          <xsl:variable name="state" select="p:consume(20, $input, $state)"/>       <!-- '*' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(21, $input, $state)"/>       <!-- '+' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'OccurrenceIndicator', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ParenthesizedItemType.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ParenthesizedItemType" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(45, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ItemType($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ParenthesizedItemType', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TypedArrayTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TypedArrayTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(47, $input, $state)"/>             <!-- 'array' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(45, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SequenceType($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TypedArrayTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AnyArrayTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AnyArrayTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(47, $input, $state)"/>             <!-- 'array' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | ('(' ':') | '*' -->
    <xsl:variable name="state" select="p:consume(20, $input, $state)"/>             <!-- '*' -->
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AnyArrayTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ArrayTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArrayTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 47">                                       <!-- 'array' -->
          <xsl:variable name="state" select="p:lookahead2W(3, $input, $state)"/>    <!-- S^WS | '(' | ('(' ':') -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:lk] eq 2223">                               <!-- 'array' '(' -->
                <xsl:variable name="state" select="p:lookahead3W(49, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | '*' |
                                                                                             'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                             'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                             'descendant-or-self' | 'div' | 'document-node' | 'element' |
                                                                                             'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                             'following' | 'following-sibling' | 'for' | 'function' | 'ge' |
                                                                                             'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                             'le' | 'let' | 'lt' | 'map' | 'mod' | 'namespace' |
                                                                                             'namespace-node' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                             'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                             'satisfies' | 'schema-attribute' | 'schema-element' | 'self' |
                                                                                             'some' | 'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                                                             'union' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 329903">                                    <!-- 'array' '(' '*' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AnyArrayTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypedArrayTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ArrayTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AtomicOrUnionType.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AtomicOrUnionType" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EQName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AtomicOrUnionType', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TypedMapTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TypedMapTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(80, $input, $state)"/>             <!-- 'map' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AtomicOrUnionType($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(6, $input, $state)"/>          <!-- S^WS | ('(' ':') | ',' -->
    <xsl:variable name="state" select="p:consume(22, $input, $state)"/>             <!-- ',' -->
    <xsl:variable name="state" select="p:lookahead1W(45, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SequenceType($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TypedMapTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AnyMapTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AnyMapTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(80, $input, $state)"/>             <!-- 'map' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | ('(' ':') | '*' -->
    <xsl:variable name="state" select="p:consume(20, $input, $state)"/>             <!-- '*' -->
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AnyMapTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse MapTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MapTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 80">                                       <!-- 'map' -->
          <xsl:variable name="state" select="p:lookahead2W(3, $input, $state)"/>    <!-- S^WS | '(' | ('(' ':') -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:lk] eq 2256">                               <!-- 'map' '(' -->
                <xsl:variable name="state" select="p:lookahead3W(46, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | '*' |
                                                                                             'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                             'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                             'descendant-or-self' | 'div' | 'document-node' | 'element' |
                                                                                             'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                             'following' | 'following-sibling' | 'for' | 'function' | 'ge' |
                                                                                             'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                             'le' | 'let' | 'lt' | 'map' | 'mod' | 'namespace' |
                                                                                             'namespace-node' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                             'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                             'satisfies' | 'schema-attribute' | 'schema-element' | 'self' |
                                                                                             'some' | 'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                                                             'union' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 329936">                                    <!-- 'map' '(' '*' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AnyMapTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypedMapTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'MapTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production TypedFunctionTest (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TypedFunctionTest-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(17, $input, $state)"/>     <!-- S^WS | ('(' ':') | ')' | ',' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(45, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-SequenceType($input, $state)
            "/>
            <xsl:sequence select="p:parse-TypedFunctionTest-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse TypedFunctionTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TypedFunctionTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(67, $input, $state)"/>             <!-- 'function' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(48, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | ')' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 19">                                       <!-- ')' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SequenceType($input, $state)
          "/>
          <xsl:variable name="state" select="p:parse-TypedFunctionTest-1($input, $state)"/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>          <!-- S^WS | ('(' ':') | 'as' -->
    <xsl:variable name="state" select="p:consume(48, $input, $state)"/>             <!-- 'as' -->
    <xsl:variable name="state" select="p:lookahead1W(45, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SequenceType($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TypedFunctionTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AnyFunctionTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AnyFunctionTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(67, $input, $state)"/>             <!-- 'function' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | ('(' ':') | '*' -->
    <xsl:variable name="state" select="p:consume(20, $input, $state)"/>             <!-- '*' -->
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AnyFunctionTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FunctionTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 67">                                       <!-- 'function' -->
          <xsl:variable name="state" select="p:lookahead2W(3, $input, $state)"/>    <!-- S^WS | '(' | ('(' ':') -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:lk] eq 2243">                               <!-- 'function' '(' -->
                <xsl:variable name="state" select="p:lookahead3W(51, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | ')' |
                                                                                             '*' | 'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                                                             'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                                                             'descendant' | 'descendant-or-self' | 'div' | 'document-node' |
                                                                                             'element' | 'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                             'following' | 'following-sibling' | 'for' | 'function' | 'ge' |
                                                                                             'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                             'le' | 'let' | 'lt' | 'map' | 'mod' | 'namespace' |
                                                                                             'namespace-node' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                             'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                             'satisfies' | 'schema-attribute' | 'schema-element' | 'self' |
                                                                                             'some' | 'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                                                             'union' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 329923">                                    <!-- 'function' '(' '*' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AnyFunctionTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypedFunctionTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AnyKindTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AnyKindTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(85, $input, $state)"/>             <!-- 'node' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AnyKindTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse NamespaceNodeTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NamespaceNodeTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(83, $input, $state)"/>             <!-- 'namespace-node' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NamespaceNodeTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TextTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TextTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(99, $input, $state)"/>             <!-- 'text' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TextTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse CommentTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-CommentTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(53, $input, $state)"/>             <!-- 'comment' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'CommentTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse PITest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PITest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(91, $input, $state)"/>             <!-- 'processing-instruction' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(21, $input, $state)"/>         <!-- StringLiteral | NCName | S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 19">                                       <!-- ')' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 7">                                   <!-- NCName -->
                <xsl:variable name="state" select="p:consume(7, $input, $state)"/>  <!-- NCName -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="p:consume(5, $input, $state)"/>  <!-- StringLiteral -->
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PITest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AttributeDeclaration.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AttributeDeclaration" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AttributeName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AttributeDeclaration', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SchemaAttributeTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SchemaAttributeTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(94, $input, $state)"/>             <!-- 'schema-attribute' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AttributeDeclaration($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SchemaAttributeTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AttributeName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AttributeName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EQName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AttributeName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AttribNameOrWildcard.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AttribNameOrWildcard" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 20">                                        <!-- '*' -->
          <xsl:variable name="state" select="p:consume(20, $input, $state)"/>       <!-- '*' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AttributeName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AttribNameOrWildcard', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AttributeTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AttributeTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(49, $input, $state)"/>             <!-- 'attribute' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(50, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' | '*' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 19">                                       <!-- ')' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AttribNameOrWildcard($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(17, $input, $state)"/>   <!-- S^WS | ('(' ':') | ')' | ',' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 22">                                  <!-- ',' -->
                <xsl:variable name="state" select="p:consume(22, $input, $state)"/> <!-- ',' -->
                <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                             'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                             'castable' | 'child' | 'comment' | 'descendant' |
                                                                                             'descendant-or-self' | 'div' | 'document-node' | 'element' |
                                                                                             'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                             'following' | 'following-sibling' | 'for' | 'function' | 'ge' |
                                                                                             'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                             'le' | 'let' | 'lt' | 'map' | 'mod' | 'namespace' |
                                                                                             'namespace-node' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                             'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                             'satisfies' | 'schema-attribute' | 'schema-element' | 'self' |
                                                                                             'some' | 'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                                                             'union' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-TypeName($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AttributeTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ElementDeclaration.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ElementDeclaration" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ElementName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ElementDeclaration', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SchemaElementTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SchemaElementTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(95, $input, $state)"/>             <!-- 'schema-element' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ElementDeclaration($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SchemaElementTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TypeName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TypeName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EQName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TypeName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ElementName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ElementName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EQName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ElementName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ElementNameOrWildcard.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ElementNameOrWildcard" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 20">                                        <!-- '*' -->
          <xsl:variable name="state" select="p:consume(20, $input, $state)"/>       <!-- '*' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ElementName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ElementNameOrWildcard', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ElementTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ElementTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(58, $input, $state)"/>             <!-- 'element' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(50, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' | '*' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 19">                                       <!-- ')' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ElementNameOrWildcard($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(17, $input, $state)"/>   <!-- S^WS | ('(' ':') | ')' | ',' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 22">                                  <!-- ',' -->
                <xsl:variable name="state" select="p:consume(22, $input, $state)"/> <!-- ',' -->
                <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                             'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                             'castable' | 'child' | 'comment' | 'descendant' |
                                                                                             'descendant-or-self' | 'div' | 'document-node' | 'element' |
                                                                                             'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                             'following' | 'following-sibling' | 'for' | 'function' | 'ge' |
                                                                                             'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                             'le' | 'let' | 'lt' | 'map' | 'mod' | 'namespace' |
                                                                                             'namespace-node' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                             'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                             'satisfies' | 'schema-attribute' | 'schema-element' | 'self' |
                                                                                             'some' | 'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                                                             'union' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-TypeName($input, $state)
                "/>
                <xsl:variable name="state" select="p:lookahead1W(18, $input, $state)"/> <!-- S^WS | ('(' ':') | ')' | '?' -->
                <xsl:variable name="state" as="item()+">
                  <xsl:choose>
                    <xsl:when test="$state[$p:error]">
                      <xsl:sequence select="$state"/>
                    </xsl:when>
                    <xsl:when test="$state[$p:l1] = 40">                            <!-- '?' -->
                      <xsl:variable name="state" select="p:consume(40, $input, $state)"/> <!-- '?' -->
                      <xsl:sequence select="$state"/>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:sequence select="$state"/>
                    </xsl:otherwise>
                  </xsl:choose>
                </xsl:variable>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ElementTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse DocumentTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-DocumentTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(57, $input, $state)"/>             <!-- 'document-node' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(23, $input, $state)"/>         <!-- S^WS | ('(' ':') | ')' | 'element' | 'schema-element' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 19">                                       <!-- ')' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 58">                                  <!-- 'element' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-ElementTest($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-SchemaElementTest($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'DocumentTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse KindTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-KindTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 57">                                        <!-- 'document-node' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-DocumentTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 58">                                        <!-- 'element' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ElementTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 49">                                        <!-- 'attribute' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AttributeTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 95">                                        <!-- 'schema-element' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SchemaElementTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 94">                                        <!-- 'schema-attribute' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SchemaAttributeTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 91">                                        <!-- 'processing-instruction' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-PITest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 53">                                        <!-- 'comment' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-CommentTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 99">                                        <!-- 'text' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-TextTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 83">                                        <!-- 'namespace-node' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NamespaceNodeTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AnyKindTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'KindTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ItemType.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ItemType" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] = (47,                                          (: 'array' :)
                                         49,                                          (: 'attribute' :)
                                         53,                                          (: 'comment' :)
                                         57,                                          (: 'document-node' :)
                                         58,                                          (: 'element' :)
                                         67,                                          (: 'function' :)
                                         76,                                          (: 'item' :)
                                         80,                                          (: 'map' :)
                                         83,                                          (: 'namespace-node' :)
                                         85,                                          (: 'node' :)
                                         91,                                          (: 'processing-instruction' :)
                                         94,                                          (: 'schema-attribute' :)
                                         95,                                          (: 'schema-element' :)
                                         99)">                                      <!-- 'text' -->
          <xsl:variable name="state" select="p:lookahead2W(31, $input, $state)"/>   <!-- S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' |
                                                                                         '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' | ']' | 'and' |
                                                                                         'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'union' | '{' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2225                                          (: 'attribute' '(' :)
                     or $state[$p:lk] = 2229                                          (: 'comment' '(' :)
                     or $state[$p:lk] = 2233                                          (: 'document-node' '(' :)
                     or $state[$p:lk] = 2234                                          (: 'element' '(' :)
                     or $state[$p:lk] = 2259                                          (: 'namespace-node' '(' :)
                     or $state[$p:lk] = 2261                                          (: 'node' '(' :)
                     or $state[$p:lk] = 2267                                          (: 'processing-instruction' '(' :)
                     or $state[$p:lk] = 2270                                          (: 'schema-attribute' '(' :)
                     or $state[$p:lk] = 2271                                          (: 'schema-element' '(' :)
                     or $state[$p:lk] = 2275">                                      <!-- 'text' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-KindTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2252">                                      <!-- 'item' '(' -->
          <xsl:variable name="state" select="p:consume(76, $input, $state)"/>       <!-- 'item' -->
          <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>    <!-- S^WS | '(' | ('(' ':') -->
          <xsl:variable name="state" select="p:consume(17, $input, $state)"/>       <!-- '(' -->
          <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>    <!-- S^WS | ('(' ':') | ')' -->
          <xsl:variable name="state" select="p:consume(19, $input, $state)"/>       <!-- ')' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2243">                                      <!-- 'function' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-FunctionTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2256">                                      <!-- 'map' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-MapTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2223">                                      <!-- 'array' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ArrayTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 17">                                        <!-- '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ParenthesizedItemType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AtomicOrUnionType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ItemType', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SequenceType.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SequenceType" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 60">                                       <!-- 'empty-sequence' -->
          <xsl:variable name="state" select="p:lookahead2W(31, $input, $state)"/>   <!-- S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' |
                                                                                         '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' | ']' | 'and' |
                                                                                         'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'union' | '{' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2236">                                      <!-- 'empty-sequence' '(' -->
          <xsl:variable name="state" select="p:consume(60, $input, $state)"/>       <!-- 'empty-sequence' -->
          <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>    <!-- S^WS | '(' | ('(' ':') -->
          <xsl:variable name="state" select="p:consume(17, $input, $state)"/>       <!-- '(' -->
          <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>    <!-- S^WS | ('(' ':') | ')' -->
          <xsl:variable name="state" select="p:consume(19, $input, $state)"/>       <!-- ')' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ItemType($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(29, $input, $state)"/>   <!-- S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' | '<' |
                                                                                         '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' | ']' | 'and' | 'div' |
                                                                                         'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'union' | '{' | '|' | '||' | '}' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 20                                      (: '*' :)
                           or $state[$p:l1] = 21                                      (: '+' :)
                           or $state[$p:l1] = 40">                                  <!-- '?' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-OccurrenceIndicator($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SequenceType', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TypeDeclaration.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TypeDeclaration" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(48, $input, $state)"/>             <!-- 'as' -->
    <xsl:variable name="state" select="p:lookahead1W(45, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SequenceType($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TypeDeclaration', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Param.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Param" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '$' -->
    <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EQName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(22, $input, $state)"/>         <!-- S^WS | ('(' ':') | ')' | ',' | 'as' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 48">                                        <!-- 'as' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeDeclaration($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Param', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production ParamList (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ParamList-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(17, $input, $state)"/>     <!-- S^WS | ('(' ':') | ')' | ',' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>  <!-- S^WS | '$' | ('(' ':') -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-Param($input, $state)
            "/>
            <xsl:sequence select="p:parse-ParamList-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse ParamList.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ParamList" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-Param($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-ParamList-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ParamList', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse InlineFunctionExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-InlineFunctionExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(67, $input, $state)"/>             <!-- 'function' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(16, $input, $state)"/>         <!-- S^WS | '$' | ('(' ':') | ')' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 16">                                        <!-- '$' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ParamList($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="state" select="p:lookahead1W(19, $input, $state)"/>         <!-- S^WS | ('(' ':') | 'as' | '{' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 48">                                        <!-- 'as' -->
          <xsl:variable name="state" select="p:consume(48, $input, $state)"/>       <!-- 'as' -->
          <xsl:variable name="state" select="p:lookahead1W(45, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SequenceType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(13, $input, $state)"/>         <!-- S^WS | ('(' ':') | '{' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-FunctionBody($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'InlineFunctionExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse NamedFunctionRef.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NamedFunctionRef" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-FunctionEQName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(1, $input, $state)"/>          <!-- S^WS | '#' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(15, $input, $state)"/>             <!-- '#' -->
    <xsl:variable name="state" select="p:lookahead1W(0, $input, $state)"/>          <!-- IntegerLiteral | S^WS | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(2, $input, $state)"/>              <!-- IntegerLiteral -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NamedFunctionRef', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FunctionItemExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionItemExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 67">                                        <!-- 'function' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-InlineFunctionExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NamedFunctionRef($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionItemExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ArgumentPlaceholder.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArgumentPlaceholder" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(40, $input, $state)"/>             <!-- '?' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ArgumentPlaceholder', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Argument.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Argument" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 40">                                       <!-- '?' -->
          <xsl:variable name="state" select="p:lookahead2W(25, $input, $state)"/>   <!-- IntegerLiteral | NCName | S^WS | '(' | ('(' ':') | ')' | '*' | ',' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2472                                          (: '?' ')' :)
                     or $state[$p:lk] = 2856">                                      <!-- '?' ',' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ArgumentPlaceholder($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ExprSingle($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Argument', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production ArgumentList (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArgumentList-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(17, $input, $state)"/>     <!-- S^WS | ('(' ':') | ')' | ',' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-Argument($input, $state)
            "/>
            <xsl:sequence select="p:parse-ArgumentList-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse ArgumentList.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArgumentList" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | ')' | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' |
                                                                                         '[' | 'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 19">                                       <!-- ')' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-Argument($input, $state)
          "/>
          <xsl:variable name="state" select="p:parse-ArgumentList-1($input, $state)"/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ArgumentList', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FunctionEQName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionEQName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 6">                                         <!-- URIQualifiedName -->
          <xsl:variable name="state" select="p:consume(6, $input, $state)"/>        <!-- URIQualifiedName -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-FunctionName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionEQName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FunctionCall.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionCall" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-FunctionEQName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ArgumentList($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionCall', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ContextItemExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ContextItemExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(24, $input, $state)"/>             <!-- '.' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ContextItemExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ParenthesizedExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ParenthesizedExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | ')' | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' |
                                                                                         '[' | 'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 19">                                       <!-- ')' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-Expr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ParenthesizedExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse VarRef.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-VarRef" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '$' -->
    <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-VarName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'VarRef', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse NumericLiteral.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NumericLiteral" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 2">                                         <!-- IntegerLiteral -->
          <xsl:variable name="state" select="p:consume(2, $input, $state)"/>        <!-- IntegerLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 3">                                         <!-- DecimalLiteral -->
          <xsl:variable name="state" select="p:consume(3, $input, $state)"/>        <!-- DecimalLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(4, $input, $state)"/>        <!-- DoubleLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NumericLiteral', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Literal.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Literal" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 5">                                         <!-- StringLiteral -->
          <xsl:variable name="state" select="p:consume(5, $input, $state)"/>        <!-- StringLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NumericLiteral($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Literal', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse PrimaryExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PrimaryExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] = (6,                                           (: URIQualifiedName :)
                                         8,                                           (: QName^Token :)
                                         44,                                          (: 'ancestor' :)
                                         45,                                          (: 'ancestor-or-self' :)
                                         46,                                          (: 'and' :)
                                         50,                                          (: 'cast' :)
                                         51,                                          (: 'castable' :)
                                         52,                                          (: 'child' :)
                                         54,                                          (: 'descendant' :)
                                         55,                                          (: 'descendant-or-self' :)
                                         56,                                          (: 'div' :)
                                         59,                                          (: 'else' :)
                                         61,                                          (: 'eq' :)
                                         62,                                          (: 'every' :)
                                         63,                                          (: 'except' :)
                                         64,                                          (: 'following' :)
                                         65,                                          (: 'following-sibling' :)
                                         66,                                          (: 'for' :)
                                         68,                                          (: 'ge' :)
                                         69,                                          (: 'gt' :)
                                         70,                                          (: 'idiv' :)
                                         73,                                          (: 'instance' :)
                                         74,                                          (: 'intersect' :)
                                         75,                                          (: 'is' :)
                                         77,                                          (: 'le' :)
                                         78,                                          (: 'let' :)
                                         79,                                          (: 'lt' :)
                                         81,                                          (: 'mod' :)
                                         82,                                          (: 'namespace' :)
                                         84,                                          (: 'ne' :)
                                         87,                                          (: 'or' :)
                                         88,                                          (: 'parent' :)
                                         89,                                          (: 'preceding' :)
                                         90,                                          (: 'preceding-sibling' :)
                                         92,                                          (: 'return' :)
                                         93,                                          (: 'satisfies' :)
                                         96,                                          (: 'self' :)
                                         97,                                          (: 'some' :)
                                         101,                                         (: 'to' :)
                                         102,                                         (: 'treat' :)
                                         104)">                                     <!-- 'union' -->
          <xsl:variable name="state" select="p:lookahead2W(15, $input, $state)"/>   <!-- S^WS | '#' | '(' | ('(' ':') -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2                                             (: IntegerLiteral :)
                     or $state[$p:lk] = 3                                             (: DecimalLiteral :)
                     or $state[$p:lk] = 4                                             (: DoubleLiteral :)
                     or $state[$p:lk] = 5">                                         <!-- StringLiteral -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-Literal($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 16">                                        <!-- '$' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-VarRef($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 17">                                        <!-- '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ParenthesizedExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 24">                                        <!-- '.' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ContextItemExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2182                                          (: URIQualifiedName '(' :)
                     or $state[$p:lk] = 2184                                          (: QName^Token '(' :)
                     or $state[$p:lk] = 2220                                          (: 'ancestor' '(' :)
                     or $state[$p:lk] = 2221                                          (: 'ancestor-or-self' '(' :)
                     or $state[$p:lk] = 2222                                          (: 'and' '(' :)
                     or $state[$p:lk] = 2226                                          (: 'cast' '(' :)
                     or $state[$p:lk] = 2227                                          (: 'castable' '(' :)
                     or $state[$p:lk] = 2228                                          (: 'child' '(' :)
                     or $state[$p:lk] = 2230                                          (: 'descendant' '(' :)
                     or $state[$p:lk] = 2231                                          (: 'descendant-or-self' '(' :)
                     or $state[$p:lk] = 2232                                          (: 'div' '(' :)
                     or $state[$p:lk] = 2235                                          (: 'else' '(' :)
                     or $state[$p:lk] = 2237                                          (: 'eq' '(' :)
                     or $state[$p:lk] = 2238                                          (: 'every' '(' :)
                     or $state[$p:lk] = 2239                                          (: 'except' '(' :)
                     or $state[$p:lk] = 2240                                          (: 'following' '(' :)
                     or $state[$p:lk] = 2241                                          (: 'following-sibling' '(' :)
                     or $state[$p:lk] = 2242                                          (: 'for' '(' :)
                     or $state[$p:lk] = 2244                                          (: 'ge' '(' :)
                     or $state[$p:lk] = 2245                                          (: 'gt' '(' :)
                     or $state[$p:lk] = 2246                                          (: 'idiv' '(' :)
                     or $state[$p:lk] = 2249                                          (: 'instance' '(' :)
                     or $state[$p:lk] = 2250                                          (: 'intersect' '(' :)
                     or $state[$p:lk] = 2251                                          (: 'is' '(' :)
                     or $state[$p:lk] = 2253                                          (: 'le' '(' :)
                     or $state[$p:lk] = 2254                                          (: 'let' '(' :)
                     or $state[$p:lk] = 2255                                          (: 'lt' '(' :)
                     or $state[$p:lk] = 2257                                          (: 'mod' '(' :)
                     or $state[$p:lk] = 2258                                          (: 'namespace' '(' :)
                     or $state[$p:lk] = 2260                                          (: 'ne' '(' :)
                     or $state[$p:lk] = 2263                                          (: 'or' '(' :)
                     or $state[$p:lk] = 2264                                          (: 'parent' '(' :)
                     or $state[$p:lk] = 2265                                          (: 'preceding' '(' :)
                     or $state[$p:lk] = 2266                                          (: 'preceding-sibling' '(' :)
                     or $state[$p:lk] = 2268                                          (: 'return' '(' :)
                     or $state[$p:lk] = 2269                                          (: 'satisfies' '(' :)
                     or $state[$p:lk] = 2272                                          (: 'self' '(' :)
                     or $state[$p:lk] = 2273                                          (: 'some' '(' :)
                     or $state[$p:lk] = 2277                                          (: 'to' '(' :)
                     or $state[$p:lk] = 2278                                          (: 'treat' '(' :)
                     or $state[$p:lk] = 2280">                                      <!-- 'union' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-FunctionCall($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 80">                                        <!-- 'map' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-MapConstructor($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 42                                            (: '[' :)
                     or $state[$p:lk] = 47">                                        <!-- 'array' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ArrayConstructor($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 40">                                        <!-- '?' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-UnaryLookup($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-FunctionItemExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PrimaryExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production PostfixExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PostfixExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(40, $input, $state)"/>     <!-- S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                                                         '?' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' | 'eq' |
                                                                                         'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                                                         'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' |
                                                                                         'treat' | 'union' | '|' | '||' | '}' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 17                                         (: '(' :)
                      and $state[$p:l1] != 40                                         (: '?' :)
                      and $state[$p:l1] != 42">                                     <!-- '[' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 42">                                <!-- '[' -->
                  <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                  <xsl:variable name="state" select="
                    if ($state[$p:error]) then
                      $state
                    else
                      p:parse-Predicate($input, $state)
                  "/>
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 17">                                <!-- '(' -->
                  <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                  <xsl:variable name="state" select="
                    if ($state[$p:error]) then
                      $state
                    else
                      p:parse-ArgumentList($input, $state)
                  "/>
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                  <xsl:variable name="state" select="
                    if ($state[$p:error]) then
                      $state
                    else
                      p:parse-Lookup($input, $state)
                  "/>
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:sequence select="p:parse-PostfixExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse PostfixExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PostfixExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-PrimaryExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-PostfixExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PostfixExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse StepExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-StepExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 67">                                       <!-- 'function' -->
          <xsl:variable name="state" select="p:lookahead2W(35, $input, $state)"/>   <!-- S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                                                         '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' | 'eq' |
                                                                                         'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                                                         'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' |
                                                                                         'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = (47,                                          (: 'array' :)
                                         80)">                                      <!-- 'map' -->
          <xsl:variable name="state" select="p:lookahead2W(37, $input, $state)"/>   <!-- S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' |
                                                                                         '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                                                         ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' | 'eq' | 'except' |
                                                                                         'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'lt' |
                                                                                         'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' | 'treat' |
                                                                                         'union' | '{' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = (44,                                          (: 'ancestor' :)
                                         45,                                          (: 'ancestor-or-self' :)
                                         52,                                          (: 'child' :)
                                         54,                                          (: 'descendant' :)
                                         55,                                          (: 'descendant-or-self' :)
                                         64,                                          (: 'following' :)
                                         65,                                          (: 'following-sibling' :)
                                         82,                                          (: 'namespace' :)
                                         88,                                          (: 'parent' :)
                                         89,                                          (: 'preceding' :)
                                         90,                                          (: 'preceding-sibling' :)
                                         96)">                                      <!-- 'self' -->
          <xsl:variable name="state" select="p:lookahead2W(42, $input, $state)"/>   <!-- S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                                                         '-' | '/' | '//' | ':' | '::' | '<' | '<<' | '<=' | '=' | '=>' | '>' |
                                                                                         '>=' | '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' |
                                                                                         'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = (6,                                           (: URIQualifiedName :)
                                         8,                                           (: QName^Token :)
                                         46,                                          (: 'and' :)
                                         50,                                          (: 'cast' :)
                                         51,                                          (: 'castable' :)
                                         56,                                          (: 'div' :)
                                         59,                                          (: 'else' :)
                                         61,                                          (: 'eq' :)
                                         62,                                          (: 'every' :)
                                         63,                                          (: 'except' :)
                                         66,                                          (: 'for' :)
                                         68,                                          (: 'ge' :)
                                         69,                                          (: 'gt' :)
                                         70,                                          (: 'idiv' :)
                                         73,                                          (: 'instance' :)
                                         74,                                          (: 'intersect' :)
                                         75,                                          (: 'is' :)
                                         77,                                          (: 'le' :)
                                         78,                                          (: 'let' :)
                                         79,                                          (: 'lt' :)
                                         81,                                          (: 'mod' :)
                                         84,                                          (: 'ne' :)
                                         87,                                          (: 'or' :)
                                         92,                                          (: 'return' :)
                                         93,                                          (: 'satisfies' :)
                                         97,                                          (: 'some' :)
                                         101,                                         (: 'to' :)
                                         102,                                         (: 'treat' :)
                                         104)">                                     <!-- 'union' -->
          <xsl:variable name="state" select="p:lookahead2W(38, $input, $state)"/>   <!-- S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                                                         '-' | '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' |
                                                                                         '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                                                         'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                                                         'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2                                             (: IntegerLiteral :)
                     or $state[$p:lk] = 3                                             (: DecimalLiteral :)
                     or $state[$p:lk] = 4                                             (: DoubleLiteral :)
                     or $state[$p:lk] = 5                                             (: StringLiteral :)
                     or $state[$p:lk] = 16                                            (: '$' :)
                     or $state[$p:lk] = 17                                            (: '(' :)
                     or $state[$p:lk] = 24                                            (: '.' :)
                     or $state[$p:lk] = 40                                            (: '?' :)
                     or $state[$p:lk] = 42                                            (: '[' :)
                     or $state[$p:lk] = 1926                                          (: URIQualifiedName '#' :)
                     or $state[$p:lk] = 1928                                          (: QName^Token '#' :)
                     or $state[$p:lk] = 1964                                          (: 'ancestor' '#' :)
                     or $state[$p:lk] = 1965                                          (: 'ancestor-or-self' '#' :)
                     or $state[$p:lk] = 1966                                          (: 'and' '#' :)
                     or $state[$p:lk] = 1970                                          (: 'cast' '#' :)
                     or $state[$p:lk] = 1971                                          (: 'castable' '#' :)
                     or $state[$p:lk] = 1972                                          (: 'child' '#' :)
                     or $state[$p:lk] = 1974                                          (: 'descendant' '#' :)
                     or $state[$p:lk] = 1975                                          (: 'descendant-or-self' '#' :)
                     or $state[$p:lk] = 1976                                          (: 'div' '#' :)
                     or $state[$p:lk] = 1979                                          (: 'else' '#' :)
                     or $state[$p:lk] = 1981                                          (: 'eq' '#' :)
                     or $state[$p:lk] = 1982                                          (: 'every' '#' :)
                     or $state[$p:lk] = 1983                                          (: 'except' '#' :)
                     or $state[$p:lk] = 1984                                          (: 'following' '#' :)
                     or $state[$p:lk] = 1985                                          (: 'following-sibling' '#' :)
                     or $state[$p:lk] = 1986                                          (: 'for' '#' :)
                     or $state[$p:lk] = 1988                                          (: 'ge' '#' :)
                     or $state[$p:lk] = 1989                                          (: 'gt' '#' :)
                     or $state[$p:lk] = 1990                                          (: 'idiv' '#' :)
                     or $state[$p:lk] = 1993                                          (: 'instance' '#' :)
                     or $state[$p:lk] = 1994                                          (: 'intersect' '#' :)
                     or $state[$p:lk] = 1995                                          (: 'is' '#' :)
                     or $state[$p:lk] = 1997                                          (: 'le' '#' :)
                     or $state[$p:lk] = 1998                                          (: 'let' '#' :)
                     or $state[$p:lk] = 1999                                          (: 'lt' '#' :)
                     or $state[$p:lk] = 2001                                          (: 'mod' '#' :)
                     or $state[$p:lk] = 2002                                          (: 'namespace' '#' :)
                     or $state[$p:lk] = 2004                                          (: 'ne' '#' :)
                     or $state[$p:lk] = 2007                                          (: 'or' '#' :)
                     or $state[$p:lk] = 2008                                          (: 'parent' '#' :)
                     or $state[$p:lk] = 2009                                          (: 'preceding' '#' :)
                     or $state[$p:lk] = 2010                                          (: 'preceding-sibling' '#' :)
                     or $state[$p:lk] = 2012                                          (: 'return' '#' :)
                     or $state[$p:lk] = 2013                                          (: 'satisfies' '#' :)
                     or $state[$p:lk] = 2016                                          (: 'self' '#' :)
                     or $state[$p:lk] = 2017                                          (: 'some' '#' :)
                     or $state[$p:lk] = 2021                                          (: 'to' '#' :)
                     or $state[$p:lk] = 2022                                          (: 'treat' '#' :)
                     or $state[$p:lk] = 2024                                          (: 'union' '#' :)
                     or $state[$p:lk] = 2182                                          (: URIQualifiedName '(' :)
                     or $state[$p:lk] = 2184                                          (: QName^Token '(' :)
                     or $state[$p:lk] = 2220                                          (: 'ancestor' '(' :)
                     or $state[$p:lk] = 2221                                          (: 'ancestor-or-self' '(' :)
                     or $state[$p:lk] = 2222                                          (: 'and' '(' :)
                     or $state[$p:lk] = 2226                                          (: 'cast' '(' :)
                     or $state[$p:lk] = 2227                                          (: 'castable' '(' :)
                     or $state[$p:lk] = 2228                                          (: 'child' '(' :)
                     or $state[$p:lk] = 2230                                          (: 'descendant' '(' :)
                     or $state[$p:lk] = 2231                                          (: 'descendant-or-self' '(' :)
                     or $state[$p:lk] = 2232                                          (: 'div' '(' :)
                     or $state[$p:lk] = 2235                                          (: 'else' '(' :)
                     or $state[$p:lk] = 2237                                          (: 'eq' '(' :)
                     or $state[$p:lk] = 2238                                          (: 'every' '(' :)
                     or $state[$p:lk] = 2239                                          (: 'except' '(' :)
                     or $state[$p:lk] = 2240                                          (: 'following' '(' :)
                     or $state[$p:lk] = 2241                                          (: 'following-sibling' '(' :)
                     or $state[$p:lk] = 2242                                          (: 'for' '(' :)
                     or $state[$p:lk] = 2243                                          (: 'function' '(' :)
                     or $state[$p:lk] = 2244                                          (: 'ge' '(' :)
                     or $state[$p:lk] = 2245                                          (: 'gt' '(' :)
                     or $state[$p:lk] = 2246                                          (: 'idiv' '(' :)
                     or $state[$p:lk] = 2249                                          (: 'instance' '(' :)
                     or $state[$p:lk] = 2250                                          (: 'intersect' '(' :)
                     or $state[$p:lk] = 2251                                          (: 'is' '(' :)
                     or $state[$p:lk] = 2253                                          (: 'le' '(' :)
                     or $state[$p:lk] = 2254                                          (: 'let' '(' :)
                     or $state[$p:lk] = 2255                                          (: 'lt' '(' :)
                     or $state[$p:lk] = 2257                                          (: 'mod' '(' :)
                     or $state[$p:lk] = 2258                                          (: 'namespace' '(' :)
                     or $state[$p:lk] = 2260                                          (: 'ne' '(' :)
                     or $state[$p:lk] = 2263                                          (: 'or' '(' :)
                     or $state[$p:lk] = 2264                                          (: 'parent' '(' :)
                     or $state[$p:lk] = 2265                                          (: 'preceding' '(' :)
                     or $state[$p:lk] = 2266                                          (: 'preceding-sibling' '(' :)
                     or $state[$p:lk] = 2268                                          (: 'return' '(' :)
                     or $state[$p:lk] = 2269                                          (: 'satisfies' '(' :)
                     or $state[$p:lk] = 2272                                          (: 'self' '(' :)
                     or $state[$p:lk] = 2273                                          (: 'some' '(' :)
                     or $state[$p:lk] = 2277                                          (: 'to' '(' :)
                     or $state[$p:lk] = 2278                                          (: 'treat' '(' :)
                     or $state[$p:lk] = 2280                                          (: 'union' '(' :)
                     or $state[$p:lk] = 13487                                         (: 'array' '{' :)
                     or $state[$p:lk] = 13520">                                     <!-- 'map' '{' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-PostfixExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AxisStep($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'StepExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production RelativePathExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-RelativePathExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 26                                         (: '/' :)
                      and $state[$p:l1] != 27">                                     <!-- '//' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 26">                                <!-- '/' -->
                  <xsl:variable name="state" select="p:consume(26, $input, $state)"/> <!-- '/' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(27, $input, $state)"/> <!-- '//' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" select="p:lookahead1W(52, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '.' | '..' | '?' | '@' | '[' | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-StepExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-RelativePathExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse RelativePathExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-RelativePathExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-StepExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-RelativePathExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'RelativePathExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse PathExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PathExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 26">                                        <!-- '/' -->
          <xsl:variable name="state" select="p:consume(26, $input, $state)"/>       <!-- '/' -->
          <xsl:variable name="state" select="p:lookahead1W(58, $input, $state)"/>   <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '!' | '!=' | '$' |
                                                                                         '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | '.' | '..' | ':' |
                                                                                         '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '?' | '@' | '[' |
                                                                                         ']' | 'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' | '|' | '||' | '}' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 13                                      (: '!' :)
                           or $state[$p:l1] = 14                                      (: '!=' :)
                           or $state[$p:l1] = 19                                      (: ')' :)
                           or $state[$p:l1] = 20                                      (: '*' :)
                           or $state[$p:l1] = 21                                      (: '+' :)
                           or $state[$p:l1] = 22                                      (: ',' :)
                           or $state[$p:l1] = 23                                      (: '-' :)
                           or $state[$p:l1] = 28                                      (: ':' :)
                           or $state[$p:l1] = 32                                      (: '&lt;' :)
                           or $state[$p:l1] = 33                                      (: '&lt;&lt;' :)
                           or $state[$p:l1] = 34                                      (: '&lt;=' :)
                           or $state[$p:l1] = 35                                      (: '=' :)
                           or $state[$p:l1] = 36                                      (: '=>' :)
                           or $state[$p:l1] = 37                                      (: '>' :)
                           or $state[$p:l1] = 38                                      (: '>=' :)
                           or $state[$p:l1] = 39                                      (: '>>' :)
                           or $state[$p:l1] = 43                                      (: ']' :)
                           or $state[$p:l1] = 106                                     (: '|' :)
                           or $state[$p:l1] = 107                                     (: '||' :)
                           or $state[$p:l1] = 108">                                 <!-- '}' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-RelativePathExpr($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 27">                                        <!-- '//' -->
          <xsl:variable name="state" select="p:consume(27, $input, $state)"/>       <!-- '//' -->
          <xsl:variable name="state" select="p:lookahead1W(52, $input, $state)"/>   <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '.' | '..' | '?' | '@' | '[' | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-RelativePathExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-RelativePathExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PathExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production SimpleMapExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleMapExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 13">                                     <!-- '!' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(13, $input, $state)"/>     <!-- '!' -->
            <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '.' | '..' | '/' | '//' | '?' | '@' | '[' | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-PathExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-SimpleMapExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse SimpleMapExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleMapExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-PathExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-SimpleMapExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SimpleMapExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ValueExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ValueExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SimpleMapExpr($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ValueExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production UnaryExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-UnaryExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>     <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 21                                         (: '+' :)
                      and $state[$p:l1] != 23">                                     <!-- '-' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 23">                                <!-- '-' -->
                  <xsl:variable name="state" select="p:consume(23, $input, $state)"/> <!-- '-' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(21, $input, $state)"/> <!-- '+' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:sequence select="p:parse-UnaryExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse UnaryExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-UnaryExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:parse-UnaryExpr-1($input, $state)"/>
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ValueExpr($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'UnaryExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production ArrowExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArrowExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(33, $input, $state)"/>     <!-- S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' | '<' |
                                                                                         '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | ']' | 'and' | 'cast' |
                                                                                         'castable' | 'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                                                         'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' |
                                                                                         'return' | 'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' |
                                                                                         '}' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 36">                                     <!-- '=>' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(36, $input, $state)"/>     <!-- '=>' -->
            <xsl:variable name="state" select="p:lookahead1W(47, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | '$' | '(' | ('(' ':') |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ArrowFunctionSpecifier($input, $state)
            "/>
            <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>  <!-- S^WS | '(' | ('(' ':') -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ArgumentList($input, $state)
            "/>
            <xsl:sequence select="p:parse-ArrowExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse ArrowExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArrowExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-UnaryExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-ArrowExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ArrowExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse CastExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-CastExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ArrowExpr($input, $state)
    "/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 50">                                        <!-- 'cast' -->
          <xsl:variable name="state" select="p:consume(50, $input, $state)"/>       <!-- 'cast' -->
          <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>    <!-- S^WS | ('(' ':') | 'as' -->
          <xsl:variable name="state" select="p:consume(48, $input, $state)"/>       <!-- 'as' -->
          <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SingleType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'CastExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse CastableExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-CastableExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-CastExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(30, $input, $state)"/>         <!-- S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' | '<' |
                                                                                         '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' | 'castable' |
                                                                                         'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' | '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 51">                                        <!-- 'castable' -->
          <xsl:variable name="state" select="p:consume(51, $input, $state)"/>       <!-- 'castable' -->
          <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>    <!-- S^WS | ('(' ':') | 'as' -->
          <xsl:variable name="state" select="p:consume(48, $input, $state)"/>       <!-- 'as' -->
          <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SingleType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'CastableExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TreatExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TreatExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-CastableExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(28, $input, $state)"/>         <!-- S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' | '<' |
                                                                                         '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                                                         'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                                                         'to' | 'treat' | 'union' | '|' | '||' | '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 102">                                       <!-- 'treat' -->
          <xsl:variable name="state" select="p:consume(102, $input, $state)"/>      <!-- 'treat' -->
          <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>    <!-- S^WS | ('(' ':') | 'as' -->
          <xsl:variable name="state" select="p:consume(48, $input, $state)"/>       <!-- 'as' -->
          <xsl:variable name="state" select="p:lookahead1W(45, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SequenceType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TreatExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse InstanceofExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-InstanceofExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-TreatExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(27, $input, $state)"/>         <!-- S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' | '<' |
                                                                                         '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                                                         'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                                                         'to' | 'union' | '|' | '||' | '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 73">                                        <!-- 'instance' -->
          <xsl:variable name="state" select="p:consume(73, $input, $state)"/>       <!-- 'instance' -->
          <xsl:variable name="state" select="p:lookahead1W(11, $input, $state)"/>   <!-- S^WS | ('(' ':') | 'of' -->
          <xsl:variable name="state" select="p:consume(86, $input, $state)"/>       <!-- 'of' -->
          <xsl:variable name="state" select="p:lookahead1W(45, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SequenceType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'InstanceofExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-IntersectExceptExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(26, $input, $state)"/>     <!-- S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' | '<' |
                                                                                         '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'intersect' | 'is' | 'le' |
                                                                                         'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' | 'union' |
                                                                                         '|' | '||' | '}' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 63                                         (: 'except' :)
                      and $state[$p:l1] != 74">                                     <!-- 'intersect' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 74">                                <!-- 'intersect' -->
                  <xsl:variable name="state" select="p:consume(74, $input, $state)"/> <!-- 'intersect' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(63, $input, $state)"/> <!-- 'except' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-InstanceofExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-IntersectExceptExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse IntersectExceptExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-IntersectExceptExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-InstanceofExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-IntersectExceptExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'IntersectExceptExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production UnionExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-UnionExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 104                                        (: 'union' :)
                      and $state[$p:l1] != 106">                                    <!-- '|' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 104">                               <!-- 'union' -->
                  <xsl:variable name="state" select="p:consume(104, $input, $state)"/> <!-- 'union' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(106, $input, $state)"/> <!-- '|' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-IntersectExceptExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-UnionExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse UnionExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-UnionExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-IntersectExceptExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-UnionExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'UnionExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MultiplicativeExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 20                                         (: '*' :)
                      and $state[$p:l1] != 56                                         (: 'div' :)
                      and $state[$p:l1] != 70                                         (: 'idiv' :)
                      and $state[$p:l1] != 81">                                     <!-- 'mod' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 20">                                <!-- '*' -->
                  <xsl:variable name="state" select="p:consume(20, $input, $state)"/> <!-- '*' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 56">                                <!-- 'div' -->
                  <xsl:variable name="state" select="p:consume(56, $input, $state)"/> <!-- 'div' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 70">                                <!-- 'idiv' -->
                  <xsl:variable name="state" select="p:consume(70, $input, $state)"/> <!-- 'idiv' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(81, $input, $state)"/> <!-- 'mod' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-UnionExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-MultiplicativeExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse MultiplicativeExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MultiplicativeExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-UnionExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-MultiplicativeExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'MultiplicativeExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production AdditiveExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AdditiveExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 21                                         (: '+' :)
                      and $state[$p:l1] != 23">                                     <!-- '-' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 21">                                <!-- '+' -->
                  <xsl:variable name="state" select="p:consume(21, $input, $state)"/> <!-- '+' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(23, $input, $state)"/> <!-- '-' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-MultiplicativeExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-AdditiveExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse AdditiveExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AdditiveExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-MultiplicativeExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-AdditiveExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AdditiveExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse RangeExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-RangeExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AdditiveExpr($input, $state)
    "/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 101">                                       <!-- 'to' -->
          <xsl:variable name="state" select="p:consume(101, $input, $state)"/>      <!-- 'to' -->
          <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>   <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AdditiveExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'RangeExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production StringConcatExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-StringConcatExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 107">                                    <!-- '||' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(107, $input, $state)"/>    <!-- '||' -->
            <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-RangeExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-StringConcatExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse StringConcatExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-StringConcatExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-RangeExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-StringConcatExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'StringConcatExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ComparisonExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ComparisonExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-StringConcatExpr($input, $state)
    "/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 19                                           (: ')' :)
                    and $state[$p:l1] != 22                                           (: ',' :)
                    and $state[$p:l1] != 28                                           (: ':' :)
                    and $state[$p:l1] != 43                                           (: ']' :)
                    and $state[$p:l1] != 46                                           (: 'and' :)
                    and $state[$p:l1] != 59                                           (: 'else' :)
                    and $state[$p:l1] != 87                                           (: 'or' :)
                    and $state[$p:l1] != 92                                           (: 'return' :)
                    and $state[$p:l1] != 93                                           (: 'satisfies' :)
                    and $state[$p:l1] != 108">                                      <!-- '}' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 61                                      (: 'eq' :)
                           or $state[$p:l1] = 68                                      (: 'ge' :)
                           or $state[$p:l1] = 69                                      (: 'gt' :)
                           or $state[$p:l1] = 77                                      (: 'le' :)
                           or $state[$p:l1] = 79                                      (: 'lt' :)
                           or $state[$p:l1] = 84">                                  <!-- 'ne' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-ValueComp($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 33                                      (: '&lt;&lt;' :)
                           or $state[$p:l1] = 39                                      (: '>>' :)
                           or $state[$p:l1] = 75">                                  <!-- 'is' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-NodeComp($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-GeneralComp($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>   <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-StringConcatExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ComparisonExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production AndExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AndExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 46">                                     <!-- 'and' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(46, $input, $state)"/>     <!-- 'and' -->
            <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ComparisonExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-AndExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse AndExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AndExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ComparisonExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-AndExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AndExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production OrExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-OrExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 87">                                     <!-- 'or' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(87, $input, $state)"/>     <!-- 'or' -->
            <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-AndExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-OrExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse OrExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-OrExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AndExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-OrExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'OrExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse IfExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-IfExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(71, $input, $state)"/>             <!-- 'if' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-Expr($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="state" select="p:lookahead1W(12, $input, $state)"/>         <!-- S^WS | ('(' ':') | 'then' -->
    <xsl:variable name="state" select="p:consume(100, $input, $state)"/>            <!-- 'then' -->
    <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(59, $input, $state)"/>             <!-- 'else' -->
    <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'IfExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production QuantifiedExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-QuantifiedExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>  <!-- S^WS | '$' | ('(' ':') -->
            <xsl:variable name="state" select="p:consume(16, $input, $state)"/>     <!-- '$' -->
            <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-VarName($input, $state)
            "/>
            <xsl:variable name="state" select="p:lookahead1W(10, $input, $state)"/> <!-- S^WS | ('(' ':') | 'in' -->
            <xsl:variable name="state" select="p:consume(72, $input, $state)"/>     <!-- 'in' -->
            <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ExprSingle($input, $state)
            "/>
            <xsl:sequence select="p:parse-QuantifiedExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse QuantifiedExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-QuantifiedExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 97">                                        <!-- 'some' -->
          <xsl:variable name="state" select="p:consume(97, $input, $state)"/>       <!-- 'some' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(62, $input, $state)"/>       <!-- 'every' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>          <!-- S^WS | '$' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '$' -->
    <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-VarName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(10, $input, $state)"/>         <!-- S^WS | ('(' ':') | 'in' -->
    <xsl:variable name="state" select="p:consume(72, $input, $state)"/>             <!-- 'in' -->
    <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-QuantifiedExpr-1($input, $state)"/>
    <xsl:variable name="state" select="p:consume(93, $input, $state)"/>             <!-- 'satisfies' -->
    <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'QuantifiedExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SimpleLetBinding.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleLetBinding" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '$' -->
    <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-VarName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(8, $input, $state)"/>          <!-- S^WS | ('(' ':') | ':=' -->
    <xsl:variable name="state" select="p:consume(31, $input, $state)"/>             <!-- ':=' -->
    <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SimpleLetBinding', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production SimpleLetClause (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleLetClause-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>  <!-- S^WS | '$' | ('(' ':') -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-SimpleLetBinding($input, $state)
            "/>
            <xsl:sequence select="p:parse-SimpleLetClause-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse SimpleLetClause.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleLetClause" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(78, $input, $state)"/>             <!-- 'let' -->
    <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>          <!-- S^WS | '$' | ('(' ':') -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SimpleLetBinding($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-SimpleLetClause-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SimpleLetClause', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse LetExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-LetExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SimpleLetClause($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(92, $input, $state)"/>             <!-- 'return' -->
    <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'LetExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FunctionName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 8">                                         <!-- QName^Token -->
          <xsl:variable name="state" select="p:consume(8, $input, $state)"/>        <!-- QName^Token -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 44">                                        <!-- 'ancestor' -->
          <xsl:variable name="state" select="p:consume(44, $input, $state)"/>       <!-- 'ancestor' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 45">                                        <!-- 'ancestor-or-self' -->
          <xsl:variable name="state" select="p:consume(45, $input, $state)"/>       <!-- 'ancestor-or-self' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 46">                                        <!-- 'and' -->
          <xsl:variable name="state" select="p:consume(46, $input, $state)"/>       <!-- 'and' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 50">                                        <!-- 'cast' -->
          <xsl:variable name="state" select="p:consume(50, $input, $state)"/>       <!-- 'cast' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 51">                                        <!-- 'castable' -->
          <xsl:variable name="state" select="p:consume(51, $input, $state)"/>       <!-- 'castable' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 52">                                        <!-- 'child' -->
          <xsl:variable name="state" select="p:consume(52, $input, $state)"/>       <!-- 'child' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 54">                                        <!-- 'descendant' -->
          <xsl:variable name="state" select="p:consume(54, $input, $state)"/>       <!-- 'descendant' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 55">                                        <!-- 'descendant-or-self' -->
          <xsl:variable name="state" select="p:consume(55, $input, $state)"/>       <!-- 'descendant-or-self' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 56">                                        <!-- 'div' -->
          <xsl:variable name="state" select="p:consume(56, $input, $state)"/>       <!-- 'div' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 59">                                        <!-- 'else' -->
          <xsl:variable name="state" select="p:consume(59, $input, $state)"/>       <!-- 'else' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 61">                                        <!-- 'eq' -->
          <xsl:variable name="state" select="p:consume(61, $input, $state)"/>       <!-- 'eq' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 62">                                        <!-- 'every' -->
          <xsl:variable name="state" select="p:consume(62, $input, $state)"/>       <!-- 'every' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 63">                                        <!-- 'except' -->
          <xsl:variable name="state" select="p:consume(63, $input, $state)"/>       <!-- 'except' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 64">                                        <!-- 'following' -->
          <xsl:variable name="state" select="p:consume(64, $input, $state)"/>       <!-- 'following' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 65">                                        <!-- 'following-sibling' -->
          <xsl:variable name="state" select="p:consume(65, $input, $state)"/>       <!-- 'following-sibling' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 66">                                        <!-- 'for' -->
          <xsl:variable name="state" select="p:consume(66, $input, $state)"/>       <!-- 'for' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 68">                                        <!-- 'ge' -->
          <xsl:variable name="state" select="p:consume(68, $input, $state)"/>       <!-- 'ge' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 69">                                        <!-- 'gt' -->
          <xsl:variable name="state" select="p:consume(69, $input, $state)"/>       <!-- 'gt' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 70">                                        <!-- 'idiv' -->
          <xsl:variable name="state" select="p:consume(70, $input, $state)"/>       <!-- 'idiv' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 73">                                        <!-- 'instance' -->
          <xsl:variable name="state" select="p:consume(73, $input, $state)"/>       <!-- 'instance' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 74">                                        <!-- 'intersect' -->
          <xsl:variable name="state" select="p:consume(74, $input, $state)"/>       <!-- 'intersect' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 75">                                        <!-- 'is' -->
          <xsl:variable name="state" select="p:consume(75, $input, $state)"/>       <!-- 'is' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 77">                                        <!-- 'le' -->
          <xsl:variable name="state" select="p:consume(77, $input, $state)"/>       <!-- 'le' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 78">                                        <!-- 'let' -->
          <xsl:variable name="state" select="p:consume(78, $input, $state)"/>       <!-- 'let' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 79">                                        <!-- 'lt' -->
          <xsl:variable name="state" select="p:consume(79, $input, $state)"/>       <!-- 'lt' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 81">                                        <!-- 'mod' -->
          <xsl:variable name="state" select="p:consume(81, $input, $state)"/>       <!-- 'mod' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 82">                                        <!-- 'namespace' -->
          <xsl:variable name="state" select="p:consume(82, $input, $state)"/>       <!-- 'namespace' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 84">                                        <!-- 'ne' -->
          <xsl:variable name="state" select="p:consume(84, $input, $state)"/>       <!-- 'ne' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 87">                                        <!-- 'or' -->
          <xsl:variable name="state" select="p:consume(87, $input, $state)"/>       <!-- 'or' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 88">                                        <!-- 'parent' -->
          <xsl:variable name="state" select="p:consume(88, $input, $state)"/>       <!-- 'parent' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 89">                                        <!-- 'preceding' -->
          <xsl:variable name="state" select="p:consume(89, $input, $state)"/>       <!-- 'preceding' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 90">                                        <!-- 'preceding-sibling' -->
          <xsl:variable name="state" select="p:consume(90, $input, $state)"/>       <!-- 'preceding-sibling' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 92">                                        <!-- 'return' -->
          <xsl:variable name="state" select="p:consume(92, $input, $state)"/>       <!-- 'return' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 93">                                        <!-- 'satisfies' -->
          <xsl:variable name="state" select="p:consume(93, $input, $state)"/>       <!-- 'satisfies' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 96">                                        <!-- 'self' -->
          <xsl:variable name="state" select="p:consume(96, $input, $state)"/>       <!-- 'self' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 97">                                        <!-- 'some' -->
          <xsl:variable name="state" select="p:consume(97, $input, $state)"/>       <!-- 'some' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 101">                                       <!-- 'to' -->
          <xsl:variable name="state" select="p:consume(101, $input, $state)"/>      <!-- 'to' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 102">                                       <!-- 'treat' -->
          <xsl:variable name="state" select="p:consume(102, $input, $state)"/>      <!-- 'treat' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(104, $input, $state)"/>      <!-- 'union' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse QName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-QName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 47">                                        <!-- 'array' -->
          <xsl:variable name="state" select="p:consume(47, $input, $state)"/>       <!-- 'array' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 49">                                        <!-- 'attribute' -->
          <xsl:variable name="state" select="p:consume(49, $input, $state)"/>       <!-- 'attribute' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 53">                                        <!-- 'comment' -->
          <xsl:variable name="state" select="p:consume(53, $input, $state)"/>       <!-- 'comment' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 57">                                        <!-- 'document-node' -->
          <xsl:variable name="state" select="p:consume(57, $input, $state)"/>       <!-- 'document-node' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 58">                                        <!-- 'element' -->
          <xsl:variable name="state" select="p:consume(58, $input, $state)"/>       <!-- 'element' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 60">                                        <!-- 'empty-sequence' -->
          <xsl:variable name="state" select="p:consume(60, $input, $state)"/>       <!-- 'empty-sequence' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 67">                                        <!-- 'function' -->
          <xsl:variable name="state" select="p:consume(67, $input, $state)"/>       <!-- 'function' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 71">                                        <!-- 'if' -->
          <xsl:variable name="state" select="p:consume(71, $input, $state)"/>       <!-- 'if' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 76">                                        <!-- 'item' -->
          <xsl:variable name="state" select="p:consume(76, $input, $state)"/>       <!-- 'item' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 80">                                        <!-- 'map' -->
          <xsl:variable name="state" select="p:consume(80, $input, $state)"/>       <!-- 'map' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 83">                                        <!-- 'namespace-node' -->
          <xsl:variable name="state" select="p:consume(83, $input, $state)"/>       <!-- 'namespace-node' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 85">                                        <!-- 'node' -->
          <xsl:variable name="state" select="p:consume(85, $input, $state)"/>       <!-- 'node' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 91">                                        <!-- 'processing-instruction' -->
          <xsl:variable name="state" select="p:consume(91, $input, $state)"/>       <!-- 'processing-instruction' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 94">                                        <!-- 'schema-attribute' -->
          <xsl:variable name="state" select="p:consume(94, $input, $state)"/>       <!-- 'schema-attribute' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 95">                                        <!-- 'schema-element' -->
          <xsl:variable name="state" select="p:consume(95, $input, $state)"/>       <!-- 'schema-element' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 98">                                        <!-- 'switch' -->
          <xsl:variable name="state" select="p:consume(98, $input, $state)"/>       <!-- 'switch' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 99">                                        <!-- 'text' -->
          <xsl:variable name="state" select="p:consume(99, $input, $state)"/>       <!-- 'text' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 103">                                       <!-- 'typeswitch' -->
          <xsl:variable name="state" select="p:consume(103, $input, $state)"/>      <!-- 'typeswitch' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-FunctionName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'QName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse EQName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-EQName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 6">                                         <!-- URIQualifiedName -->
          <xsl:variable name="state" select="p:consume(6, $input, $state)"/>        <!-- URIQualifiedName -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-QName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'EQName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse VarName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-VarName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EQName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'VarName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SimpleForBinding.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleForBinding" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '$' -->
    <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-VarName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(10, $input, $state)"/>         <!-- S^WS | ('(' ':') | 'in' -->
    <xsl:variable name="state" select="p:consume(72, $input, $state)"/>             <!-- 'in' -->
    <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SimpleForBinding', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production SimpleForClause (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleForClause-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>  <!-- S^WS | '$' | ('(' ':') -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-SimpleForBinding($input, $state)
            "/>
            <xsl:sequence select="p:parse-SimpleForClause-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse SimpleForClause.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleForClause" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(66, $input, $state)"/>             <!-- 'for' -->
    <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>          <!-- S^WS | '$' | ('(' ':') -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SimpleForBinding($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-SimpleForClause-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SimpleForClause', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ForExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ForExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SimpleForClause($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(92, $input, $state)"/>             <!-- 'return' -->
    <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ForExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ExprSingle.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ExprSingle" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 71">                                       <!-- 'if' -->
          <xsl:variable name="state" select="p:lookahead2W(35, $input, $state)"/>   <!-- S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                                                         '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' | 'eq' |
                                                                                         'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                                                         'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' |
                                                                                         'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = (62,                                          (: 'every' :)
                                         66,                                          (: 'for' :)
                                         78,                                          (: 'let' :)
                                         97)">                                      <!-- 'some' -->
          <xsl:variable name="state" select="p:lookahead2W(41, $input, $state)"/>   <!-- S^WS | '!' | '!=' | '#' | '$' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                                                         ',' | '-' | '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' |
                                                                                         '>=' | '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' |
                                                                                         'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2114">                                      <!-- 'for' '$' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ForExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2126">                                      <!-- 'let' '$' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-LetExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2110                                          (: 'every' '$' :)
                     or $state[$p:lk] = 2145">                                      <!-- 'some' '$' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-QuantifiedExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2247">                                      <!-- 'if' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-IfExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-OrExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ExprSingle', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production Expr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Expr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ExprSingle($input, $state)
            "/>
            <xsl:sequence select="p:parse-Expr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse Expr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Expr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-Expr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Expr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AVTVar.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AVTVar" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(105, $input, $state)"/>            <!-- '{' -->
    <xsl:variable name="state" select="p:lookahead1W(57, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' | '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 108">                                      <!-- '}' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-Expr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(108, $input, $state)"/>            <!-- '}' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AVTVar', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production AVTFix (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AVTFix-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(20, $input, $state)"/>     <!-- AVTFixChar | S^WS | EOF | ('(' ':') | '{' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 1">                                      <!-- AVTFixChar -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(1, $input, $state)"/>      <!-- AVTFixChar -->
            <xsl:sequence select="p:parse-AVTFix-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse AVTFix.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AVTFix" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:parse-AVTFix-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AVTFix', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production AVTExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AVTExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 105">                                    <!-- '{' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-AVTVar($input, $state)
            "/>
            <xsl:variable name="state" select="p:lookahead1W(20, $input, $state)"/> <!-- AVTFixChar | S^WS | EOF | ('(' ':') | '{' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-AVTFix($input, $state)
            "/>
            <xsl:sequence select="p:parse-AVTExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse AVTExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AVTExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AVTFix($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-AVTExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AVTExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AVT.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AVT" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:lookahead1W(20, $input, $state)"/>         <!-- AVTFixChar | S^WS | EOF | ('(' ':') | '{' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AVTExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(12, $input, $state)"/>             <!-- EOF -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AVT', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Create a textual error message from a parsing error.
   !
   ! @param $input the input string.
   ! @param $error the parsing error descriptor.
   ! @return the error message.
  -->
  <xsl:function name="p:error-message" as="xs:string">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="error" as="element(error)"/>

    <xsl:variable name="begin" select="xs:integer($error/@b)"/>
    <xsl:variable name="context" select="string-to-codepoints(substring($input, 1, $begin - 1))"/>
    <xsl:variable name="linefeeds" select="index-of($context, 10)"/>
    <xsl:variable name="line" select="count($linefeeds) + 1"/>
    <xsl:variable name="column" select="($begin - $linefeeds[last()], $begin)[1]"/>
    <xsl:variable name="expected" select="if ($error/@x or $error/@ambiguous-input) then () else p:expected-token-set($error/@s)"/>
    <xsl:sequence select="
      string-join
      (
        (
          if ($error/@o) then
            ('syntax error, found ', $p:TOKEN[$error/@o + 1])
          else
            'lexical analysis failed',
          '&#10;',
          'while expecting ',
          if ($error/@x) then
            $p:TOKEN[$error/@x + 1]
          else
          (
            '['[exists($expected[2])],
            string-join($expected, ', '),
            ']'[exists($expected[2])]
          ),
          '&#10;',
          if ($error/@o or $error/@e = $begin) then
            ()
          else
            ('after successfully scanning ', string($error/@e - $begin), ' characters beginning '),
          'at line ', string($line), ', column ', string($column), ':&#10;',
          '...', substring($input, $begin, 64), '...'
        ),
        ''
      )
    "/>
  </xsl:function>

  <!--~
   ! Consume one token, i.e. compare lookahead token 1 with expected
   ! token and in case of a match, shift lookahead tokens down such that
   ! l1 becomes the current token, and higher lookahead tokens move down.
   ! When lookahead token 1 does not match the expected token, raise an
   ! error by saving the expected token code in the error field of the
   ! lexer state.
   !
   ! @param $code the expected token.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:consume" as="item()+">
    <xsl:param name="code" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:when test="$state[$p:l1] eq $code">
        <xsl:variable name="begin" select="$state[$p:e0]"/>
        <xsl:variable name="end" select="$state[$p:b1]"/>
        <xsl:variable name="whitespace">
          <xsl:if test="$begin ne $end">
            <xsl:value-of select="substring($input, $begin, $end - $begin)"/>
          </xsl:if>
        </xsl:variable>
        <xsl:variable name="token" select="$p:TOKEN[1 + $state[$p:l1]]"/>
        <xsl:variable name="name" select="if (starts-with($token, &quot;'&quot;)) then 'TOKEN' else $token"/>
        <xsl:variable name="begin" select="$state[$p:b1]"/>
        <xsl:variable name="end" select="$state[$p:e1]"/>
        <xsl:variable name="node">
          <xsl:element name="{$name}">
            <xsl:sequence select="substring($input, $begin, $end - $begin)"/>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="
          subsequence($state, $p:l1, 9),
          0, 0, 0,
          subsequence($state, 13),
          $whitespace/node(),
          $node/node()
        "/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="error">
          <xsl:element name="error">
            <xsl:attribute name="b" select="$state[$p:b1]"/>
            <xsl:attribute name="e" select="$state[$p:e1]"/>
            <xsl:choose>
              <xsl:when test="$state[$p:l1] lt 0">
                <xsl:attribute name="s" select="- $state[$p:l1]"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:attribute name="o" select="$state[$p:l1]"/>
                <xsl:attribute name="x" select="$code"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="
          subsequence($state, 1, $p:error - 1),
          $error/node(),
          subsequence($state, $p:error + 1)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Consume one token, i.e. compare lookahead token 1 with expected
   ! token and in case of a match, shift lookahead tokens down such that
   ! l1 becomes the current token, and higher lookahead tokens move down.
   ! When lookahead token 1 does not match the expected token, raise an
   ! error by saving the expected token code in the error field of the
   ! lexer state. In contrast to p:consume, do not create any output.
   !
   ! @param $code the expected token.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:consumeT" as="item()+">
    <xsl:param name="code" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:when test="$state[$p:l1] eq $code">
        <xsl:sequence select="
          subsequence($state, $p:l1, 9),
          0, 0, 0,
          subsequence($state, 13)
        "/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="error">
          <xsl:element name="error">
            <xsl:attribute name="b" select="$state[$p:b1]"/>
            <xsl:attribute name="e" select="$state[$p:e1]"/>
            <xsl:choose>
              <xsl:when test="$state[$p:l1] lt 0">
                <xsl:attribute name="s" select="- $state[$p:l1]"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:attribute name="o" select="$state[$p:l1]"/>
                <xsl:attribute name="x" select="$code"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="
          subsequence($state, 1, $p:error - 1),
          $error/node(),
          subsequence($state, $p:error + 1)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Consume whitespace.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:whitespace" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="end" select="$state[$p:b1]"/>
    <xsl:choose>
      <xsl:when test="$begin eq $end">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="whitespace">
          <xsl:value-of select="substring($input, $begin, $end - $begin)"/>
        </xsl:variable>
        <xsl:sequence select="
          0,
          $state[$p:b0],
          $end,
          subsequence($state, $p:e0 + 1),
          $whitespace/node()
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Use p:match to fetch the next token, but skip any leading
   ! whitespace.
   !
   ! @param $input the input string.
   ! @param $begin the index where to start.
   ! @param $token-set the valid token set id.
   ! @return a sequence of three values: the token code of the result
   ! token, with input string positions of token begin and end.
  -->
  <xsl:function name="p:matchW">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="token-set" as="xs:integer"/>

    <xsl:variable name="match" select="p:match($input, $begin, $token-set)"/>
    <xsl:choose>
      <xsl:when test="$match[1] = 9">                                               <!-- S^WS -->
        <xsl:sequence select="p:matchW($input, $match[3], $token-set)"/>
      </xsl:when>
      <xsl:when test="$match[1] = 18">                                              <!-- ('(' ':') -->
        <xsl:variable name="state" select="p:try-Whitespace($input, (0, $begin, $begin, $match, 0, 0, 0, 0, 0, 0, false()))"/>
        <xsl:sequence select="p:matchW($input, $state[$p:e0], $token-set)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="$match"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Lookahead one token on level 1 with whitespace skipping.
   !
   ! @param $set the code of the DFA entry state for the set of valid tokens.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result stack.
   ! @return the updated state.
  -->
  <xsl:function name="p:lookahead1W" as="item()+">
    <xsl:param name="set" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:l1] ne 0">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="match" select="
          p:matchW($input, $state[$p:e0], $set),
          0, 0, 0
        "/>
        <xsl:sequence select="
          $match[1],
          subsequence($state, $p:b0, 2),
          $match,
          subsequence($state, 10)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Lookahead one token on level 2 with whitespace skipping.
   !
   ! @param $set the code of the DFA entry state for the set of valid tokens.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result stack.
   ! @return the updated state.
  -->
  <xsl:function name="p:lookahead2W" as="item()+">
    <xsl:param name="set" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="match" select="
      if ($state[$p:l2] ne 0) then
        subsequence($state, $p:l2, 6)
      else
      (
        p:matchW($input, $state[$p:e1], $set),
        0, 0, 0
      )
    "/>
    <xsl:sequence select="
      $match[1] * 128 + $state[$p:l1],
      subsequence($state, $p:b0, 5),
      $match,
      subsequence($state, 13)
    "/>
  </xsl:function>

  <!--~
   ! Lookahead one token on level 3 with whitespace skipping.
   !
   ! @param $set the code of the DFA entry state for the set of valid tokens.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result stack.
   ! @return the updated state.
  -->
  <xsl:function name="p:lookahead3W" as="item()+">
    <xsl:param name="set" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="match" select="
      if ($state[$p:l3] ne 0) then
        subsequence($state, $p:l3, 3)
      else
        p:matchW($input, $state[$p:e2], $set)
    "/>
    <xsl:sequence select="
      $match[1] * 16384 + $state[$p:lk],
      subsequence($state, $p:b0, 8),
      $match,
      subsequence($state, 13)
    "/>
  </xsl:function>

  <!--~
   ! Lookahead one token on level 1.
   !
   ! @param $set the code of the DFA entry state for the set of valid tokens.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result stack.
   ! @return the updated state.
  -->
  <xsl:function name="p:lookahead1" as="item()+">
    <xsl:param name="set" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:l1] ne 0">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="match" select="
          p:match($input, $state[$p:e0], $set),
          0, 0, 0
        "/>
        <xsl:sequence select="
          $match[1],
          subsequence($state, $p:b0, 2),
          $match,
          subsequence($state, 10)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Reduce the result stack, creating a nonterminal element. Pop
   ! $count elements off the stack, wrap them in a new element
   ! named $name, and push the new element.
   !
   ! @param $state lexer state, error indicator, and result.
   ! @param $name the name of the result node.
   ! @param $count the number of child nodes.
   ! @param $begin the input index where the nonterminal begins.
   ! @param $end the input index where the nonterminal ends.
   ! @return the updated state.
  -->
  <xsl:function name="p:reduce" as="item()+">
    <xsl:param name="state" as="item()+"/>
    <xsl:param name="name" as="xs:string"/>
    <xsl:param name="count" as="xs:integer"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="end" as="xs:integer"/>

    <xsl:variable name="node">
      <xsl:element name="{$name}">
        <xsl:sequence select="subsequence($state, $count + 1)"/>
      </xsl:element>
    </xsl:variable>
    <xsl:sequence select="subsequence($state, 1, $count), $node/node()"/>
  </xsl:function>

  <!--~
   ! Parse start symbol AVT from given string.
   !
   ! @param $s the string to be parsed.
   ! @return the result as generated by parser actions.
  -->
  <xsl:function name="p:parse-AVT" as="item()*">
    <xsl:param name="s" as="xs:string"/>

    <xsl:variable name="state" select="0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, false()"/>
    <xsl:variable name="state" select="p:parse-AVT($s, $state)"/>
    <xsl:variable name="error" select="$state[$p:error]"/>
    <xsl:choose>
      <xsl:when test="$error">
        <xsl:variable name="ERROR">
          <xsl:element name="ERROR">
            <xsl:sequence select="$error/@*, p:error-message($s, $error)"/>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="$ERROR/node()"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="subsequence($state, $p:result)"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

</xsl:stylesheet>