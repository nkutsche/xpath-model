<?xml version="1.0" encoding="UTF-8"?>
<!-- This file was generated on Tue Jan 11, 2022 18:13 (UTC+01) by REx v5.55 which is Copyright (c) 1979-2022 by Gunther Rademacher <grd@gmx.net> -->
<!-- REx command line: xslt-3-avt.ebnf -tree -xslt -->

<xsl:stylesheet version="2.0"
                xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:p="xslt-3-avt">
  <!--~
   ! The index of the lexer state for accessing the combined
   ! (i.e. level > 1) lookahead code.
  -->
  <xsl:variable name="p:lk" as="xs:integer" select="1"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the begin of the token that has been consumed.
  -->
  <xsl:variable name="p:b0" as="xs:integer" select="2"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the end of the token that has been consumed.
  -->
  <xsl:variable name="p:e0" as="xs:integer" select="3"/>

  <!--~
   ! The index of the lexer state for accessing the code of the
   ! level-1-lookahead token.
  -->
  <xsl:variable name="p:l1" as="xs:integer" select="4"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the begin of the level-1-lookahead token.
  -->
  <xsl:variable name="p:b1" as="xs:integer" select="5"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the end of the level-1-lookahead token.
  -->
  <xsl:variable name="p:e1" as="xs:integer" select="6"/>

  <!--~
   ! The index of the lexer state for accessing the code of the
   ! level-2-lookahead token.
  -->
  <xsl:variable name="p:l2" as="xs:integer" select="7"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the begin of the level-2-lookahead token.
  -->
  <xsl:variable name="p:b2" as="xs:integer" select="8"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the end of the level-2-lookahead token.
  -->
  <xsl:variable name="p:e2" as="xs:integer" select="9"/>

  <!--~
   ! The index of the lexer state for accessing the code of the
   ! level-3-lookahead token.
  -->
  <xsl:variable name="p:l3" as="xs:integer" select="10"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the begin of the level-3-lookahead token.
  -->
  <xsl:variable name="p:b3" as="xs:integer" select="11"/>

  <!--~
   ! The index of the lexer state for accessing the position in the
   ! input string of the end of the level-3-lookahead token.
  -->
  <xsl:variable name="p:e3" as="xs:integer" select="12"/>

  <!--~
   ! The index of the lexer state for accessing the token code that
   ! was expected when an error was found.
  -->
  <xsl:variable name="p:error" as="xs:integer" select="13"/>

  <!--~
   ! The index of the lexer state that points to the first entry
   ! used for collecting action results.
  -->
  <xsl:variable name="p:result" as="xs:integer" select="14"/>

  <!--~
   ! The codepoint to charclass mapping for 7 bit codepoints.
  -->
  <xsl:variable name="p:MAP0" as="xs:integer+" select="
    55, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 6, 18, 19, 20, 21, 22, 23, 23, 23, 23, 24, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 25, 23, 23, 23, 23, 23, 23,
    23, 23, 23, 26, 6, 27, 6, 23, 6, 28, 29, 30, 31, 32, 33, 34, 35, 36, 23, 23, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 23, 51, 52, 53, 6, 6
  "/>

  <!--~
   ! The codepoint to charclass mapping for codepoints below the surrogate block.
  -->
  <xsl:variable name="p:MAP1" as="xs:integer+" select="
    108, 124, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 156, 181, 181, 181, 181, 181, 214, 215, 213, 214, 214, 214, 214, 214, 214,
    214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
    214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214,
    214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 214, 247, 261, 277, 293, 309, 331, 370, 386, 422, 422, 422, 414, 354, 346, 354, 346,
    354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 439, 439, 439, 439, 439, 439, 439, 315, 354, 354, 354, 354, 354, 354, 354,
    354, 400, 422, 422, 423, 421, 422, 422, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 422, 422, 422, 422, 422,
    422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 353, 354, 354, 354,
    354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 354, 422, 55, 0,
    0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16, 16, 16,
    16, 16, 16, 16, 16, 16, 17, 6, 18, 19, 20, 21, 22, 23, 23, 23, 23, 24, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 6, 23, 23, 25, 23, 23, 23,
    23, 23, 23, 23, 23, 23, 26, 6, 27, 6, 23, 23, 23, 23, 23, 23, 23, 6, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 6, 28, 29, 30, 31, 32,
    33, 34, 35, 36, 23, 23, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 23, 51, 52, 53, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 23, 23, 6, 6, 6, 6, 6,
    6, 6, 54, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54
  "/>

  <!--~
   ! The codepoint to charclass mapping for codepoints above the surrogate block.
  -->
  <xsl:variable name="p:MAP2" as="xs:integer+" select="
    57344, 63744, 64976, 65008, 65536, 983040, 63743, 64975, 65007, 65533, 983039, 1114111, 6, 23, 6, 23, 23, 6
  "/>

  <!--~
   ! The token-set-id to DFA-initial-state mapping.
  -->
  <xsl:variable name="p:INITIAL" as="xs:integer+" select="
    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 2069, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,
    42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59
  "/>

  <!--~
   ! The DFA transition table.
  -->
  <xsl:variable name="p:TRANSITION" as="xs:integer+" select="
    8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941,
    8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941,
    8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 3607, 3584, 3605, 3589, 7800, 8941, 5008, 12228, 3846, 3623, 3639, 3677, 3707, 3724,
    3759, 3708, 5700, 3788, 3813, 3835, 4127, 3819, 3841, 4038, 3862, 3878, 3894, 3876, 3921, 3937, 12188, 3942, 4105, 3958, 3984, 3968, 4000, 3905, 4168,
    12257, 3772, 4026, 4066, 4094, 12218, 12228, 12223, 4082, 3691, 4121, 4143, 4159, 4184, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941,
    4186, 4310, 4324, 9693, 8321, 8941, 5008, 12228, 3846, 3623, 3639, 3677, 3707, 3724, 3759, 3708, 5700, 3788, 3813, 3835, 4127, 3819, 3841, 4038, 3862, 3878,
    3894, 3876, 3921, 3937, 12188, 3942, 4105, 3958, 3984, 3968, 4000, 3905, 4168, 12257, 3772, 4026, 4066, 4094, 12218, 12228, 12223, 4082, 3691, 4121, 4143,
    4159, 4184, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 7161, 8941, 8657, 9804, 8941, 5008, 12228, 3846, 4202, 3639, 3677, 3707,
    3724, 3759, 3708, 5700, 3788, 3813, 3835, 4127, 3819, 3841, 4038, 3862, 3878, 3894, 3876, 3921, 3937, 12188, 3942, 4105, 3958, 3984, 3968, 4000, 3905, 4168,
    12257, 3772, 4026, 4066, 4094, 12218, 12228, 12223, 4082, 3691, 4121, 4143, 4159, 4184, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941,
    4218, 3738, 6849, 5738, 8321, 8941, 5008, 12228, 3846, 3623, 3639, 3677, 3707, 3724, 3759, 3708, 5700, 3788, 3813, 3835, 4127, 3819, 3841, 4038, 3862, 3878,
    3894, 3876, 3921, 3937, 12188, 3942, 4105, 3958, 3984, 3968, 4000, 3905, 4168, 12257, 3772, 4026, 4066, 4094, 12218, 12228, 12223, 4082, 3691, 4121, 4143,
    4159, 4184, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4234, 4275, 4947, 4296, 8321, 8941, 5008, 12228, 3846, 3623, 3639, 3677, 3707,
    3724, 3759, 3708, 5700, 3788, 3813, 3835, 4127, 3819, 3841, 4038, 3862, 3878, 3894, 3876, 3921, 3937, 12188, 3942, 4105, 3958, 3984, 3968, 4000, 3905, 4168,
    12257, 3772, 4026, 4066, 4094, 12218, 12228, 12223, 4082, 3691, 4121, 4143, 4159, 4184, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941,
    4186, 3738, 8941, 5738, 8321, 8941, 5008, 12228, 3846, 3623, 3639, 3677, 3707, 3724, 3759, 3708, 5700, 3788, 3813, 3835, 4127, 3819, 3841, 4038, 3862, 3878,
    3894, 3876, 3921, 3937, 12188, 3942, 4105, 3958, 3984, 3968, 4000, 3905, 4168, 12257, 3772, 4026, 4066, 4094, 12218, 12228, 12223, 4082, 3691, 4121, 4143,
    4159, 4184, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 7293, 8941, 11836, 9199, 8941, 5008, 12228, 3846, 4351, 3639, 3677,
    3707, 3724, 3759, 3708, 5700, 3788, 3813, 3835, 4127, 3819, 3841, 4038, 3862, 3878, 3894, 3876, 3921, 3937, 12188, 3942, 4105, 3958, 3984, 3968, 4000, 3905,
    4168, 12257, 3772, 4026, 4066, 4094, 12218, 12228, 12223, 4082, 3691, 4121, 4143, 4159, 4184, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941,
    8941, 4379, 4367, 4395, 4410, 11743, 8941, 5008, 12228, 3846, 4450, 3639, 3677, 3707, 3724, 3759, 3708, 5700, 3788, 3813, 3835, 4127, 3819, 3841, 4038,
    3862, 3878, 3894, 3876, 3921, 3937, 12188, 3942, 4105, 3958, 3984, 3968, 4000, 3905, 4168, 12257, 3772, 4026, 4066, 4094, 12218, 12228, 12223, 4082, 3691,
    4121, 4143, 4159, 4184, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4466, 4507, 4516, 4532, 10773, 8941, 5008, 12228, 3846, 4572,
    3639, 3677, 3707, 3724, 3759, 3708, 5700, 3788, 3813, 3835, 4127, 3819, 3841, 4038, 3862, 3878, 3894, 3876, 3921, 3937, 12188, 3942, 4105, 3958, 3984, 3968,
    4000, 3905, 4168, 12257, 3772, 4026, 4066, 4094, 12218, 12228, 12223, 4082, 3691, 4121, 4143, 4159, 4184, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941,
    8941, 8941, 8941, 10100, 6519, 6527, 4588, 8321, 8941, 5008, 12228, 3846, 3623, 3639, 3677, 3707, 4628, 3759, 3708, 5700, 3788, 3813, 3835, 5761, 3819,
    3841, 4038, 3862, 3878, 3894, 3876, 3921, 3937, 12188, 3942, 4105, 3958, 3984, 3968, 4000, 3905, 4168, 12257, 3772, 4026, 4066, 4094, 12218, 12228, 12223,
    4082, 3691, 4121, 4143, 4159, 4184, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 4424, 4434, 7079, 8321, 8941, 5008, 12228, 3846,
    3623, 3639, 3677, 3707, 3724, 3759, 3708, 4010, 3788, 3813, 3835, 4127, 3819, 3841, 4038, 3862, 3878, 3894, 3876, 3921, 3937, 12188, 3942, 4105, 3958, 3984,
    3968, 4000, 3905, 4168, 12257, 3772, 4026, 4066, 4094, 12218, 12228, 12223, 4082, 3691, 4121, 4143, 4159, 4184, 8941, 8941, 8941, 8941, 8941, 8941, 8941,
    8941, 8941, 8941, 8941, 7855, 4644, 4653, 8690, 8321, 8941, 5008, 12228, 3846, 3623, 3639, 3677, 3707, 3724, 3759, 3708, 5700, 3788, 3813, 3835, 4127, 3819,
    3841, 4038, 3862, 3878, 3894, 3876, 3921, 3937, 12188, 3942, 4105, 3958, 3984, 3968, 4000, 3905, 4168, 12257, 3772, 4026, 4066, 4094, 12218, 12228, 12223,
    4082, 3691, 4121, 4143, 4159, 4184, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 4546, 4556, 8045, 4050, 8941, 8226, 6372, 10180,
    4669, 8941, 4689, 7224, 4691, 4707, 4708, 8471, 8941, 7222, 7224, 9221, 4708, 4708, 7942, 8013, 7224, 7451, 4708, 6903, 8569, 8233, 7255, 8924, 7223, 11542,
    7416, 8230, 7453, 11181, 4725, 4779, 4802, 4839, 7394, 4855, 9539, 6691, 4871, 7445, 7824, 7828, 7701, 6819, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941,
    8941, 8941, 8941, 4186, 3738, 8941, 4898, 4050, 8941, 8226, 6372, 10008, 4669, 8941, 4689, 7224, 4691, 4707, 4708, 11808, 8941, 7222, 7224, 9221, 4708,
    4708, 7942, 8013, 7224, 7451, 4708, 6903, 8230, 8233, 4708, 6903, 7223, 7451, 6391, 8230, 7453, 11771, 8234, 6390, 8232, 12149, 7449, 10073, 9539, 6691,
    7449, 7445, 7824, 7828, 7701, 6819, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 3738, 4928, 10292, 8321, 8941, 8286, 12228,
    3846, 3623, 3639, 3677, 3707, 3724, 3759, 3708, 5700, 3788, 3813, 3835, 4127, 3819, 3841, 4038, 3862, 3878, 3894, 3876, 3921, 3937, 12188, 3942, 4105, 3958,
    3984, 3968, 4000, 3905, 4168, 12257, 3772, 4026, 4066, 4094, 12218, 12228, 12223, 4082, 3691, 4121, 4143, 4159, 4184, 8941, 8941, 8941, 8941, 8941, 8941,
    8941, 8941, 8941, 8941, 8941, 6000, 5991, 8941, 12029, 4050, 8941, 8226, 6372, 11286, 4669, 8941, 4689, 7224, 4691, 4707, 4708, 8544, 8941, 7222, 7224,
    9221, 4708, 4708, 4963, 8013, 7224, 7451, 4708, 6903, 8230, 8233, 4708, 6903, 7223, 7451, 6391, 8230, 7453, 11771, 8234, 6390, 8232, 12149, 7449, 10073,
    9539, 6691, 7449, 7445, 7824, 7828, 7701, 6819, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8192, 4985, 4997, 8877, 8523, 8941, 5927,
    5934, 5217, 5030, 3639, 5046, 5248, 5076, 5116, 5158, 5196, 3788, 5174, 5376, 5398, 5129, 5212, 5318, 5233, 5388, 5279, 5306, 5346, 5362, 5465, 5414, 5290,
    5439, 5263, 5540, 5455, 5626, 5423, 5060, 5142, 5481, 5512, 5185, 5616, 5569, 5564, 5528, 5496, 5556, 5585, 5601, 5642, 8941, 8941, 8941, 8941, 8941, 8941,
    8941, 8941, 8941, 8941, 8941, 4186, 4602, 4612, 9099, 8321, 5661, 5008, 12228, 3846, 3623, 3639, 3677, 3707, 3724, 3759, 3708, 5700, 3788, 3813, 3835, 4127,
    3819, 3841, 4038, 3862, 3878, 3894, 3876, 3921, 3937, 12188, 3942, 4105, 3958, 3984, 3968, 4000, 3905, 4168, 12257, 3772, 4026, 4066, 4094, 12218, 12228,
    12223, 4082, 3691, 4121, 4143, 4159, 4184, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 4912, 5680, 10670, 8321, 5716, 5008,
    12228, 3846, 3623, 3639, 3677, 3707, 3724, 3759, 3708, 5700, 3788, 3813, 3835, 4127, 3819, 3841, 4038, 3862, 3878, 3894, 3876, 3921, 3937, 12188, 3942,
    4105, 3958, 3984, 3968, 4000, 3905, 4168, 12257, 3772, 4026, 4066, 4094, 12218, 12228, 12223, 4082, 3691, 4121, 4143, 4159, 4184, 8941, 8941, 8941, 8941,
    8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 5090, 5100, 6489, 8321, 5735, 5754, 12228, 3846, 3623, 3639, 3677, 3707, 3724, 3759, 3708, 5700, 3788, 3813,
    3835, 4127, 3819, 3841, 4038, 3862, 3878, 3894, 3876, 3921, 3937, 12188, 3942, 4105, 3958, 3984, 3968, 4000, 3905, 4168, 12257, 3772, 4026, 4066, 4094,
    12218, 12228, 12223, 4082, 3691, 4121, 4143, 4159, 4184, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 5777, 5792, 5817, 8321,
    8941, 5008, 12228, 3846, 3623, 3639, 3677, 3707, 3724, 3759, 3708, 5700, 3788, 3813, 3835, 4127, 3819, 3841, 4038, 3862, 3878, 3894, 3876, 3921, 3937,
    12188, 3942, 4105, 3958, 3984, 3968, 4000, 3905, 4168, 12257, 3772, 4026, 4066, 4094, 12218, 12228, 12223, 4082, 3691, 4121, 4143, 4159, 4184, 8941, 8941,
    8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 3738, 8941, 5857, 8321, 8941, 5008, 12228, 3846, 3623, 3639, 3677, 3707, 3724, 3759, 3708, 5700,
    3788, 3813, 3835, 4127, 3819, 3841, 4038, 3862, 3878, 3894, 3876, 3921, 3937, 12188, 3942, 4105, 3958, 3984, 3968, 4000, 3905, 4168, 12257, 3772, 4026,
    4066, 4094, 12218, 12228, 12223, 4082, 3691, 4121, 4143, 4159, 4184, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 7885, 4280,
    11767, 4050, 8941, 8226, 6372, 6392, 4669, 8941, 9835, 7224, 9837, 4707, 4708, 6391, 8941, 5897, 7224, 9899, 4708, 4708, 6245, 8013, 7224, 7451, 4708, 6903,
    8230, 8233, 4708, 6903, 7223, 7451, 6391, 8230, 7453, 11771, 8234, 6390, 8232, 12149, 7449, 10073, 9539, 6691, 7449, 7445, 7824, 7828, 7701, 6819, 8941,
    8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 7885, 4280, 11767, 4050, 8941, 8226, 6372, 8386, 4669, 8941, 9835, 7224, 9837, 4707, 4708,
    9920, 8941, 5897, 7224, 9899, 4708, 4708, 6245, 8013, 7224, 7451, 4708, 6903, 8230, 8233, 4708, 6903, 7223, 7451, 6391, 8230, 7453, 11771, 8234, 6390, 8232,
    12149, 7449, 10073, 9539, 6691, 7449, 7445, 7824, 7828, 7701, 6819, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 7885, 11406,
    5916, 4050, 8941, 8226, 6372, 6392, 4669, 8941, 9835, 7224, 9837, 4707, 4708, 6391, 8941, 5897, 7224, 9899, 4708, 4708, 6245, 8013, 7224, 7451, 4708, 6903,
    8230, 8233, 4708, 6903, 7223, 7451, 6391, 8230, 7453, 11771, 8234, 6390, 8232, 12149, 7449, 10073, 9539, 6691, 7449, 7445, 7824, 7828, 7701, 6819, 8941,
    8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 3738, 5950, 5977, 8321, 8941, 5008, 12228, 3846, 3623, 3639, 3677, 3707, 3724, 3759, 3708,
    5700, 3788, 3813, 3835, 4127, 3819, 3841, 4038, 3862, 3878, 3894, 3876, 3921, 3937, 12188, 3942, 4105, 3958, 3984, 3968, 4000, 3905, 4168, 12257, 3772,
    4026, 4066, 4094, 12218, 12228, 12223, 4082, 3691, 4121, 4143, 4159, 4184, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 5831,
    5841, 5801, 8321, 8941, 5008, 12228, 3846, 3623, 3639, 3677, 3707, 3724, 3759, 3708, 5700, 3788, 3813, 3835, 4127, 3819, 3841, 4038, 3862, 3878, 3894, 3876,
    3921, 3937, 12188, 3942, 4105, 3958, 3984, 3968, 4000, 3905, 4168, 12257, 3772, 4026, 4066, 4094, 12218, 12228, 12223, 4082, 3691, 4121, 4143, 4159, 4184,
    8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 7191, 6016, 6026, 6042, 4050, 6822, 6078, 6105, 6146, 4669, 8941, 9835, 7224, 9837, 4707,
    4708, 6391, 5664, 6174, 7224, 9732, 4708, 4708, 6195, 6215, 8970, 10908, 6664, 8494, 8230, 11466, 4708, 6240, 8594, 7451, 6265, 6290, 6314, 6340, 8234,
    6390, 8232, 12149, 7449, 10073, 9539, 6691, 7449, 7445, 7824, 7828, 7701, 6819, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186,
    7885, 4280, 11767, 4050, 8941, 8226, 6372, 6392, 4669, 8941, 9835, 7224, 9837, 4707, 4708, 6391, 8941, 5897, 7224, 9899, 4708, 4708, 6245, 8013, 7224, 7451,
    4708, 6903, 6365, 8233, 6388, 6903, 7223, 7451, 6391, 8230, 7453, 11771, 8234, 6390, 8232, 12149, 7449, 10073, 11979, 6408, 7449, 7445, 7824, 7828, 7701,
    6819, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 8100, 6458, 6471, 5330, 8941, 8226, 9620, 6130, 6505, 8941, 6543, 7224, 9837,
    6559, 4708, 6391, 8941, 6599, 6634, 9899, 6650, 10128, 6245, 8013, 7224, 6688, 4708, 6707, 8230, 8233, 4708, 7914, 6728, 7451, 6764, 6789, 7453, 6780, 8828,
    10995, 8232, 12149, 7449, 10073, 11032, 4813, 7449, 7445, 7824, 7828, 6805, 6819, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186,
    8157, 8167, 6838, 4050, 6860, 6884, 6372, 6900, 6919, 9687, 6945, 6949, 9837, 6965, 6618, 6391, 8941, 5897, 7224, 9899, 4708, 4708, 6245, 10866, 7224, 8437,
    4708, 6903, 8230, 10472, 4708, 6983, 7004, 10203, 6391, 8230, 7453, 11771, 8234, 6390, 8232, 12149, 7449, 9304, 7026, 9294, 7449, 7445, 7824, 7828, 7701,
    6819, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 7042, 7052, 7068, 4050, 5961, 6929, 7095, 7147, 7183, 5645, 11264, 7131, 7207,
    7241, 11152, 7279, 7315, 7339, 7380, 7432, 6119, 7469, 7509, 10524, 6179, 12001, 8366, 6903, 9438, 8233, 7533, 9857, 6422, 7451, 7555, 7586, 7626, 7642,
    9268, 7732, 9660, 12097, 7677, 7717, 10357, 8127, 7773, 7445, 9630, 7816, 7701, 6819, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941,
    4186, 7885, 11443, 7844, 7871, 8941, 8259, 6372, 7911, 4669, 8941, 9835, 7224, 9837, 4707, 4708, 6391, 8941, 5897, 7224, 7930, 4708, 7539, 6245, 8013, 7224,
    7451, 4708, 10745, 8230, 11606, 4708, 7964, 7223, 7451, 6391, 8230, 7453, 11771, 8234, 6390, 8232, 12149, 7449, 10073, 9539, 6691, 7449, 7445, 9763, 8614,
    7985, 6819, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 9129, 9139, 8034, 4050, 8941, 8226, 6372, 6392, 4669, 8941, 9835, 7224,
    9837, 4707, 4708, 6391, 8941, 5897, 7224, 9899, 4708, 4708, 6245, 8013, 7224, 7451, 4708, 6903, 8230, 8233, 4708, 6903, 7223, 7451, 6391, 8230, 7453, 11771,
    8061, 8086, 8116, 9341, 7449, 10073, 9539, 6691, 7449, 7445, 7824, 4751, 7701, 6819, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186,
    7885, 4280, 11767, 8143, 8941, 3650, 11342, 6392, 8183, 8941, 9835, 7224, 11883, 4707, 4708, 8208, 8941, 5897, 7224, 9899, 4708, 4708, 6245, 8013, 7224,
    7451, 4708, 6903, 8230, 7010, 4708, 8250, 7223, 7451, 6391, 8230, 7453, 11771, 8234, 6390, 11701, 12130, 7449, 10073, 9539, 6691, 7449, 7445, 7824, 7828,
    7701, 6819, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 7948, 9484, 9495, 8275, 4050, 11401, 8808, 12072, 6392, 4669, 8309, 8337,
    7656, 8750, 8360, 8382, 11730, 4969, 5897, 7224, 8402, 4708, 11072, 6245, 7123, 7224, 9066, 4708, 6903, 8230, 8430, 10885, 11855, 8453, 8487, 8510, 8230,
    8539, 8560, 8234, 6390, 8232, 12149, 7449, 9350, 8585, 6691, 7449, 7690, 8610, 7828, 8630, 6819, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941,
    8941, 4186, 10255, 10265, 8673, 6158, 8684, 9375, 8344, 6392, 4669, 8941, 9835, 8706, 3661, 8726, 4708, 11388, 8941, 8742, 8766, 9899, 8786, 4708, 6245,
    8013, 7224, 7451, 4708, 6903, 8230, 8233, 4708, 6903, 8824, 9519, 6391, 8230, 7453, 7484, 7661, 11160, 8232, 12149, 7449, 10073, 9539, 6691, 8844, 9776,
    7824, 4739, 7701, 6819, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 10700, 10710, 8860, 4050, 8941, 10933, 9398, 6392, 4669,
    8941, 8893, 5900, 10958, 8917, 7263, 8000, 8940, 8957, 11598, 9899, 8992, 9015, 8217, 9987, 7225, 10225, 4708, 9033, 8230, 8233, 4708, 6903, 7223, 7451,
    6391, 8230, 7453, 11771, 8234, 6390, 8232, 11511, 6609, 9058, 9539, 6691, 7449, 7445, 7824, 7828, 7701, 6819, 8941, 8941, 8941, 8941, 8941, 8941, 8941,
    8941, 8941, 8941, 8941, 4186, 9584, 9594, 9082, 9115, 9155, 9171, 6298, 9187, 4669, 8941, 9835, 9215, 9837, 4707, 9237, 9240, 8941, 5897, 7224, 9899, 4708,
    4708, 6712, 8013, 8976, 8464, 6672, 11911, 9256, 9284, 9328, 9366, 9391, 10479, 6391, 7493, 9414, 9454, 11573, 9470, 9511, 9535, 9555, 4823, 9610, 9646,
    7449, 7445, 6324, 7828, 7364, 6819, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 3743, 4249, 4259, 9676, 4050, 7323, 9709, 9748, 9792,
    4669, 8941, 9835, 7224, 9820, 4707, 4708, 9853, 7299, 5897, 7224, 6748, 4708, 4708, 9873, 8013, 9893, 7451, 9915, 6903, 8230, 8233, 4708, 6903, 9936, 12122,
    9974, 8230, 7453, 11771, 8234, 6390, 10024, 12149, 10040, 7610, 10068, 6691, 7449, 7445, 7824, 7828, 11672, 6819, 8941, 8941, 8941, 8941, 8941, 8941, 8941,
    8941, 8941, 8941, 8941, 4186, 7885, 12278, 10089, 4050, 8941, 8226, 6372, 6392, 4669, 8941, 10459, 8018, 8710, 10116, 10328, 10810, 8941, 5897, 7224, 9899,
    4708, 4708, 6274, 8013, 10154, 7451, 10176, 6903, 8230, 10196, 9017, 6903, 7223, 7451, 6391, 8230, 7453, 11771, 8234, 6390, 8232, 12149, 7449, 10073, 9539,
    6691, 7449, 7445, 7824, 7828, 7701, 6819, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 7885, 4280, 11767, 4050, 8871, 6062,
    10405, 6392, 4669, 8941, 9835, 7224, 9837, 4707, 4708, 6391, 8941, 5897, 7224, 9899, 4708, 4708, 6245, 8013, 7224, 7451, 4708, 6903, 8230, 8233, 4708, 6903,
    7223, 7451, 6391, 8230, 7453, 11771, 10219, 10241, 8232, 12149, 7449, 10073, 9539, 6691, 7449, 7445, 7824, 7828, 7701, 6819, 8941, 8941, 8941, 8941, 8941,
    8941, 8941, 8941, 8941, 8941, 8941, 4186, 4481, 4491, 10281, 4050, 7167, 10308, 10344, 7788, 4669, 8941, 10398, 10421, 10444, 10495, 4708, 10511, 8941,
    10540, 7224, 10160, 11633, 4708, 7969, 8013, 6089, 7451, 10382, 6903, 8230, 8233, 4708, 6903, 7223, 7451, 6391, 10556, 6436, 11771, 8234, 6390, 8232, 11306,
    9948, 10579, 11549, 7600, 7449, 7445, 10611, 10603, 7701, 6819, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 10627, 10637, 10653,
    10686, 4939, 10726, 6372, 10742, 10761, 6199, 10789, 12065, 9837, 10826, 10989, 6391, 8941, 5897, 7224, 9899, 4708, 4708, 6988, 11335, 8901, 10000, 9958,
    10853, 8230, 10901, 6442, 10924, 10949, 10974, 7110, 8230, 7453, 4786, 11489, 4882, 8232, 12149, 11011, 10073, 8999, 11027, 10801, 11048, 7824, 7828, 7701,
    6819, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 6249, 7570, 11088, 11101, 4050, 6053, 4335, 11139, 11176, 4669, 11197, 11226, 12055,
    11249, 11302, 11063, 11322, 9877, 11358, 6741, 10370, 11422, 4709, 11438, 11459, 11482, 11279, 11505, 8645, 11527, 11373, 8414, 8798, 11565, 9312, 6391,
    11589, 11622, 9429, 7353, 9570, 11659, 11688, 7449, 10073, 9539, 8070, 11935, 11717, 11759, 7828, 11787, 6819, 8941, 8941, 8941, 8941, 8941, 8941, 8941,
    8941, 8941, 8941, 8941, 4186, 7747, 7757, 11824, 4050, 8941, 9042, 6372, 11852, 4669, 8941, 9835, 7224, 9837, 4707, 4708, 6391, 7517, 11871, 7224, 11899,
    11802, 11643, 6245, 8013, 7224, 7451, 4708, 6903, 8230, 8233, 4708, 6903, 11927, 11959, 6391, 8230, 7453, 11771, 8234, 6390, 11951, 11975, 7449, 10073,
    9539, 6691, 10876, 11995, 7824, 4763, 7701, 6819, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 7885, 4280, 11767, 4050, 8941,
    6583, 10428, 6392, 12017, 8941, 12045, 7224, 9837, 12088, 4708, 6391, 6482, 5897, 9723, 9899, 6967, 4708, 6245, 8013, 7224, 7451, 4708, 6903, 8230, 8233,
    4708, 6903, 7223, 7451, 6391, 8230, 7453, 11771, 8234, 6390, 8232, 12149, 7449, 10073, 9539, 6691, 7449, 7445, 7824, 7828, 7701, 6819, 8941, 8941, 8941,
    8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 7885, 4280, 11767, 4050, 8941, 8226, 10318, 10837, 4669, 8941, 9835, 7224, 9837, 4707, 4708, 6391,
    8941, 5897, 7224, 9899, 4708, 4708, 6245, 8013, 7224, 7451, 4708, 6903, 6349, 8770, 7405, 6574, 7223, 7451, 6391, 8230, 7453, 11771, 8234, 6390, 8232,
    12149, 7449, 10073, 9539, 6691, 7449, 7445, 7824, 7828, 7701, 6819, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 7885, 4280,
    11767, 4050, 9093, 7895, 10563, 6392, 4669, 8941, 9835, 7224, 11233, 4707, 4708, 10052, 8941, 5897, 7224, 9899, 4708, 4708, 6245, 8013, 7224, 7451, 4708,
    6903, 8230, 8233, 4708, 6903, 7223, 7451, 6391, 8230, 7453, 11771, 8234, 6390, 8232, 12149, 7449, 10073, 9539, 6691, 7449, 7445, 7824, 7828, 7701, 6819,
    8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 7885, 4280, 11767, 4050, 8941, 8226, 6224, 10138, 4669, 8941, 9835, 7224, 9837,
    4707, 4708, 6391, 8941, 5897, 7224, 9899, 4708, 4708, 6245, 11210, 12113, 10587, 12146, 6903, 8230, 8233, 4708, 6903, 7223, 7451, 6391, 8230, 7453, 11771,
    8234, 6390, 8232, 12149, 7449, 10073, 9539, 6691, 7449, 7445, 7824, 7828, 7701, 6819, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941,
    5719, 12165, 10664, 5738, 8321, 8941, 5691, 8293, 3846, 3623, 3639, 5013, 3707, 3724, 5014, 3708, 5700, 3788, 3813, 3835, 4127, 3819, 3841, 4038, 3862,
    3878, 3894, 3876, 3921, 3937, 12188, 3942, 4105, 3958, 3984, 3968, 4000, 3905, 4168, 12257, 3772, 4026, 4066, 4094, 12218, 12228, 12223, 4082, 3691, 4121,
    4143, 4159, 4184, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 5871, 5881, 6868, 8321, 8941, 12181, 12228, 3846, 3623, 3639,
    3677, 3707, 3724, 3759, 3708, 5700, 3788, 3813, 3835, 4127, 3819, 3841, 4038, 3862, 3878, 3894, 3876, 3921, 3937, 12188, 3942, 4105, 3958, 3984, 3968, 4000,
    3905, 4168, 12257, 3772, 4026, 4066, 4094, 12218, 12228, 12223, 4082, 3691, 4121, 4143, 4159, 4184, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941,
    8941, 8941, 4186, 11113, 11123, 3797, 8321, 8941, 5008, 12228, 3846, 3623, 3639, 12204, 3707, 3724, 12244, 3708, 5700, 3788, 3813, 3835, 4127, 3819, 3841,
    4038, 3862, 3878, 3894, 3876, 3921, 3937, 12188, 3942, 4105, 3958, 3984, 3968, 4000, 3905, 4168, 12257, 3772, 4026, 4066, 4094, 12218, 12228, 12223, 4082,
    3691, 4121, 4143, 4159, 4184, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 4186, 3738, 8941, 8941, 4050, 8941, 8226, 6372, 6392, 4669,
    8941, 4689, 7224, 4691, 4707, 4708, 6391, 8941, 7222, 7224, 9221, 4708, 4708, 6245, 8013, 7224, 7451, 4708, 6903, 8230, 8233, 4708, 6903, 7223, 7451, 6391,
    8230, 7453, 11771, 8234, 6390, 8232, 12149, 7449, 10073, 9539, 6691, 7449, 7445, 7824, 7828, 7701, 6819, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941,
    8941, 8941, 8941, 8941, 12273, 8941, 5738, 4673, 8941, 5008, 12228, 3846, 12294, 3639, 5013, 3707, 3724, 5014, 3708, 5700, 3788, 3813, 3835, 4127, 3819,
    3841, 4038, 3862, 3878, 3894, 3876, 3921, 3937, 12188, 3942, 4105, 3958, 3984, 3968, 4000, 3905, 4168, 12257, 3772, 4026, 4066, 4094, 12218, 12228, 12223,
    4082, 3691, 4121, 4143, 4159, 4184, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 8941, 10300, 10300, 10300, 10300, 10312, 10300, 10300,
    10300, 10300, 10300, 10300, 10300, 10300, 10300, 10300, 10300, 10300, 0, 134144, 0, 0, 10300, 10300, 10300, 10300, 10300, 10300, 10300, 10300, 10300, 10300,
    10300, 10300, 10300, 10300, 10300, 10300, 69, 10300, 220160, 0, 69, 69, 0, 0, 0, 0, 0, 0, 0, 0, 194560, 0, 201728, 202752, 0, 0, 208896, 210944, 212992, 0,
    218112, 221184, 0, 0, 235520, 0, 0, 0, 0, 0, 0, 0, 104, 104, 104, 183, 104, 104, 104, 104, 104, 104, 324, 104, 104, 104, 104, 104, 104, 104, 12619, 289, 0,
    178, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 194560, 140288, 140288, 140288, 229376, 140288, 140288, 193536,
    140288, 217088, 140288, 140288, 140288, 229376, 140288, 140288, 193536, 140288, 140288, 201728, 202752, 140288, 204800, 140288, 208896, 140288, 210944,
    212992, 140288, 140288, 140288, 218112, 140288, 221184, 221184, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 235520, 140288,
    140288, 140288, 0, 0, 0, 0, 2121, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 67, 0, 0, 69, 0, 225, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288,
    140288, 140288, 140288, 194560, 140288, 140288, 140288, 140288, 200704, 206848, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 0, 207872,
    0, 0, 179200, 189440, 0, 0, 0, 0, 215040, 0, 0, 0, 0, 0, 0, 0, 0, 0, 111616, 111616, 0, 0, 134144, 0, 0, 140288, 0, 140288, 179200, 140288, 140288, 140288,
    140288, 140288, 140288, 189440, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 199680, 140288, 140288, 140288, 140288, 140288, 199680, 140288,
    140288, 140288, 140288, 140288, 211968, 214016, 215040, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 0,
    134144, 181248, 205824, 0, 0, 0, 183296, 138240, 140288, 140288, 140288, 183296, 140288, 140288, 140288, 140288, 140288, 192512, 140288, 140288, 140288,
    140288, 140288, 203776, 140288, 140288, 209920, 140288, 219136, 140288, 140288, 140288, 140288, 140288, 140288, 230400, 231424, 140288, 233472, 140288,
    140288, 140288, 140288, 140288, 140288, 183296, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 186368, 140288, 140288, 191488, 140288,
    140288, 140288, 140288, 140288, 140288, 230400, 231424, 140288, 233472, 140288, 140288, 140288, 0, 0, 0, 0, 0, 0, 238592, 0, 236544, 0, 140288, 180224,
    140288, 140288, 185344, 140288, 140288, 140288, 140288, 140288, 195584, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 0, 140288, 140288, 140288,
    140288, 140288, 140288, 140288, 140288, 196608, 140288, 140288, 140288, 140288, 140288, 222208, 140288, 140288, 226304, 140288, 140288, 232448, 140288,
    191488, 0, 0, 140288, 140288, 226304, 140288, 140288, 232448, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 196608, 0, 0, 0,
    140288, 140288, 140288, 186368, 140288, 140288, 191488, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 235520, 140288, 140288,
    140288, 135168, 373, 0, 227328, 140288, 182272, 140288, 140288, 140288, 197632, 207872, 216064, 223232, 140288, 227328, 140288, 140288, 140288, 140288, 0,
    136192, 234496, 0, 0, 192512, 0, 203776, 0, 0, 0, 0, 69, 69, 69, 2121, 2121, 2121, 2121, 76, 77, 78, 0, 0, 182272, 140288, 140288, 140288, 197632, 207872,
    216064, 223232, 140288, 227328, 140288, 140288, 140288, 0, 140288, 187392, 140288, 190464, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288,
    140288, 190464, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 237568, 140288, 187392, 140288, 140288, 140288, 140288, 140288, 140288,
    236544, 140288, 238592, 0, 0, 196608, 0, 226304, 0, 0, 140288, 217088, 140288, 140288, 140288, 229376, 140288, 140288, 140288, 140288, 140288, 140288,
    140288, 140288, 140288, 140288, 0, 0, 140288, 179200, 140288, 140288, 140288, 140288, 178176, 140288, 140288, 140288, 140288, 228352, 178176, 140288,
    140288, 140288, 140288, 228352, 140288, 198656, 224256, 140288, 140288, 198656, 224256, 140288, 188416, 140288, 188416, 140288, 140288, 140288, 140288,
    140288, 140288, 140288, 0, 0, 0, 206848, 184320, 177152, 140288, 184320, 140288, 225280, 225280, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 69, 0, 220160, 0,
    69, 69, 0, 76, 0, 0, 0, 0, 0, 0, 194560, 0, 201728, 202752, 0, 16384, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 69, 16384, 0, 0, 17408, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 69, 0, 0, 0, 0, 2121, 78, 0, 0, 78, 78, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 116, 135, 116, 116, 116, 17408, 0, 0, 0, 2121, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 104, 123, 104, 104, 104, 0, 0, 0, 0, 17408, 17408, 17408, 17408, 17408, 17408, 17408, 0, 0, 134144, 0, 0, 0, 0, 2121, 0, 0, 0, 0, 0, 81, 81,
    81, 81, 81, 81, 14417, 14417, 14417, 14417, 14417, 14417, 14417, 14417, 14417, 0, 0, 0, 0, 0, 0, 0, 104, 104, 181, 104, 104, 104, 104, 196, 201, 220160, 0,
    69, 69, 0, 0, 77, 0, 0, 0, 0, 0, 194560, 0, 201728, 202752, 61, 61, 61, 61, 2122, 61, 61, 61, 18493, 18493, 61, 61, 61, 61, 61, 18493, 61, 61, 61, 61, 61,
    61, 61, 61, 61, 61, 70, 18493, 61, 61, 61, 18493, 61, 61, 18493, 18493, 18493, 18493, 18493, 61, 61, 18493, 61, 18493, 18493, 61, 18493, 18493, 18493,
    18493, 18493, 18493, 18493, 18493, 0, 0, 134144, 0, 0, 0, 0, 2121, 0, 0, 0, 0, 0, 22528, 22528, 22528, 22528, 22528, 22528, 22528, 22528, 22528, 22528,
    22528, 0, 0, 0, 0, 0, 220160, 0, 147, 147, 0, 0, 0, 0, 0, 0, 0, 0, 194560, 0, 201728, 202752, 0, 0, 0, 0, 20480, 0, 0, 0, 0, 0, 0, 0, 0, 0, 69, 0, 0, 0, 0,
    2121, 78, 0, 0, 78, 78, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 118, 137, 118, 118, 118, 20480, 20480, 20480, 0, 2121, 20480, 20480, 20480, 0, 20480,
    20480, 20480, 20480, 20480, 20480, 20480, 20480, 20480, 20480, 20480, 0, 0, 0, 0, 0, 20480, 0, 20480, 20480, 0, 0, 0, 20480, 0, 0, 20480, 0, 0, 134144, 0,
    0, 0, 0, 2121, 0, 0, 0, 0, 0, 24576, 24576, 24576, 24576, 24576, 24576, 24576, 24576, 24576, 24576, 24576, 0, 0, 0, 0, 0, 220160, 0, 69, 273408, 273408, 0,
    0, 0, 0, 0, 0, 0, 194560, 0, 201728, 202752, 0, 21504, 21504, 21504, 12410, 12410, 12410, 12410, 12410, 12410, 12410, 0, 0, 134144, 0, 0, 0, 0, 2121, 0, 0,
    0, 0, 0, 33874, 33874, 33874, 33874, 33874, 33874, 33874, 33874, 33874, 33874, 33874, 0, 0, 0, 0, 0, 221184, 140288, 140288, 140288, 140288, 140288, 140288,
    140288, 140288, 140288, 235520, 140288, 140288, 140288, 0, 12288, 0, 23552, 0, 0, 2121, 0, 23552, 0, 0, 23552, 23552, 23552, 23552, 23552, 23552, 23552,
    23552, 23552, 23552, 23552, 0, 0, 0, 0, 0, 0, 0, 69, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 139264, 0, 0, 0, 178, 104, 104, 104, 104, 104, 104, 104,
    104, 104, 104, 104, 104, 104, 104, 0, 0, 225, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 453, 661, 104, 104, 104, 104,
    104, 104, 104, 104, 104, 104, 104, 104, 672, 123, 123, 104, 815, 104, 104, 104, 104, 123, 819, 123, 123, 123, 123, 104, 104, 816, 817, 104, 104, 123, 123,
    820, 821, 123, 123, 104, 104, 104, 104, 818, 104, 123, 123, 123, 123, 822, 123, 104, 104, 123, 675, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123,
    123, 0, 0, 657, 0, 0, 104, 104, 104, 104, 0, 104, 104, 104, 104, 104, 691, 104, 692, 693, 104, 104, 104, 104, 104, 123, 123, 123, 765, 123, 123, 123, 123,
    123, 123, 0, 104, 104, 104, 734, 104, 104, 104, 104, 104, 104, 123, 123, 123, 123, 123, 702, 123, 703, 704, 123, 123, 123, 123, 123, 0, 104, 711, 727, 123,
    123, 123, 0, 731, 104, 104, 104, 104, 104, 104, 104, 104, 104, 741, 774, 104, 104, 104, 104, 104, 104, 104, 104, 123, 783, 123, 123, 123, 123, 123, 123,
    123, 123, 123, 123, 682, 123, 123, 123, 0, 0, 0, 0, 0, 0, 25741, 25741, 25741, 25741, 25741, 25741, 25741, 0, 0, 134144, 0, 0, 0, 0, 2121, 0, 0, 0, 0, 0,
    36864, 36864, 36864, 36864, 36864, 36864, 0, 0, 27751, 27751, 27751, 27751, 27751, 27751, 27751, 27751, 27751, 0, 0, 0, 0, 0, 0, 0, 163, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 17408, 0, 0, 0, 0, 0, 17408, 123, 123, 123, 123, 374, 374, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 383, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2123, 0, 0, 0, 0, 0,
    29696, 29696, 29696, 29696, 29696, 29696, 29759, 29696, 29696, 29759, 29696, 29696, 29759, 0, 0, 0, 0, 0, 0, 0, 140288, 140288, 140288, 140288, 140288,
    140288, 140288, 140288, 140288, 140288, 140288, 194560, 140288, 140288, 140288, 220160, 0, 273557, 148, 0, 0, 0, 0, 0, 0, 0, 0, 194560, 0, 201728, 202752,
    0, 178, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 194737, 140465, 140465, 140465, 200881, 207025, 140465,
    140465, 140465, 140465, 140465, 140465, 140465, 140465, 177376, 140512, 184544, 221361, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 140465,
    140465, 235697, 140465, 140465, 140465, 0, 0, 0, 0, 2121, 0, 0, 0, 0, 0, 38995, 38995, 38995, 38995, 38995, 38995, 38995, 38995, 38995, 38995, 38995, 0, 0,
    0, 0, 0, 225, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 194784, 140512, 140512, 140512, 140512, 189664,
    140512, 140512, 140512, 140512, 140512, 140512, 140512, 199904, 140512, 140512, 140512, 140512, 200928, 207072, 140512, 140512, 140512, 140512, 140512,
    140512, 140512, 140512, 0, 207872, 140512, 201952, 202976, 140512, 205024, 140512, 209120, 140512, 211168, 213216, 140512, 140512, 140512, 218336, 140512,
    221408, 140288, 0, 140465, 179377, 140465, 140465, 140465, 140465, 140465, 140465, 189617, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 140465,
    237745, 140512, 187616, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 235744, 140512, 140512, 140512, 135168, 0, 0, 140512,
    140512, 212192, 214240, 215264, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 0, 134144, 181248, 205824,
    0, 0, 0, 183296, 138240, 140465, 140465, 140465, 183473, 140465, 140465, 140465, 140465, 140465, 192689, 140465, 140465, 201905, 202929, 140465, 204977,
    140465, 209073, 140465, 211121, 213169, 140465, 140465, 140465, 218289, 140465, 140465, 226481, 140465, 140465, 232625, 140465, 140512, 140512, 140512,
    140512, 140512, 140512, 140512, 140512, 196832, 230577, 231601, 140465, 233649, 140465, 140465, 140465, 140512, 140512, 140512, 183520, 140512, 140512,
    140512, 140512, 140512, 140512, 236768, 140512, 238816, 0, 0, 196608, 0, 226304, 0, 0, 192736, 140512, 140512, 140512, 140512, 140512, 204000, 140512,
    140512, 210144, 140512, 219360, 140512, 140512, 140512, 140512, 0, 136192, 234496, 0, 0, 192512, 0, 203776, 0, 0, 0, 0, 69, 69, 69, 2121, 2121, 2121, 2121,
    76, 77, 78, 0, 153, 140512, 140512, 230624, 231648, 140512, 233696, 140512, 140512, 140512, 0, 0, 0, 0, 0, 0, 238592, 0, 236544, 0, 140465, 180401, 140465,
    140465, 185521, 140465, 140465, 140465, 140465, 140465, 195761, 140465, 140465, 199857, 140465, 140465, 140465, 140465, 140465, 212145, 214193, 215217,
    140465, 140465, 140465, 140465, 140465, 203953, 140465, 140465, 210097, 140465, 219313, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 140465,
    140465, 140465, 0, 0, 140512, 179424, 140512, 140512, 140512, 140512, 185568, 140512, 140512, 140512, 140512, 140512, 195808, 140512, 140512, 140512,
    140512, 140512, 140512, 140512, 0, 0, 0, 206848, 184320, 177329, 140465, 184497, 140465, 0, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 140465,
    196785, 140465, 140465, 140465, 140465, 140465, 222385, 0, 0, 0, 140465, 140465, 140465, 186545, 140465, 140465, 191665, 140465, 140465, 140465, 140465,
    140465, 140465, 140465, 140465, 140465, 140465, 140465, 236721, 140465, 238769, 140512, 180448, 227328, 140465, 182449, 140465, 140465, 140465, 197809,
    208049, 216241, 223409, 140465, 227505, 140465, 140465, 140465, 140512, 140512, 140512, 229376, 140465, 140465, 193713, 140465, 217265, 140465, 140465,
    140465, 229553, 140512, 140512, 193760, 182496, 140512, 140512, 140512, 197856, 208096, 216288, 223456, 140512, 227552, 140512, 140512, 140512, 0, 140465,
    187569, 140465, 190641, 140465, 140465, 140465, 140465, 140465, 140465, 140465, 140512, 140512, 190688, 140512, 140512, 140512, 140512, 140512, 222432,
    140512, 140512, 226528, 140512, 140512, 232672, 140512, 191488, 0, 0, 140512, 217312, 140512, 140512, 140512, 229600, 140465, 140465, 140465, 140465,
    140465, 140465, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 140512, 0, 140465, 140465, 140465, 140465, 140465, 140465, 140512,
    140512, 178353, 140465, 140465, 140465, 140465, 228529, 178400, 140512, 140512, 140512, 140512, 228576, 140465, 198833, 224433, 140465, 140512, 198880,
    224480, 140512, 188593, 140465, 188640, 140512, 140465, 140512, 140465, 140512, 140465, 140512, 140512, 140512, 237792, 0, 140465, 140465, 140465, 140465,
    140465, 140465, 140465, 140465, 140465, 140465, 140512, 140512, 140512, 186592, 140512, 140512, 191712, 140512, 140512, 140512, 140512, 225457, 225504, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 286, 0, 0, 0, 34816, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 386, 0, 0, 36864, 36965, 36965, 36965, 36965, 36965,
    36965, 36965, 36965, 36965, 36965, 0, 0, 0, 0, 0, 0, 0, 140288, 140466, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 235520,
    140288, 140288, 140288, 135168, 0, 0, 15360, 35840, 39936, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 108544, 69, 0, 0, 0, 40960, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 134144, 0, 0, 0, 0, 0, 0, 37888, 0, 0, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 0, 12288, 140288, 179200,
    140288, 140288, 0, 0, 41984, 0, 2121, 0, 0, 0, 0, 0, 0, 0, 0, 41984, 0, 41984, 0, 0, 0, 0, 0, 0, 0, 41984, 0, 0, 0, 0, 0, 0, 0, 0, 45056, 0, 45056, 0, 0,
    134144, 0, 0, 0, 0, 0, 0, 41984, 41984, 41984, 41984, 41984, 41984, 41984, 0, 0, 134144, 0, 0, 0, 0, 2121, 0, 0, 0, 0, 0, 45056, 45056, 45056, 45056, 45056,
    45056, 45056, 45056, 45056, 45056, 45056, 0, 0, 0, 0, 0, 0, 0, 0, 0, 43008, 43008, 43008, 43008, 43008, 43008, 43008, 0, 0, 134144, 0, 0, 0, 0, 2121, 0, 0,
    0, 0, 0, 109665, 109665, 109665, 109665, 109665, 109665, 109665, 109665, 109665, 109665, 109665, 0, 0, 0, 0, 0, 289, 389, 104, 104, 104, 104, 104, 104, 104,
    104, 104, 104, 104, 104, 104, 104, 316, 104, 104, 105, 105, 105, 105, 124, 124, 124, 124, 124, 124, 124, 0, 0, 0, 0, 0, 0, 0, 140465, 140465, 140465,
    140465, 140465, 140465, 140465, 140465, 140465, 223, 140512, 140512, 140512, 140512, 140512, 140512, 0, 0, 44032, 44032, 44032, 44032, 44032, 44032, 44032,
    44032, 44032, 0, 0, 0, 0, 0, 0, 159, 0, 164, 0, 167, 0, 169, 0, 0, 0, 0, 0, 0, 0, 44032, 44032, 44032, 44032, 44032, 44032, 44032, 0, 0, 134144, 0, 0, 0, 0,
    2121, 0, 0, 0, 62, 62, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 69, 0, 0, 0, 0, 65, 2121, 78, 65, 0, 78, 78, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 106,
    125, 106, 106, 106, 106, 106, 106, 106, 125, 125, 125, 125, 125, 125, 125, 0, 0, 0, 0, 0, 0, 160, 0, 165, 0, 0, 0, 0, 0, 0, 0, 104, 104, 104, 104, 104, 190,
    104, 104, 104, 0, 0, 0, 175, 0, 176, 0, 104, 104, 104, 182, 104, 104, 104, 104, 104, 104, 483, 104, 104, 104, 104, 104, 104, 488, 104, 104, 104, 204, 206,
    104, 210, 104, 213, 104, 104, 0, 123, 123, 123, 229, 123, 123, 123, 123, 123, 123, 123, 433, 123, 123, 436, 123, 123, 123, 123, 123, 123, 123, 123, 123,
    261, 123, 123, 0, 0, 0, 0, 123, 123, 123, 123, 251, 253, 123, 257, 123, 260, 123, 123, 0, 0, 0, 0, 69, 69, 69, 2121, 2121, 2121, 2121, 76, 77, 78, 152, 0,
    289, 389, 104, 104, 391, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 486, 487, 104, 104, 104, 123, 455, 123, 123, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 285, 0, 287, 288, 465, 0, 467, 467, 389, 104, 104, 104, 471, 104, 104, 104, 104, 104, 104, 104, 221, 104, 0, 123, 123, 123, 123, 123, 123, 123, 123,
    123, 123, 571, 123, 123, 123, 123, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 68, 0, 69, 0, 123, 123, 123, 123, 610, 123, 123, 123, 123, 123, 123, 123, 123, 0, 0,
    0, 0, 0, 0, 460, 0, 0, 0, 0, 0, 0, 0, 0, 104, 104, 104, 104, 624, 104, 104, 104, 104, 104, 104, 104, 104, 222, 0, 123, 123, 226, 123, 123, 123, 104, 104,
    104, 635, 104, 123, 123, 123, 123, 641, 123, 123, 123, 123, 123, 123, 104, 104, 805, 806, 104, 104, 123, 123, 811, 812, 123, 123, 123, 123, 123, 652, 123,
    0, 0, 0, 0, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 539, 0, 0, 529, 104, 104, 531, 532, 104, 104, 104, 104, 104, 104, 104, 104, 104,
    0, 123, 123, 123, 123, 123, 123, 553, 554, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 0, 0, 0, 758, 104, 760, 104, 123, 123,
    123, 123, 766, 123, 768, 123, 770, 123, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 591, 104, 104, 104, 104, 104, 638, 123, 123, 123,
    123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 564, 123, 123, 100, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 107, 126, 107, 107, 107, 107, 126,
    126, 126, 126, 126, 126, 126, 0, 0, 0, 0, 0, 0, 380, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38995, 0, 0, 134144, 0, 0, 0, 0, 69, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 278,
    0, 0, 0, 0, 2121, 0, 0, 0, 21504, 21504, 21504, 21504, 21504, 21504, 21504, 21504, 21504, 21504, 21504, 0, 12410, 0, 21504, 0, 289, 178, 291, 104, 104, 104,
    104, 104, 104, 104, 300, 104, 104, 104, 104, 305, 225, 333, 123, 123, 123, 123, 123, 123, 123, 342, 123, 123, 123, 123, 347, 123, 123, 123, 123, 123, 123,
    123, 573, 123, 0, 0, 0, 0, 0, 0, 0, 104, 104, 104, 104, 104, 191, 104, 104, 104, 289, 389, 104, 104, 104, 104, 104, 104, 104, 396, 104, 104, 104, 104, 104,
    104, 104, 719, 104, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 357, 123, 123, 359, 123, 104, 104, 104, 404, 104, 104, 104, 104, 104, 104, 104,
    104, 104, 104, 412, 413, 123, 123, 123, 430, 123, 123, 123, 123, 123, 123, 123, 123, 123, 438, 123, 123, 123, 123, 123, 123, 123, 509, 123, 123, 123, 123,
    123, 123, 123, 123, 123, 123, 123, 123, 512, 123, 123, 123, 104, 104, 491, 104, 104, 104, 104, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 104,
    123, 123, 123, 123, 518, 123, 123, 123, 123, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 464, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 590, 104, 104,
    104, 104, 104, 406, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 423, 12619, 389, 123, 123, 123, 123, 123, 123, 608, 123, 123, 123, 123, 123, 123, 123,
    123, 123, 123, 0, 0, 617, 647, 648, 123, 123, 123, 123, 123, 0, 0, 0, 0, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 630, 631, 104, 824, 123,
    123, 123, 826, 104, 104, 123, 123, 104, 123, 104, 123, 104, 123, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 170, 0, 0, 108, 108, 108, 108, 127, 127, 127,
    127, 127, 127, 127, 0, 0, 0, 0, 0, 0, 16384, 0, 0, 16384, 16384, 0, 0, 0, 0, 0, 0, 0, 161, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 109665, 0, 0, 134144, 0, 0, 0, 161,
    0, 0, 0, 0, 0, 104, 104, 104, 104, 104, 104, 104, 104, 197, 123, 123, 244, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 0, 0, 0, 0, 0, 0, 0, 0, 69, 69,
    0, 0, 0, 0, 0, 275, 0, 0, 0, 0, 0, 0, 0, 104, 104, 104, 104, 185, 104, 104, 195, 104, 289, 178, 292, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
    104, 104, 315, 104, 104, 317, 225, 334, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 439, 123, 567, 123, 123, 123, 123, 123, 123,
    123, 123, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 463, 0, 0, 104, 104, 104, 104, 584, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 550, 104, 104, 104, 123, 123,
    123, 743, 123, 123, 123, 123, 123, 123, 123, 0, 104, 104, 104, 104, 104, 757, 0, 0, 0, 0, 2121, 78, 0, 79, 78, 78, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
    86, 109, 128, 109, 109, 109, 109, 109, 109, 109, 128, 128, 128, 128, 128, 128, 128, 0, 0, 0, 0, 0, 0, 22528, 22528, 22528, 22528, 22528, 0, 0, 134144, 0, 0,
    202, 104, 207, 104, 104, 212, 215, 218, 104, 0, 123, 123, 123, 123, 232, 123, 123, 123, 123, 123, 123, 123, 612, 123, 123, 123, 123, 123, 0, 0, 0, 0, 389,
    104, 104, 470, 104, 104, 104, 104, 104, 104, 104, 104, 312, 104, 104, 104, 104, 104, 104, 104, 123, 242, 123, 249, 123, 254, 123, 123, 259, 262, 265, 123,
    0, 271, 0, 0, 0, 0, 2121, 76, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 168, 0, 0, 0, 0, 0, 272, 69, 69, 0, 0, 0, 273, 0, 0, 0, 0, 0, 0, 0, 0, 0, 65, 0, 0, 0, 0, 69,
    0, 104, 104, 319, 104, 104, 104, 104, 104, 104, 104, 104, 328, 104, 104, 12619, 289, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
    104, 104, 104, 490, 225, 123, 123, 123, 123, 123, 123, 123, 123, 123, 343, 123, 123, 346, 123, 123, 123, 123, 123, 123, 123, 559, 123, 123, 123, 123, 123,
    123, 123, 123, 123, 123, 123, 123, 358, 123, 123, 123, 123, 361, 123, 123, 123, 123, 123, 123, 123, 123, 370, 123, 123, 271, 0, 0, 0, 0, 2121, 77, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 384, 0, 0, 0, 0, 0, 377, 0, 0, 378, 379, 0, 381, 0, 0, 0, 0, 0, 0, 0, 0, 0, 166, 0, 0, 0, 0, 171, 0, 289, 389, 390, 104, 104, 104,
    104, 104, 104, 104, 104, 104, 104, 399, 104, 104, 104, 104, 104, 664, 104, 104, 104, 104, 669, 104, 104, 123, 123, 123, 123, 104, 104, 123, 123, 104, 123,
    104, 123, 833, 834, 402, 104, 104, 104, 104, 104, 407, 104, 104, 104, 104, 409, 410, 411, 104, 104, 104, 104, 104, 717, 104, 104, 104, 123, 721, 123, 123,
    123, 123, 123, 123, 123, 123, 123, 123, 561, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 614, 123, 123, 0, 0, 0, 104, 104, 416, 104, 418, 104, 104,
    104, 422, 104, 12619, 389, 424, 123, 123, 123, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 441,
    123, 123, 123, 123, 443, 444, 445, 123, 123, 123, 123, 450, 123, 452, 123, 123, 123, 123, 123, 123, 123, 655, 0, 0, 0, 0, 104, 104, 104, 104, 104, 104, 104,
    104, 627, 628, 104, 104, 104, 123, 123, 456, 123, 0, 0, 0, 458, 0, 0, 0, 0, 0, 0, 0, 0, 0, 382, 0, 0, 0, 0, 0, 0, 123, 123, 123, 123, 123, 557, 123, 123,
    123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 451, 123, 123, 123, 123, 123, 609, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 616, 0, 0, 0, 0,
    2121, 78, 0, 0, 78, 78, 95, 95, 99, 95, 99, 95, 618, 619, 620, 104, 104, 623, 104, 104, 104, 104, 626, 104, 104, 629, 104, 104, 104, 104, 123, 763, 123,
    123, 123, 123, 123, 123, 123, 123, 0, 104, 732, 104, 104, 104, 736, 104, 104, 104, 104, 123, 104, 104, 634, 636, 104, 123, 123, 640, 123, 123, 123, 123,
    643, 123, 123, 646, 123, 123, 123, 123, 651, 653, 123, 0, 0, 0, 0, 0, 104, 659, 104, 104, 104, 104, 309, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
    104, 670, 104, 123, 123, 123, 104, 713, 104, 104, 104, 104, 104, 104, 104, 123, 123, 123, 723, 123, 123, 123, 0, 104, 104, 104, 793, 104, 794, 104, 104,
    104, 123, 123, 123, 123, 104, 104, 123, 123, 104, 123, 104, 123, 104, 123, 123, 123, 123, 123, 730, 104, 104, 104, 104, 104, 104, 104, 104, 104, 740, 123,
    123, 123, 123, 123, 123, 123, 679, 123, 123, 123, 123, 123, 123, 686, 0, 0, 0, 0, 2121, 78, 0, 0, 78, 78, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 121,
    140, 121, 121, 121, 104, 104, 775, 104, 777, 104, 104, 104, 104, 782, 123, 123, 784, 123, 786, 123, 123, 123, 123, 123, 123, 256, 258, 123, 123, 267, 123,
    0, 0, 0, 0, 69, 69, 69, 10312, 2121, 2121, 2121, 76, 77, 139264, 0, 0, 123, 814, 104, 104, 104, 104, 104, 104, 123, 123, 123, 123, 123, 123, 104, 104, 104,
    104, 104, 104, 123, 123, 123, 123, 123, 123, 104, 104, 110, 110, 110, 110, 129, 129, 129, 129, 129, 129, 129, 0, 0, 0, 0, 0, 0, 23552, 0, 0, 0, 0, 0, 0, 0,
    69, 0, 0, 0, 145, 0, 69, 69, 69, 2121, 2121, 2121, 2121, 76, 77, 78, 0, 0, 0, 0, 2121, 78, 0, 0, 78, 78, 0, 0, 0, 0, 0, 0, 0, 104, 104, 104, 104, 104, 192,
    104, 104, 104, 123, 123, 245, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 0, 0, 0, 0, 0, 578, 104, 104, 104, 417, 104, 104, 104, 104, 104, 104, 12619,
    389, 123, 123, 123, 123, 0, 136192, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 66, 0, 0, 0, 69, 0, 123, 123, 123, 570, 123, 123, 123, 123, 123, 0, 0, 0, 0, 0, 0, 0, 0,
    461, 462, 0, 0, 104, 104, 825, 123, 123, 123, 104, 104, 123, 123, 104, 123, 104, 123, 104, 123, 123, 123, 123, 123, 123, 367, 123, 123, 123, 123, 123, 123,
    0, 0, 0, 0, 389, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 314, 104, 104, 104, 104, 111, 111, 111, 111, 130, 130, 130, 130, 130, 130, 130, 0,
    0, 0, 0, 0, 0, 24576, 24576, 24576, 24576, 24576, 0, 0, 134144, 0, 0, 104, 104, 663, 104, 104, 104, 104, 666, 104, 104, 104, 104, 104, 123, 123, 123, 123,
    123, 123, 123, 123, 123, 123, 772, 104, 123, 123, 123, 677, 123, 123, 123, 123, 680, 123, 123, 123, 123, 123, 0, 0, 0, 0, 2121, 78, 0, 0, 78, 78, 0, 0, 0,
    0, 100, 0, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 694, 104, 104, 104, 104, 123, 123, 764, 123, 123, 123, 123, 123, 123, 123, 0, 773, 0, 0, 0, 146,
    69, 69, 69, 2121, 2121, 2121, 2121, 76, 77, 78, 0, 0, 0, 0, 2121, 78, 0, 0, 78, 78, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 108, 127, 108, 108, 108, 0,
    0, 69, 69, 0, 0, 0, 0, 274, 0, 0, 0, 0, 0, 0, 0, 63, 64, 0, 0, 0, 0, 0, 71, 0, 123, 123, 123, 123, 365, 123, 123, 123, 123, 123, 123, 123, 123, 0, 0, 0, 0,
    459, 0, 0, 0, 0, 0, 0, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 123, 123, 123, 123, 123, 123, 123, 123, 572, 123, 123, 123,
    0, 0, 0, 0, 0, 0, 0, 104, 104, 104, 104, 104, 104, 104, 104, 198, 112, 112, 112, 112, 131, 131, 131, 131, 131, 131, 131, 0, 0, 0, 0, 0, 0, 28672, 140288,
    140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 0, 140288, 140513, 140288, 140288, 140288, 140288, 279, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 284,
    0, 0, 0, 0, 69, 69, 69, 2121, 2121, 2121, 2121, 76, 77, 139264, 0, 0, 289, 178, 104, 104, 104, 104, 296, 104, 104, 104, 104, 104, 104, 104, 104, 104, 0,
    123, 123, 123, 123, 123, 235, 225, 123, 123, 123, 123, 338, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 513, 514, 123, 123, 123, 123,
    351, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 271, 0, 0, 104, 415, 104, 104, 104, 104, 104, 104, 104, 104, 12619, 389, 123, 123, 123,
    123, 123, 123, 123, 123, 123, 560, 123, 123, 123, 123, 123, 566, 540, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 123, 123, 123, 123,
    499, 123, 123, 123, 123, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 588, 104, 104, 104, 104, 104, 104, 494, 123, 123, 123, 123, 123, 123, 123, 123,
    123, 123, 123, 123, 123, 135168, 373, 0, 593, 104, 104, 595, 104, 104, 597, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 523, 0, 0, 0, 0, 0, 606, 123,
    123, 123, 123, 123, 611, 123, 123, 613, 123, 123, 615, 0, 0, 0, 0, 148, 19605, 148, 2121, 2121, 19529, 2121, 76, 77, 139264, 0, 0, 104, 633, 104, 104, 104,
    123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 270, 374, 0, 123, 123, 123, 650, 123, 123, 123, 0, 0, 0, 0, 0, 104, 104, 104, 104, 104,
    104, 104, 104, 104, 537, 104, 104, 104, 123, 123, 123, 745, 123, 747, 748, 749, 123, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
    592, 104, 799, 123, 800, 123, 123, 123, 104, 104, 104, 104, 104, 104, 123, 123, 123, 123, 123, 123, 823, 104, 104, 104, 123, 123, 123, 123, 104, 104, 123,
    123, 829, 830, 104, 123, 104, 123, 123, 123, 123, 123, 123, 519, 123, 123, 0, 0, 524, 0, 0, 0, 0, 76, 76, 76, 76, 76, 76, 76, 0, 0, 134144, 0, 0, 113, 113,
    113, 113, 132, 132, 132, 132, 132, 132, 132, 0, 0, 0, 0, 0, 156, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23552, 0, 0, 134144, 0, 0, 306, 104, 104, 104, 104, 104, 104,
    104, 104, 104, 104, 104, 104, 104, 104, 104, 329, 104, 12619, 289, 225, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 348, 289, 389,
    104, 104, 104, 104, 104, 394, 104, 104, 104, 104, 104, 104, 104, 104, 326, 104, 104, 104, 104, 330, 12619, 289, 104, 403, 104, 104, 104, 104, 104, 104, 104,
    104, 104, 104, 104, 104, 104, 104, 551, 104, 123, 123, 123, 428, 123, 123, 123, 123, 123, 123, 123, 123, 123, 437, 123, 123, 123, 123, 123, 123, 123, 123,
    123, 574, 0, 0, 0, 0, 0, 0, 0, 104, 104, 104, 104, 186, 104, 104, 104, 104, 579, 104, 104, 582, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
    671, 123, 123, 123, 104, 104, 104, 776, 104, 778, 104, 104, 104, 123, 123, 123, 123, 785, 123, 787, 114, 114, 114, 114, 133, 133, 133, 133, 133, 133, 133,
    0, 0, 0, 0, 0, 157, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 29696, 0, 19456, 134144, 31744, 0, 289, 178, 104, 104, 104, 104, 104, 297, 104, 104, 104, 104, 104, 104,
    104, 104, 484, 104, 104, 104, 104, 104, 489, 104, 225, 123, 123, 123, 123, 123, 339, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 575, 0, 0, 0, 0, 0,
    376, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 289, 389, 104, 104, 104, 104, 104, 104, 395, 104, 104, 104, 398, 104, 104, 104, 104, 104, 482, 104,
    104, 104, 104, 104, 104, 104, 104, 104, 104, 485, 104, 104, 104, 104, 104, 123, 123, 429, 123, 123, 123, 432, 123, 123, 123, 123, 123, 123, 123, 123, 123,
    0, 752, 104, 104, 104, 104, 104, 123, 442, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 565, 123, 123, 517, 123, 123, 123, 123,
    123, 123, 123, 0, 0, 0, 0, 0, 0, 0, 104, 104, 104, 104, 104, 104, 194, 104, 104, 123, 123, 729, 123, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
    123, 123, 497, 123, 123, 123, 123, 123, 123, 115, 115, 115, 115, 134, 134, 134, 134, 134, 134, 134, 0, 0, 0, 0, 0, 158, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33874,
    0, 0, 134144, 0, 0, 0, 144, 0, 0, 69, 69, 69, 2121, 2121, 2121, 2121, 76, 77, 78, 0, 0, 0, 0, 2121, 78, 0, 0, 78, 78, 87, 87, 87, 87, 87, 87, 87, 87, 87,
    87, 87, 111, 130, 111, 111, 111, 0, 0, 0, 154, 0, 0, 0, 162, 0, 0, 0, 0, 0, 0, 0, 172, 0, 173, 0, 0, 0, 0, 0, 104, 104, 179, 104, 104, 104, 104, 104, 199,
    123, 123, 246, 123, 123, 123, 123, 123, 123, 123, 123, 269, 0, 0, 0, 0, 69, 69, 69, 2121, 2121, 2121, 2121, 76, 6295, 139264, 0, 0, 104, 308, 104, 104, 104,
    104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 12619, 0, 123, 123, 123, 123, 350, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123,
    123, 123, 0, 0, 375, 528, 0, 0, 104, 104, 104, 104, 104, 533, 534, 104, 536, 104, 104, 104, 104, 104, 104, 665, 104, 104, 104, 104, 104, 104, 123, 673, 123,
    104, 541, 104, 104, 104, 104, 104, 547, 104, 104, 104, 104, 104, 104, 123, 123, 123, 123, 123, 767, 123, 123, 123, 123, 0, 104, 104, 733, 104, 104, 104,
    104, 104, 104, 104, 123, 123, 123, 601, 123, 123, 604, 123, 123, 123, 123, 123, 555, 556, 123, 558, 123, 123, 123, 123, 123, 563, 123, 123, 123, 123, 123,
    123, 123, 123, 705, 123, 123, 123, 123, 0, 104, 104, 104, 104, 735, 104, 737, 738, 739, 104, 123, 123, 123, 569, 123, 123, 123, 123, 123, 123, 0, 0, 0, 0,
    0, 0, 0, 104, 104, 104, 104, 104, 188, 104, 104, 104, 0, 104, 104, 104, 104, 104, 585, 104, 104, 104, 104, 104, 104, 104, 104, 104, 0, 123, 123, 123, 123,
    123, 236, 632, 104, 104, 104, 104, 123, 123, 123, 123, 123, 123, 123, 123, 644, 645, 123, 123, 123, 123, 123, 123, 654, 0, 656, 0, 0, 0, 104, 104, 104, 104,
    104, 104, 104, 535, 104, 104, 104, 104, 104, 123, 123, 649, 123, 123, 123, 123, 0, 0, 0, 0, 0, 104, 104, 104, 660, 674, 123, 123, 123, 123, 123, 123, 123,
    123, 681, 123, 123, 123, 123, 0, 0, 0, 0, 2121, 78, 0, 0, 78, 78, 88, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 112, 131, 112, 112, 112, 0, 104, 104, 104,
    689, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 123, 123, 600, 123, 123, 123, 123, 123, 123, 123, 123, 700, 123, 123, 123, 123, 123, 123, 123, 123,
    123, 123, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 715, 104, 104, 104, 104, 104, 123, 123, 123, 123, 123, 725, 123, 123, 123, 123, 123, 123, 678,
    123, 123, 123, 123, 683, 123, 123, 0, 0, 0, 0, 2121, 78, 0, 0, 78, 78, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 115, 134, 115, 115, 115, 123, 123, 744,
    123, 123, 123, 123, 123, 123, 751, 104, 104, 104, 104, 104, 104, 214, 104, 104, 0, 123, 123, 123, 123, 123, 123, 104, 804, 104, 104, 104, 808, 123, 810,
    123, 123, 104, 759, 104, 761, 123, 123, 123, 123, 123, 123, 123, 769, 123, 771, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 696, 104,
    123, 116, 116, 116, 116, 135, 135, 135, 135, 135, 135, 135, 0, 0, 0, 0, 0, 281, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14417, 0, 0, 134144, 0, 0, 0, 0, 171, 0, 0, 0,
    0, 104, 104, 104, 184, 187, 104, 193, 104, 104, 104, 104, 405, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 421, 104, 104, 12619, 389, 123, 123,
    425, 123, 104, 205, 208, 104, 104, 104, 216, 219, 104, 0, 123, 123, 123, 231, 234, 123, 123, 123, 123, 123, 123, 803, 104, 104, 104, 104, 104, 809, 123,
    123, 123, 0, 791, 104, 104, 104, 104, 104, 104, 104, 104, 797, 123, 123, 240, 123, 123, 123, 252, 255, 123, 123, 123, 263, 266, 123, 0, 0, 0, 0, 69, 69, 69,
    2121, 2121, 2121, 2121, 6294, 77, 139264, 0, 0, 104, 104, 320, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 12619, 289, 178, 104, 104, 104, 104,
    104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 12619, 289, 123, 362, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 0, 0, 576, 0, 0, 0, 123,
    123, 123, 457, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 385, 0, 387, 388, 104, 104, 480, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 12619,
    389, 123, 123, 123, 123, 123, 123, 123, 123, 507, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 271, 0, 0, 0, 580, 104, 104, 104, 104,
    104, 104, 104, 104, 104, 589, 104, 104, 104, 104, 104, 104, 718, 104, 104, 720, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 511, 123, 123, 123, 123,
    123, 123, 607, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 0, 0, 0, 389, 104, 104, 104, 104, 104, 104, 104, 475, 104, 104, 104, 104, 104, 493,
    104, 495, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 26624, 134414, 0, 0, 0, 687, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
    104, 104, 698, 712, 104, 104, 104, 104, 104, 104, 104, 104, 123, 123, 722, 123, 123, 123, 123, 123, 123, 123, 123, 369, 123, 123, 123, 123, 0, 0, 0, 742,
    123, 123, 123, 746, 123, 123, 123, 123, 0, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 123, 117, 117, 117, 117, 136, 136, 136, 136, 136, 136, 136, 0,
    0, 0, 0, 0, 21504, 0, 0, 0, 0, 0, 0, 0, 0, 69, 0, 225, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 345, 123, 123, 123, 123, 123, 123, 123, 123, 446,
    447, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 268, 123, 0, 0, 0, 0, 104, 479, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
    12619, 389, 123, 123, 123, 426, 123, 123, 123, 506, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 134144, 0, 0, 104, 104, 104, 543, 104,
    104, 104, 104, 104, 104, 104, 104, 104, 104, 123, 123, 123, 123, 602, 123, 123, 123, 123, 104, 662, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
    123, 123, 123, 123, 123, 123, 123, 502, 123, 123, 123, 676, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 0, 0, 0, 2121, 78, 0, 0, 78, 78, 89,
    89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 113, 132, 113, 113, 113, 118, 118, 118, 118, 137, 137, 137, 137, 137, 137, 137, 0, 0, 0, 0, 0, 27751, 27751, 27751,
    27751, 27751, 0, 0, 0, 134144, 0, 0, 0, 0, 174, 0, 0, 0, 0, 104, 104, 180, 104, 104, 104, 104, 104, 104, 217, 104, 104, 0, 123, 123, 123, 123, 123, 123,
    123, 123, 123, 123, 356, 123, 123, 123, 123, 123, 104, 104, 104, 209, 211, 104, 104, 220, 104, 0, 123, 123, 227, 123, 123, 123, 123, 123, 123, 123, 123,
    750, 0, 104, 104, 754, 104, 104, 104, 104, 104, 419, 420, 104, 104, 104, 12619, 389, 123, 123, 123, 123, 123, 123, 123, 123, 510, 123, 123, 123, 123, 123,
    123, 515, 289, 178, 104, 293, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 0, 123, 123, 123, 123, 123, 237, 307, 104, 104, 104, 104, 104,
    104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 0, 123, 123, 123, 123, 123, 238, 104, 318, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104,
    12619, 289, 178, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 303, 104, 104, 104, 104, 104, 545, 104, 104, 104, 104, 104, 104, 104, 104, 123, 123, 123,
    123, 123, 603, 123, 123, 123, 225, 123, 335, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 349, 360, 123, 123, 123, 123, 123, 123, 123, 123,
    123, 123, 123, 123, 0, 0, 0, 0, 389, 104, 104, 104, 104, 104, 473, 474, 104, 476, 104, 104, 289, 389, 104, 104, 104, 392, 104, 104, 104, 104, 104, 104, 104,
    104, 104, 401, 0, 0, 0, 621, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 0, 123, 123, 123, 123, 123, 239, 123, 728, 123, 123, 0, 104, 104,
    104, 104, 104, 104, 104, 104, 104, 104, 123, 496, 123, 123, 123, 123, 123, 123, 123, 813, 123, 104, 104, 104, 104, 104, 104, 123, 123, 123, 123, 123, 123,
    104, 104, 104, 104, 807, 104, 123, 123, 123, 123, 0, 0, 0, 0, 2121, 78, 0, 80, 78, 78, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 119, 138, 119, 119, 119,
    119, 119, 119, 119, 138, 138, 138, 138, 138, 138, 138, 0, 0, 0, 0, 0, 108544, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36965, 0, 0, 134144, 0, 32768, 143, 0, 0, 0, 69,
    69, 69, 2121, 2121, 2121, 2121, 76, 77, 78, 0, 0, 0, 0, 2121, 78, 0, 0, 78, 78, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 114, 133, 114, 114, 114, 0, 163,
    0, 0, 0, 0, 0, 104, 104, 104, 104, 104, 104, 104, 104, 200, 123, 123, 247, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 0, 0, 0, 0, 527, 0, 0, 0, 69, 69,
    0, 0, 0, 0, 0, 0, 0, 277, 0, 0, 0, 0, 69, 69, 30720, 2121, 2121, 2121, 73, 76, 77, 139264, 0, 0, 289, 178, 104, 104, 104, 295, 104, 104, 298, 104, 104, 302,
    104, 104, 104, 104, 104, 104, 779, 104, 104, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 371, 123, 0, 0, 0, 225, 123, 123, 123, 337, 123, 123,
    340, 123, 123, 344, 123, 123, 123, 123, 123, 123, 123, 123, 123, 264, 123, 123, 0, 0, 0, 0, 516, 123, 123, 123, 123, 123, 123, 520, 123, 0, 0, 0, 525, 0, 0,
    0, 0, 389, 104, 104, 104, 104, 472, 104, 104, 104, 104, 104, 104, 104, 780, 104, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 562, 123, 123, 123,
    123, 104, 104, 542, 104, 104, 104, 546, 104, 104, 104, 104, 104, 104, 104, 123, 123, 123, 498, 123, 123, 123, 123, 123, 123, 568, 123, 123, 123, 123, 123,
    123, 123, 0, 0, 0, 0, 0, 0, 0, 104, 104, 104, 104, 104, 189, 104, 104, 104, 0, 104, 104, 104, 104, 104, 104, 104, 587, 104, 104, 104, 104, 104, 104, 104,
    325, 104, 104, 104, 104, 104, 104, 12619, 289, 104, 594, 104, 104, 104, 104, 104, 123, 123, 123, 123, 123, 123, 123, 605, 123, 123, 123, 123, 123, 352, 123,
    123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 685, 0, 0, 104, 104, 714, 104, 716, 104, 104, 104, 104, 123, 123, 123, 123, 724, 123, 726, 104,
    104, 104, 104, 762, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 104, 104, 104, 755, 104, 104, 788, 123, 123, 0, 104, 792, 104, 104, 104, 104, 104, 104,
    104, 123, 798, 123, 123, 123, 123, 123, 353, 123, 123, 355, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 449, 123, 123, 123, 123, 99, 99, 99, 99,
    99, 99, 99, 99, 99, 99, 99, 120, 139, 120, 120, 120, 120, 139, 139, 139, 139, 139, 139, 139, 0, 0, 0, 0, 0, 73, 0, 0, 0, 0, 0, 111616, 111616, 111616,
    111616, 111616, 111616, 111616, 111616, 111616, 111616, 111616, 0, 0, 0, 0, 0, 203, 104, 104, 104, 104, 104, 104, 104, 104, 0, 123, 123, 228, 123, 123, 123,
    123, 123, 123, 123, 354, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 684, 123, 0, 0, 123, 243, 248, 250, 123, 123, 123, 123, 123, 123, 123,
    123, 0, 0, 0, 0, 0, 658, 104, 104, 104, 0, 280, 0, 0, 0, 0, 0, 0, 282, 283, 0, 0, 280, 0, 0, 0, 0, 389, 104, 469, 104, 104, 104, 104, 104, 104, 104, 104,
    477, 289, 178, 104, 104, 294, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 327, 104, 104, 104, 104, 12619, 289, 104, 104, 104, 321, 322, 104, 104,
    104, 104, 104, 104, 104, 104, 104, 12619, 289, 178, 104, 104, 104, 104, 104, 104, 104, 104, 104, 301, 104, 104, 304, 104, 104, 104, 104, 492, 104, 104, 123,
    123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 270, 142, 0, 0, 225, 123, 123, 336, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123,
    0, 710, 104, 123, 123, 363, 364, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 0, 0, 0, 389, 468, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 0,
    123, 123, 123, 230, 123, 123, 289, 389, 104, 104, 104, 104, 393, 104, 104, 104, 104, 104, 104, 104, 400, 104, 104, 104, 104, 544, 104, 104, 104, 104, 104,
    104, 104, 104, 104, 552, 123, 123, 123, 123, 123, 366, 123, 123, 123, 123, 123, 123, 123, 0, 0, 0, 0, 155, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 105, 124, 105,
    105, 105, 427, 123, 123, 123, 123, 123, 123, 123, 434, 123, 123, 123, 123, 123, 123, 440, 454, 123, 123, 123, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 110, 129,
    110, 110, 110, 0, 466, 0, 0, 389, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 549, 104, 104, 104, 104, 123, 123, 104, 104, 104, 481, 104, 104,
    104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 668, 104, 104, 104, 123, 123, 123, 123, 123, 123, 123, 123, 508, 123, 123, 123, 123, 123, 123, 123, 123,
    123, 123, 123, 123, 123, 709, 104, 104, 0, 0, 0, 530, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 538, 104, 104, 104, 104, 596, 104, 104, 123, 123,
    123, 123, 123, 123, 123, 123, 123, 0, 104, 753, 104, 104, 104, 104, 0, 104, 104, 104, 583, 104, 104, 586, 104, 104, 104, 104, 104, 104, 104, 104, 667, 104,
    104, 104, 104, 123, 123, 123, 0, 0, 0, 104, 622, 104, 104, 104, 625, 104, 104, 104, 104, 104, 104, 104, 408, 104, 104, 104, 104, 104, 104, 104, 104, 548,
    104, 104, 104, 104, 104, 123, 123, 104, 104, 104, 104, 637, 123, 639, 123, 123, 123, 642, 123, 123, 123, 123, 123, 123, 123, 123, 123, 435, 123, 123, 123,
    123, 123, 123, 123, 123, 123, 123, 448, 123, 123, 123, 123, 123, 0, 104, 104, 688, 104, 104, 104, 104, 104, 104, 104, 104, 695, 104, 104, 123, 123, 123,
    123, 104, 104, 123, 123, 104, 123, 831, 832, 104, 123, 123, 699, 123, 123, 123, 123, 123, 123, 123, 123, 706, 123, 123, 0, 104, 104, 104, 104, 104, 104,
    104, 104, 104, 104, 104, 104, 104, 697, 123, 123, 123, 790, 0, 104, 104, 104, 104, 104, 104, 795, 796, 104, 123, 123, 123, 123, 123, 123, 123, 368, 123,
    123, 123, 123, 372, 0, 0, 0, 0, 147, 147, 147, 2121, 2121, 2121, 2121, 76, 77, 139264, 0, 0, 123, 123, 123, 801, 802, 123, 104, 104, 104, 104, 104, 104,
    123, 123, 123, 123, 123, 123, 123, 0, 0, 0, 0, 0, 104, 104, 104, 104, 104, 104, 123, 123, 123, 123, 104, 827, 123, 828, 104, 123, 104, 123, 104, 123, 123,
    123, 123, 123, 431, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 135168, 0, 0, 121, 121, 121, 121, 140, 140, 140, 140, 140, 140, 140, 0,
    0, 0, 0, 0, 77, 77, 77, 77, 77, 77, 77, 0, 0, 134144, 0, 0, 241, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 0, 0, 0, 0, 577, 0, 289, 389,
    104, 104, 104, 104, 104, 104, 104, 104, 104, 397, 104, 104, 104, 104, 104, 323, 104, 104, 104, 104, 104, 104, 104, 104, 12619, 289, 414, 104, 104, 104, 104,
    104, 104, 104, 104, 104, 12619, 389, 123, 123, 123, 123, 123, 123, 123, 123, 521, 522, 0, 0, 0, 526, 0, 0, 0, 104, 581, 104, 104, 104, 104, 104, 104, 104,
    104, 104, 104, 104, 104, 104, 781, 123, 123, 123, 123, 123, 123, 123, 0, 104, 104, 104, 104, 690, 104, 104, 104, 104, 104, 104, 104, 104, 104, 123, 599,
    123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 701, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 104, 104, 104, 104, 756, 104, 123, 789, 123, 0, 104,
    104, 104, 104, 104, 104, 104, 104, 104, 123, 123, 123, 123, 123, 500, 501, 123, 503, 0, 0, 69, 69, 0, 0, 0, 0, 0, 0, 276, 0, 0, 0, 0, 0, 142, 142, 142, 142,
    142, 142, 142, 0, 0, 62, 0, 0, 289, 178, 104, 104, 104, 104, 104, 104, 104, 299, 104, 104, 104, 104, 104, 104, 311, 104, 104, 313, 104, 104, 104, 104, 104,
    104, 310, 104, 104, 104, 104, 104, 104, 104, 104, 104, 0, 123, 123, 123, 123, 233, 123, 225, 123, 123, 123, 123, 123, 123, 123, 341, 123, 123, 123, 123,
    123, 123, 123, 123, 123, 123, 123, 707, 123, 0, 104, 104, 478, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 598, 123, 123,
    123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 708, 0, 104, 104, 123, 504, 505, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 0, 104,
    104, 0, 0, 0, 108544, 108617, 0, 0, 0, 0, 0, 0, 0, 0, 108544, 0, 108544, 110592, 0, 0, 0, 0, 0, 0, 140288, 140288, 140288, 140288, 140288, 140288, 140288,
    140288, 140288, 140288, 140288, 236544, 140288, 238592, 140288, 180224, 0, 290, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288,
    140288, 140288, 194560, 140288, 140288, 140288, 237568, 0, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288,
    140288, 140288, 0, 140288, 140288, 140288, 140288, 140288, 140288, 332, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288,
    140288, 194560, 140288, 140288, 140288, 200704, 206848, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 140288, 177152, 140288, 184320, 0, 0, 0, 0,
    13312, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 117, 136, 117, 117, 117, 220160, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 194560, 0, 201728, 202752
  "/>

  <!--~
   ! The DFA-state to expected-token-set mapping.
  -->
  <xsl:variable name="p:EXPECTED" as="xs:integer+" select="
    417, 421, 425, 429, 433, 437, 441, 445, 927, 461, 468, 511, 741, 474, 486, 479, 494, 481, 893, 511, 511, 511, 485, 486, 486, 486, 486, 475, 493, 494, 494,
    494, 494, 499, 511, 511, 485, 486, 486, 486, 486, 543, 494, 494, 494, 494, 503, 511, 687, 486, 486, 486, 519, 494, 494, 494, 494, 510, 517, 486, 486, 487,
    494, 494, 494, 510, 518, 486, 519, 494, 494, 546, 517, 486, 520, 494, 545, 951, 486, 520, 494, 495, 518, 519, 494, 524, 486, 530, 536, 519, 494, 526, 488,
    535, 486, 530, 525, 520, 531, 488, 540, 531, 489, 550, 553, 559, 725, 569, 573, 576, 579, 582, 918, 511, 589, 511, 957, 593, 511, 693, 597, 511, 919, 604,
    511, 511, 608, 616, 664, 511, 511, 511, 620, 626, 645, 511, 511, 511, 630, 511, 634, 658, 644, 511, 511, 665, 657, 643, 511, 511, 511, 650, 985, 622, 663,
    511, 511, 656, 662, 511, 511, 669, 781, 677, 645, 511, 681, 685, 511, 669, 761, 691, 511, 697, 692, 819, 760, 699, 705, 698, 511, 967, 703, 705, 709, 511,
    718, 511, 719, 511, 723, 729, 798, 735, 734, 851, 847, 704, 734, 733, 847, 736, 740, 850, 848, 849, 745, 758, 511, 933, 511, 464, 765, 766, 770, 771, 996,
    511, 562, 835, 639, 511, 775, 779, 867, 785, 997, 470, 793, 637, 797, 511, 904, 802, 806, 846, 511, 511, 980, 810, 814, 818, 561, 823, 932, 511, 555, 828,
    612, 511, 511, 554, 827, 611, 818, 861, 832, 511, 920, 840, 845, 511, 511, 839, 844, 469, 832, 511, 712, 844, 511, 920, 855, 860, 865, 920, 855, 818, 921,
    856, 890, 554, 871, 511, 713, 874, 920, 878, 554, 714, 887, 897, 664, 898, 563, 902, 451, 454, 453, 457, 565, 564, 448, 452, 456, 455, 652, 881, 882, 883,
    908, 912, 915, 511, 925, 931, 937, 940, 944, 945, 949, 752, 511, 511, 754, 955, 511, 506, 511, 646, 961, 511, 511, 511, 965, 511, 511, 511, 511, 513, 983,
    511, 511, 511, 511, 585, 750, 511, 971, 511, 511, 511, 511, 673, 511, 511, 511, 511, 672, 977, 973, 511, 511, 511, 512, 990, 511, 511, 511, 989, 973, 511,
    511, 511, 994, 511, 511, 748, 511, 511, 511, 788, 511, 511, 789, 511, 511, 600, 511, 599, 511, 511, 600, 511, 1001, 511, 599, 511, 600, 598, 511, 1002, 511,
    511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 511, 1006, 1008, 1010, 1012, 1014, 1015, 1015, 1017, 1019, 1021, 1023, 1020, 1025, 1027,
    1027, 1028, 1027, 1031, 1030, 1034, 1032, 1036, 1038, 1040, 1042, 1044, 1046, 1049, 1048, 1051, 1078, 1132, 1055, 1056, 1063, 1250, 1252, 1055, 1056, 1063,
    1250, 1252, 1054, 1056, 1082, 1064, 1135, 1056, 1053, 1056, 1162, 1090, 1056, 1056, 1056, 1055, 1056, 1084, 1194, 1194, 1194, 1097, 1195, 1211, 1098, 1098,
    1095, 1056, 1137, 1194, 1194, 1194, 1194, 1098, 1098, 1194, 1210, 1098, 1098, 1098, 1098, 1056, 1098, 1098, 1099, 1062, 1098, 1098, 1198, 1056, 1056, 1299,
    1075, 1202, 1056, 1056, 1056, 1056, 1058, 1060, 1056, 1291, 1194, 1194, 1194, 1201, 1098, 1098, 1098, 1202, 1194, 1194, 1194, 1201, 1098, 1098, 1098, 1194,
    1098, 1098, 1098, 1291, 1194, 1098, 1194, 1194, 1194, 1209, 1098, 1098, 1098, 1202, 1056, 1098, 1201, 1201, 1201, 1056, 1056, 1056, 1066, 1060, 1056, 1288,
    1056, 1056, 1053, 1056, 1056, 1242, 1128, 1132, 1289, 1056, 1101, 1102, 1104, 1106, 1109, 1109, 1108, 1110, 1111, 1111, 1111, 1114, 1113, 1116, 1056, 1057,
    1059, 1068, 1290, 1076, 1119, 1236, 1056, 1166, 1183, 1185, 1184, 1056, 1056, 1056, 1071, 1056, 1056, 1270, 1274, 1276, 1248, 1228, 1056, 1281, 1189, 1215,
    1192, 1247, 1287, 1230, 1125, 1170, 1247, 1056, 1280, 1188, 1229, 1124, 1127, 1124, 1126, 1171, 1131, 1056, 1290, 1275, 1129, 1228, 1056, 1089, 1188, 1244,
    1247, 1056, 1117, 1056, 1128, 1156, 1055, 1056, 1056, 1056, 1146, 1270, 1284, 1055, 1056, 1242, 1128, 1186, 1188, 1229, 1124, 1126, 1128, 1127, 1278, 1132,
    1056, 1056, 1056, 1089, 1056, 1270, 1053, 1056, 1057, 1059, 1148, 1136, 1243, 1124, 1127, 1156, 1187, 1087, 1230, 1154, 1271, 1132, 1056, 1056, 1074, 1194,
    1127, 1172, 1056, 1056, 1056, 1167, 1186, 1087, 1124, 1127, 1279, 1056, 1158, 1155, 1056, 1056, 1056, 1186, 1087, 1154, 1279, 1056, 1066, 1221, 1239, 1192,
    1131, 1056, 1233, 1153, 1155, 1056, 1206, 1155, 1056, 1056, 1085, 1056, 1056, 1233, 1154, 1279, 1056, 1233, 1169, 1279, 1056, 1056, 1233, 1160, 1056, 1056,
    1056, 1193, 1232, 1056, 1232, 1056, 1072, 1070, 1075, 1197, 1056, 1056, 1056, 1200, 1196, 1232, 1232, 1056, 1056, 1088, 1087, 1124, 1174, 1174, 1174, 1174,
    1163, 1164, 1164, 1164, 1164, 1165, 1091, 1179, 1181, 1168, 1246, 1273, 1056, 1056, 1088, 1188, 1182, 1245, 1272, 1056, 1072, 1071, 1056, 1056, 1056, 1199,
    1149, 1205, 1296, 1056, 1056, 1056, 1233, 1070, 1208, 1142, 1144, 1189, 1230, 1235, 1217, 1295, 1213, 1143, 1086, 1229, 1231, 1216, 1247, 1287, 1056, 1056,
    1056, 1270, 1056, 1149, 1177, 1226, 1060, 1138, 1141, 1120, 1189, 1219, 1226, 1052, 1056, 1093, 1176, 1244, 1067, 1138, 1141, 1123, 1191, 1191, 1278, 1286,
    1056, 1056, 1056, 1234, 1056, 1056, 1234, 1155, 1139, 1190, 1192, 1247, 1287, 1287, 1056, 1056, 1055, 1203, 1219, 1223, 1056, 1056, 1092, 1180, 1221, 1239,
    1192, 1286, 1053, 1225, 1052, 1139, 1240, 1285, 1132, 1056, 1254, 1252, 1056, 1254, 1055, 1133, 1226, 1056, 1133, 1223, 1056, 1140, 1134, 1065, 1056, 1238,
    1240, 1285, 1132, 1128, 1132, 1056, 1056, 1147, 1199, 1252, 1063, 1128, 1063, 1128, 1284, 1284, 1277, 1277, 1277, 1056, 1145, 1056, 1056, 1056, 1067, 1139,
    1056, 1256, 1056, 1056, 1150, 1080, 1297, 1052, 1056, 1056, 1056, 1292, 1258, 1260, 1260, 1262, 1267, 1262, 1262, 1263, 1264, 1264, 1264, 1265, 1269, 1056,
    1056, 1056, 1194, 1194, 1283, 1056, 1056, 1056, 1227, 1122, 1300, 1056, 1056, 1197, 1200, 1203, 1056, 1056, 1227, 1152, 1291, 1203, 1056, 1056, 1291, 1203,
    1136, 1056, 1062, 1056, 1146, 1061, 1069, 1136, 1056, 1056, 1228, 1186, 1058, 1060, 1070, 1075, 1056, 1073, 1136, 1056, 1056, 1291, 1293, 1056, 1056, 1294,
    1056, 1056, 1056, 262660, 295424, 328192, 393728, 786944, 1311232, 4456960, 1074004480, -2147220992, 262656, 262656, 537134080, 426496, 852480, 4981248,
    786944, 262656, 266754, 787104, 1442436, 6161028, 284967424, 284967424, 285098496, 1560044032, 486302208, 486433280, 486531584, 486466048, 1560175104,
    1560207872, 262976, 265024, 394048, 1311552, 459584, 918336, 1442624, 1835840, 1966912, 50793340, 252119932, 262605692, 262605692, 263129980, 334457724,
    512, 0, -2147483648, -2147483648, 0, 0, 1, 2, 4, 8, 16, 0, 2, 32, 0, 3, 8, 32, 64, 128, 0, 4, 64, 256, 0, 6, 262144, 4, 536871936, 514, 2, 262146, 320, 256,
    65536, 131072, 524288, 12288, 16384, 0, 15, 48, 3136, 33554456, 28, 2048, 2304, 2304, 24, -1459599121, -1459599121, -1459598865, -1459074833, -1459598865,
    -1459074577, -1458812673, -1458811393, -1458811649, -1458811649, -69632, -69632, -65792, -67840, -67840, -65537, 0, 3648, 192, 16384, 65536, 16, 786432,
    2097152, 12582912, 16777216, 33554432, 67108864, 134217728, -2147483648, 536870912, 1073741824, -2147483648, 1024, 32, 128, 256, 64, 512, 1024, 1024, 4096,
    24576, 32768, 65536, 0, 7, 8, 64, 1024, 263168, 12288, 131072, 12582912, 33554432, 268435456, 1073741824, 524288, 12582912, 8388608, 268435456, 814918768,
    814919280, -4194561, -4194561, 0, 192512, 3932160, 8388608, 33554432, 201326592, 268435456, -2147483648, 814919280, 814919280, 40960, 131072, 268435456, 48,
    7872, 57344, 196608, 3932160, 62914560, -67108864, 0, 12288, 32768, 131072, 786432, 16777216, 100663296, 134217728, 256, 256, 2048, 0, 16, 16, 32, 256,
    2304, 0, 64, 2048, 8192, 12582912, 1536, 2048, 2112, 2304, 2368, 2048, 4096, 2097152, 16777216, 234881024, 268435456, 1024, 268435456, 8, 512, 536870912,
    512, 1024, 536870912, 0, 524288, 786432, 1048576, 2097152, 8388608, 0, 8192, 8388608, 16777216, -1476395008, 3, 1024, 786432, 100663296, 2, 524288, 1048576,
    8388608, 251658240, 268435456, 536870912, -2147483648, 524288, 67108864, 134217728, 1073741824, 2, 67108864, 16, 512, 7456, 7456, 7520, 7968, 7520, 7520,
    495, 495, 4591, 7520, 8032, 7663, 0, 67108864, 268435456, -536870912, 0, 16384, 16777216, 134217728, 134217728, 268435456, 0, 28672, 32768, 96, 0,
    134217728, 536870912, -1073741824, 0, 65536, 67108864, 0, 256, 4194304, 0, 128, 1536, 0, 512, 7, 232, 256
  "/>

  <!--~
   ! The token-string table.
  -->
  <xsl:variable name="p:TOKEN" as="xs:string+" select="
    '(0)',
    'AVTFixChar',
    'IntegerLiteral',
    'DecimalLiteral',
    'DoubleLiteral',
    'StringLiteral',
    'URIQualifiedName',
    'NCName',
    'QName',
    'S',
    'CommentContents',
    'Wildcard',
    'EOF',
    &quot;'!'&quot;,
    &quot;'!='&quot;,
    &quot;'#'&quot;,
    &quot;'$'&quot;,
    &quot;'('&quot;,
    &quot;'(:'&quot;,
    &quot;')'&quot;,
    &quot;'*'&quot;,
    &quot;'+'&quot;,
    &quot;','&quot;,
    &quot;'-'&quot;,
    &quot;'.'&quot;,
    &quot;'..'&quot;,
    &quot;'/'&quot;,
    &quot;'//'&quot;,
    &quot;':'&quot;,
    &quot;':)'&quot;,
    &quot;'::'&quot;,
    &quot;':='&quot;,
    &quot;'&lt;'&quot;,
    &quot;'&lt;&lt;'&quot;,
    &quot;'&lt;='&quot;,
    &quot;'='&quot;,
    &quot;'=&gt;'&quot;,
    &quot;'&gt;'&quot;,
    &quot;'&gt;='&quot;,
    &quot;'&gt;&gt;'&quot;,
    &quot;'?'&quot;,
    &quot;'@'&quot;,
    &quot;'['&quot;,
    &quot;']'&quot;,
    &quot;'ancestor'&quot;,
    &quot;'ancestor-or-self'&quot;,
    &quot;'and'&quot;,
    &quot;'array'&quot;,
    &quot;'as'&quot;,
    &quot;'attribute'&quot;,
    &quot;'cast'&quot;,
    &quot;'castable'&quot;,
    &quot;'child'&quot;,
    &quot;'comment'&quot;,
    &quot;'descendant'&quot;,
    &quot;'descendant-or-self'&quot;,
    &quot;'div'&quot;,
    &quot;'document-node'&quot;,
    &quot;'element'&quot;,
    &quot;'else'&quot;,
    &quot;'empty-sequence'&quot;,
    &quot;'eq'&quot;,
    &quot;'every'&quot;,
    &quot;'except'&quot;,
    &quot;'following'&quot;,
    &quot;'following-sibling'&quot;,
    &quot;'for'&quot;,
    &quot;'function'&quot;,
    &quot;'ge'&quot;,
    &quot;'gt'&quot;,
    &quot;'idiv'&quot;,
    &quot;'if'&quot;,
    &quot;'in'&quot;,
    &quot;'instance'&quot;,
    &quot;'intersect'&quot;,
    &quot;'is'&quot;,
    &quot;'item'&quot;,
    &quot;'le'&quot;,
    &quot;'let'&quot;,
    &quot;'lt'&quot;,
    &quot;'map'&quot;,
    &quot;'mod'&quot;,
    &quot;'namespace'&quot;,
    &quot;'namespace-node'&quot;,
    &quot;'ne'&quot;,
    &quot;'node'&quot;,
    &quot;'of'&quot;,
    &quot;'or'&quot;,
    &quot;'parent'&quot;,
    &quot;'preceding'&quot;,
    &quot;'preceding-sibling'&quot;,
    &quot;'processing-instruction'&quot;,
    &quot;'return'&quot;,
    &quot;'satisfies'&quot;,
    &quot;'schema-attribute'&quot;,
    &quot;'schema-element'&quot;,
    &quot;'self'&quot;,
    &quot;'some'&quot;,
    &quot;'switch'&quot;,
    &quot;'text'&quot;,
    &quot;'then'&quot;,
    &quot;'to'&quot;,
    &quot;'treat'&quot;,
    &quot;'typeswitch'&quot;,
    &quot;'union'&quot;,
    &quot;'{'&quot;,
    &quot;'|'&quot;,
    &quot;'||'&quot;,
    &quot;'}'&quot;
  "/>

  <!--~
   ! Match next token in input string, starting at given index, using
   ! the DFA entry state for the set of tokens that are expected in
   ! the current context.
   !
   ! @param $input the input string.
   ! @param $begin the index where to start in input string.
   ! @param $token-set the expected token set id.
   ! @return a sequence of three: the token code of the result token,
   ! with input string begin and end positions. If there is no valid
   ! token, return the negative id of the DFA state that failed, along
   ! with begin and end positions of the longest viable prefix.
  -->
  <xsl:function name="p:match" as="xs:integer+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="token-set" as="xs:integer"/>

    <xsl:variable name="result" select="$p:INITIAL[1 + $token-set]"/>
    <xsl:sequence select="p:transition($input, $begin, $begin, $begin, $result, $result mod 1024, 0)"/>
  </xsl:function>

  <!--~
   ! The DFA state transition function. If we are in a valid DFA state, save
   ! it's result annotation, consume one input codepoint, calculate the next
   ! state, and use tail recursion to do the same again. Otherwise, return
   ! any valid result or a negative DFA state id in case of an error.
   !
   ! @param $input the input string.
   ! @param $begin the begin index of the current token in the input string.
   ! @param $current the index of the current position in the input string.
   ! @param $end the end index of the result in the input string.
   ! @param $result the result code.
   ! @param $current-state the current DFA state.
   ! @param $previous-state the  previous DFA state.
   ! @return a sequence of three: the token code of the result token,
   ! with input string begin and end positions. If there is no valid
   ! token, return the negative id of the DFA state that failed, along
   ! with begin and end positions of the longest viable prefix.
  -->
  <xsl:function name="p:transition">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="current" as="xs:integer"/>
    <xsl:param name="end" as="xs:integer"/>
    <xsl:param name="result" as="xs:integer"/>
    <xsl:param name="current-state" as="xs:integer"/>
    <xsl:param name="previous-state" as="xs:integer"/>

    <xsl:choose>
      <xsl:when test="$current-state eq 0">
        <xsl:variable name="result" select="$result idiv 1024"/>
        <xsl:variable name="end" select="$end - $result idiv 128"/>
        <xsl:variable name="end" select="if ($end gt string-length($input)) then string-length($input) + 1 else $end"/>
        <xsl:sequence select="
          if ($result ne 0) then
          (
            $result mod 128 - 1,
            $begin,
            $end
          )
          else
          (
            - $previous-state,
            $begin,
            $current - 1
          )
        "/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="c0" select="(string-to-codepoints(substring($input, $current, 1)), 0)[1]"/>
        <xsl:variable name="c1" as="xs:integer">
          <xsl:choose>
            <xsl:when test="$c0 &lt; 128">
              <xsl:sequence select="$p:MAP0[1 + $c0]"/>
            </xsl:when>
            <xsl:when test="$c0 &lt; 55296">
              <xsl:variable name="c1" select="$c0 idiv 16"/>
              <xsl:variable name="c2" select="$c1 idiv 32"/>
              <xsl:sequence select="$p:MAP1[1 + $c0 mod 16 + $p:MAP1[1 + $c1 mod 32 + $p:MAP1[1 + $c2]]]"/>
            </xsl:when>
            <xsl:otherwise>
              <xsl:sequence select="p:map2($c0, 1, 6)"/>
            </xsl:otherwise>
          </xsl:choose>
        </xsl:variable>
        <xsl:variable name="current" select="$current + 1"/>
        <xsl:variable name="i0" select="1024 * $c1 + $current-state - 1"/>
        <xsl:variable name="i1" select="$i0 idiv 16"/>
        <xsl:variable name="next-state" select="$p:TRANSITION[$i0 mod 16 + $p:TRANSITION[$i1 + 1] + 1]"/>
        <xsl:sequence select="
          if ($next-state &gt; 1023) then
            p:transition($input, $begin, $current, $current, $next-state, $next-state mod 1024, $current-state)
          else
            p:transition($input, $begin, $current, $end, $result, $next-state, $current-state)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Recursively translate one 32-bit chunk of an expected token bitset
   ! to the corresponding sequence of token strings.
   !
   ! @param $result the result of previous recursion levels.
   ! @param $chunk the 32-bit chunk of the expected token bitset.
   ! @param $base-token-code the token code of bit 0 in the current chunk.
   ! @return the set of token strings.
  -->
  <xsl:function name="p:token">
    <xsl:param name="result" as="xs:string*"/>
    <xsl:param name="chunk" as="xs:integer"/>
    <xsl:param name="base-token-code" as="xs:integer"/>

    <xsl:sequence select="
      if ($chunk = 0) then
        $result
      else
        p:token
        (
          ($result, if ($chunk mod 2 != 0) then $p:TOKEN[$base-token-code] else ()),
          if ($chunk &lt; 0) then $chunk idiv 2 + 2147483648 else $chunk idiv 2,
          $base-token-code + 1
        )
    "/>
  </xsl:function>

  <!--~
   ! Calculate expected token set for a given DFA state as a sequence
   ! of strings.
   !
   ! @param $state the DFA state.
   ! @return the set of token strings
  -->
  <xsl:function name="p:expected-token-set" as="xs:string*">
    <xsl:param name="state" as="xs:integer"/>

    <xsl:if test="$state > 0">
      <xsl:for-each select="0 to 3">
        <xsl:variable name="i0" select=". * 834 + $state - 1"/>
        <xsl:variable name="i1" select="$i0 idiv 2"/>
        <xsl:variable name="i2" select="$i1 idiv 4"/>
        <xsl:sequence select="p:token((), $p:EXPECTED[$i0 mod 2 + $p:EXPECTED[$i1 mod 4 + $p:EXPECTED[$i2 + 1] + 1] + 1], . * 32 + 1)"/>
      </xsl:for-each>
    </xsl:if>
  </xsl:function>

  <!--~
   ! Classify codepoint by doing a tail recursive binary search for a
   ! matching codepoint range entry in MAP2, the codepoint to charclass
   ! map for codepoints above the surrogate block.
   !
   ! @param $c the codepoint.
   ! @param $lo the binary search lower bound map index.
   ! @param $hi the binary search upper bound map index.
   ! @return the character class.
  -->
  <xsl:function name="p:map2" as="xs:integer">
    <xsl:param name="c" as="xs:integer"/>
    <xsl:param name="lo" as="xs:integer"/>
    <xsl:param name="hi" as="xs:integer"/>

    <xsl:variable name="m" select="($hi + $lo) idiv 2"/>
    <xsl:choose>
      <xsl:when test="$lo &gt; $hi">
        <xsl:sequence select="0"/>
      </xsl:when>
      <xsl:when test="$p:MAP2[$m] &gt; $c">
        <xsl:sequence select="p:map2($c, $lo, $m - 1)"/>
      </xsl:when>
      <xsl:when test="$p:MAP2[6 + $m] &lt; $c">
        <xsl:sequence select="p:map2($c, $m + 1, $hi)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="$p:MAP2[12 + $m]"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Try parsing the 1st loop of production Comment (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:try-Comment-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1(14, $input, $state)"/>      <!-- CommentContents | ('(' ':') | (':' ')') -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] = 29">                                      <!-- (':' ')') -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 10">                                <!-- CommentContents -->
                  <xsl:variable name="state" select="p:consumeT(10, $input, $state)"/> <!-- CommentContents -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="
                    if ($state[$p:error]) then
                      $state
                    else
                      p:try-Comment($input, $state)
                  "/>
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:sequence select="p:try-Comment-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Try parsing Comment.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:try-Comment" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="state" select="p:consumeT(18, $input, $state)"/>            <!-- ('(' ':') -->
    <xsl:variable name="state" select="p:try-Comment-1($input, $state)"/>
    <xsl:variable name="state" select="p:consumeT(29, $input, $state)"/>            <!-- (':' ')') -->
    <xsl:sequence select="$state"/>
  </xsl:function>

  <!--~
   ! Try parsing Whitespace.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:try-Whitespace" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 9">                                         <!-- S^WS -->
          <xsl:variable name="state" select="p:consumeT(9, $input, $state)"/>       <!-- S^WS -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:try-Comment($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:sequence select="$state"/>
  </xsl:function>

  <!--~
   ! Parse NodeComp.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NodeComp" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 75">                                        <!-- 'is' -->
          <xsl:variable name="state" select="p:consume(75, $input, $state)"/>       <!-- 'is' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 33">                                        <!-- '<<' -->
          <xsl:variable name="state" select="p:consume(33, $input, $state)"/>       <!-- '<<' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(39, $input, $state)"/>       <!-- '>>' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NodeComp', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse GeneralComp.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-GeneralComp" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 35">                                        <!-- '=' -->
          <xsl:variable name="state" select="p:consume(35, $input, $state)"/>       <!-- '=' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 14">                                        <!-- '!=' -->
          <xsl:variable name="state" select="p:consume(14, $input, $state)"/>       <!-- '!=' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 32">                                        <!-- '<' -->
          <xsl:variable name="state" select="p:consume(32, $input, $state)"/>       <!-- '<' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 34">                                        <!-- '<=' -->
          <xsl:variable name="state" select="p:consume(34, $input, $state)"/>       <!-- '<=' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 37">                                        <!-- '>' -->
          <xsl:variable name="state" select="p:consume(37, $input, $state)"/>       <!-- '>' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(38, $input, $state)"/>       <!-- '>=' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'GeneralComp', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ValueComp.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ValueComp" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 61">                                        <!-- 'eq' -->
          <xsl:variable name="state" select="p:consume(61, $input, $state)"/>       <!-- 'eq' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 84">                                        <!-- 'ne' -->
          <xsl:variable name="state" select="p:consume(84, $input, $state)"/>       <!-- 'ne' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 79">                                        <!-- 'lt' -->
          <xsl:variable name="state" select="p:consume(79, $input, $state)"/>       <!-- 'lt' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 77">                                        <!-- 'le' -->
          <xsl:variable name="state" select="p:consume(77, $input, $state)"/>       <!-- 'le' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 69">                                        <!-- 'gt' -->
          <xsl:variable name="state" select="p:consume(69, $input, $state)"/>       <!-- 'gt' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(68, $input, $state)"/>       <!-- 'ge' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ValueComp', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SimpleTypeName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleTypeName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-TypeName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SimpleTypeName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SingleType.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SingleType" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SimpleTypeName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(32, $input, $state)"/>         <!-- S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' | '<' |
                                                                                         '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' | ']' | 'and' |
                                                                                         'castable' | 'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                                                         'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' |
                                                                                         'return' | 'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' |
                                                                                         '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 40">                                        <!-- '?' -->
          <xsl:variable name="state" select="p:consume(40, $input, $state)"/>       <!-- '?' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SingleType', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ArrowFunctionSpecifier.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArrowFunctionSpecifier" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 16">                                        <!-- '$' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-VarRef($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 17">                                        <!-- '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ParenthesizedExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-EQName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ArrowFunctionSpecifier', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production PredicateList (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PredicateList-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(34, $input, $state)"/>     <!-- S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' |
                                                                                         '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                                                         ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' | 'eq' | 'except' |
                                                                                         'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'lt' |
                                                                                         'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' | 'treat' |
                                                                                         'union' | '|' | '||' | '}' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 42">                                     <!-- '[' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-Predicate($input, $state)
            "/>
            <xsl:sequence select="p:parse-PredicateList-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse PredicateList.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PredicateList" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:parse-PredicateList-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PredicateList', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AbbrevForwardStep.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AbbrevForwardStep" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 41">                                        <!-- '@' -->
          <xsl:variable name="state" select="p:consume(41, $input, $state)"/>       <!-- '@' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | Wildcard | ('(' ':') |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-NodeTest($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AbbrevForwardStep', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ForwardAxis.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ForwardAxis" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 52">                                        <!-- 'child' -->
          <xsl:variable name="state" select="p:consume(52, $input, $state)"/>       <!-- 'child' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 54">                                        <!-- 'descendant' -->
          <xsl:variable name="state" select="p:consume(54, $input, $state)"/>       <!-- 'descendant' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 49">                                        <!-- 'attribute' -->
          <xsl:variable name="state" select="p:consume(49, $input, $state)"/>       <!-- 'attribute' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 96">                                        <!-- 'self' -->
          <xsl:variable name="state" select="p:consume(96, $input, $state)"/>       <!-- 'self' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 55">                                        <!-- 'descendant-or-self' -->
          <xsl:variable name="state" select="p:consume(55, $input, $state)"/>       <!-- 'descendant-or-self' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 65">                                        <!-- 'following-sibling' -->
          <xsl:variable name="state" select="p:consume(65, $input, $state)"/>       <!-- 'following-sibling' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 64">                                        <!-- 'following' -->
          <xsl:variable name="state" select="p:consume(64, $input, $state)"/>       <!-- 'following' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(82, $input, $state)"/>       <!-- 'namespace' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ForwardAxis', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ForwardStep.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ForwardStep" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 49">                                       <!-- 'attribute' -->
          <xsl:variable name="state" select="p:lookahead2W(39, $input, $state)"/>   <!-- S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         '/' | '//' | ':' | '::' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' |
                                                                                         '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                                                         'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                                                         'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = (52,                                          (: 'child' :)
                                         54,                                          (: 'descendant' :)
                                         55,                                          (: 'descendant-or-self' :)
                                         64,                                          (: 'following' :)
                                         65,                                          (: 'following-sibling' :)
                                         82,                                          (: 'namespace' :)
                                         96)">                                      <!-- 'self' -->
          <xsl:variable name="state" select="p:lookahead2W(36, $input, $state)"/>   <!-- S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' |
                                                                                         '//' | ':' | '::' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' |
                                                                                         '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                                                         'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                                                         'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 3889                                          (: 'attribute' '::' :)
                     or $state[$p:lk] = 3892                                          (: 'child' '::' :)
                     or $state[$p:lk] = 3894                                          (: 'descendant' '::' :)
                     or $state[$p:lk] = 3895                                          (: 'descendant-or-self' '::' :)
                     or $state[$p:lk] = 3904                                          (: 'following' '::' :)
                     or $state[$p:lk] = 3905                                          (: 'following-sibling' '::' :)
                     or $state[$p:lk] = 3922                                          (: 'namespace' '::' :)
                     or $state[$p:lk] = 3936">                                      <!-- 'self' '::' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ForwardAxis($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | Wildcard | ('(' ':') |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NodeTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AbbrevForwardStep($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ForwardStep', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AbbrevReverseStep.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AbbrevReverseStep" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(25, $input, $state)"/>             <!-- '..' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AbbrevReverseStep', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse NameTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NameTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 11">                                        <!-- Wildcard -->
          <xsl:variable name="state" select="p:consume(11, $input, $state)"/>       <!-- Wildcard -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-EQName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NameTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse NodeTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NodeTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] = (49,                                          (: 'attribute' :)
                                         53,                                          (: 'comment' :)
                                         57,                                          (: 'document-node' :)
                                         58,                                          (: 'element' :)
                                         83,                                          (: 'namespace-node' :)
                                         85,                                          (: 'node' :)
                                         91,                                          (: 'processing-instruction' :)
                                         94,                                          (: 'schema-attribute' :)
                                         95,                                          (: 'schema-element' :)
                                         99)">                                      <!-- 'text' -->
          <xsl:variable name="state" select="p:lookahead2W(35, $input, $state)"/>   <!-- S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                                                         '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' | 'eq' |
                                                                                         'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                                                         'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' |
                                                                                         'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2225                                          (: 'attribute' '(' :)
                     or $state[$p:lk] = 2229                                          (: 'comment' '(' :)
                     or $state[$p:lk] = 2233                                          (: 'document-node' '(' :)
                     or $state[$p:lk] = 2234                                          (: 'element' '(' :)
                     or $state[$p:lk] = 2259                                          (: 'namespace-node' '(' :)
                     or $state[$p:lk] = 2261                                          (: 'node' '(' :)
                     or $state[$p:lk] = 2267                                          (: 'processing-instruction' '(' :)
                     or $state[$p:lk] = 2270                                          (: 'schema-attribute' '(' :)
                     or $state[$p:lk] = 2271                                          (: 'schema-element' '(' :)
                     or $state[$p:lk] = 2275">                                      <!-- 'text' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-KindTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NameTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NodeTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ReverseAxis.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ReverseAxis" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 88">                                        <!-- 'parent' -->
          <xsl:variable name="state" select="p:consume(88, $input, $state)"/>       <!-- 'parent' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 44">                                        <!-- 'ancestor' -->
          <xsl:variable name="state" select="p:consume(44, $input, $state)"/>       <!-- 'ancestor' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 90">                                        <!-- 'preceding-sibling' -->
          <xsl:variable name="state" select="p:consume(90, $input, $state)"/>       <!-- 'preceding-sibling' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 89">                                        <!-- 'preceding' -->
          <xsl:variable name="state" select="p:consume(89, $input, $state)"/>       <!-- 'preceding' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(45, $input, $state)"/>       <!-- 'ancestor-or-self' -->
          <xsl:variable name="state" select="p:lookahead1W(7, $input, $state)"/>    <!-- S^WS | ('(' ':') | '::' -->
          <xsl:variable name="state" select="p:consume(30, $input, $state)"/>       <!-- '::' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ReverseAxis', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ReverseStep.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ReverseStep" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 25">                                        <!-- '..' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AbbrevReverseStep($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ReverseAxis($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(44, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | Wildcard | ('(' ':') |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NodeTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ReverseStep', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AxisStep.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AxisStep" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] = (44,                                          (: 'ancestor' :)
                                         45,                                          (: 'ancestor-or-self' :)
                                         88,                                          (: 'parent' :)
                                         89,                                          (: 'preceding' :)
                                         90)">                                      <!-- 'preceding-sibling' -->
          <xsl:variable name="state" select="p:lookahead2W(36, $input, $state)"/>   <!-- S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' |
                                                                                         '//' | ':' | '::' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' |
                                                                                         '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                                                         'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                                                         'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 25                                            (: '..' :)
                     or $state[$p:lk] = 3884                                          (: 'ancestor' '::' :)
                     or $state[$p:lk] = 3885                                          (: 'ancestor-or-self' '::' :)
                     or $state[$p:lk] = 3928                                          (: 'parent' '::' :)
                     or $state[$p:lk] = 3929                                          (: 'preceding' '::' :)
                     or $state[$p:lk] = 3930">                                      <!-- 'preceding-sibling' '::' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ReverseStep($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ForwardStep($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(34, $input, $state)"/>         <!-- S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' |
                                                                                         '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                                                         ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' | 'eq' | 'except' |
                                                                                         'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'lt' |
                                                                                         'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' | 'treat' |
                                                                                         'union' | '|' | '||' | '}' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-PredicateList($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AxisStep', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Lookup.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Lookup" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(40, $input, $state)"/>             <!-- '?' -->
    <xsl:variable name="state" select="p:lookahead1W(24, $input, $state)"/>         <!-- IntegerLiteral | NCName | S^WS | '(' | ('(' ':') | '*' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-KeySpecifier($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Lookup', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Predicate.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Predicate" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(42, $input, $state)"/>             <!-- '[' -->
    <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-Expr($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(43, $input, $state)"/>             <!-- ']' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Predicate', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse KeySpecifier.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-KeySpecifier" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 7">                                         <!-- NCName -->
          <xsl:variable name="state" select="p:consume(7, $input, $state)"/>        <!-- NCName -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 2">                                         <!-- IntegerLiteral -->
          <xsl:variable name="state" select="p:consume(2, $input, $state)"/>        <!-- IntegerLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 17">                                        <!-- '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ParenthesizedExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(20, $input, $state)"/>       <!-- '*' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'KeySpecifier', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse UnaryLookup.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-UnaryLookup" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(40, $input, $state)"/>             <!-- '?' -->
    <xsl:variable name="state" select="p:lookahead1W(24, $input, $state)"/>         <!-- IntegerLiteral | NCName | S^WS | '(' | ('(' ':') | '*' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-KeySpecifier($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'UnaryLookup', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse CurlyArrayConstructor.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-CurlyArrayConstructor" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(47, $input, $state)"/>             <!-- 'array' -->
    <xsl:variable name="state" select="p:lookahead1W(13, $input, $state)"/>         <!-- S^WS | ('(' ':') | '{' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EnclosedExpr($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'CurlyArrayConstructor', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production SquareArrayConstructor (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SquareArrayConstructor-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ExprSingle($input, $state)
            "/>
            <xsl:sequence select="p:parse-SquareArrayConstructor-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse SquareArrayConstructor.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SquareArrayConstructor" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(42, $input, $state)"/>             <!-- '[' -->
    <xsl:variable name="state" select="p:lookahead1W(56, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         ']' | 'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 43">                                       <!-- ']' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ExprSingle($input, $state)
          "/>
          <xsl:variable name="state" select="p:parse-SquareArrayConstructor-1($input, $state)"/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(43, $input, $state)"/>             <!-- ']' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SquareArrayConstructor', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ArrayConstructor.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArrayConstructor" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 42">                                        <!-- '[' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SquareArrayConstructor($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-CurlyArrayConstructor($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ArrayConstructor', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse MapValueExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MapValueExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'MapValueExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse MapKeyExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MapKeyExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'MapKeyExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse MapConstructorEntry.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MapConstructorEntry" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-MapKeyExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(28, $input, $state)"/>             <!-- ':' -->
    <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-MapValueExpr($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'MapConstructorEntry', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production MapConstructor (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MapConstructor-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-MapConstructorEntry($input, $state)
            "/>
            <xsl:sequence select="p:parse-MapConstructor-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse MapConstructor.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MapConstructor" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(80, $input, $state)"/>             <!-- 'map' -->
    <xsl:variable name="state" select="p:lookahead1W(13, $input, $state)"/>         <!-- S^WS | ('(' ':') | '{' -->
    <xsl:variable name="state" select="p:consume(105, $input, $state)"/>            <!-- '{' -->
    <xsl:variable name="state" select="p:lookahead1W(57, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' | '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 108">                                      <!-- '}' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-MapConstructorEntry($input, $state)
          "/>
          <xsl:variable name="state" select="p:parse-MapConstructor-1($input, $state)"/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(108, $input, $state)"/>            <!-- '}' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'MapConstructor', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse EnclosedExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-EnclosedExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(105, $input, $state)"/>            <!-- '{' -->
    <xsl:variable name="state" select="p:lookahead1W(57, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' | '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 108">                                      <!-- '}' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-Expr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(108, $input, $state)"/>            <!-- '}' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'EnclosedExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FunctionBody.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionBody" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EnclosedExpr($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionBody', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse OccurrenceIndicator.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-OccurrenceIndicator" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 40">                                        <!-- '?' -->
          <xsl:variable name="state" select="p:consume(40, $input, $state)"/>       <!-- '?' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 20">                                        <!-- '*' -->
          <xsl:variable name="state" select="p:consume(20, $input, $state)"/>       <!-- '*' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(21, $input, $state)"/>       <!-- '+' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'OccurrenceIndicator', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ParenthesizedItemType.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ParenthesizedItemType" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(45, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ItemType($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ParenthesizedItemType', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TypedArrayTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TypedArrayTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(47, $input, $state)"/>             <!-- 'array' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(45, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SequenceType($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TypedArrayTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AnyArrayTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AnyArrayTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(47, $input, $state)"/>             <!-- 'array' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | ('(' ':') | '*' -->
    <xsl:variable name="state" select="p:consume(20, $input, $state)"/>             <!-- '*' -->
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AnyArrayTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ArrayTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArrayTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 47">                                       <!-- 'array' -->
          <xsl:variable name="state" select="p:lookahead2W(3, $input, $state)"/>    <!-- S^WS | '(' | ('(' ':') -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:lk] eq 2223">                               <!-- 'array' '(' -->
                <xsl:variable name="state" select="p:lookahead3W(49, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | '*' |
                                                                                             'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                             'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                             'descendant-or-self' | 'div' | 'document-node' | 'element' |
                                                                                             'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                             'following' | 'following-sibling' | 'for' | 'function' | 'ge' |
                                                                                             'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                             'le' | 'let' | 'lt' | 'map' | 'mod' | 'namespace' |
                                                                                             'namespace-node' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                             'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                             'satisfies' | 'schema-attribute' | 'schema-element' | 'self' |
                                                                                             'some' | 'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                                                             'union' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 329903">                                    <!-- 'array' '(' '*' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AnyArrayTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypedArrayTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ArrayTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AtomicOrUnionType.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AtomicOrUnionType" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EQName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AtomicOrUnionType', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TypedMapTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TypedMapTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(80, $input, $state)"/>             <!-- 'map' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AtomicOrUnionType($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(6, $input, $state)"/>          <!-- S^WS | ('(' ':') | ',' -->
    <xsl:variable name="state" select="p:consume(22, $input, $state)"/>             <!-- ',' -->
    <xsl:variable name="state" select="p:lookahead1W(45, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SequenceType($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TypedMapTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AnyMapTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AnyMapTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(80, $input, $state)"/>             <!-- 'map' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | ('(' ':') | '*' -->
    <xsl:variable name="state" select="p:consume(20, $input, $state)"/>             <!-- '*' -->
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AnyMapTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse MapTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MapTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 80">                                       <!-- 'map' -->
          <xsl:variable name="state" select="p:lookahead2W(3, $input, $state)"/>    <!-- S^WS | '(' | ('(' ':') -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:lk] eq 2256">                               <!-- 'map' '(' -->
                <xsl:variable name="state" select="p:lookahead3W(46, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | '*' |
                                                                                             'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                             'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                             'descendant-or-self' | 'div' | 'document-node' | 'element' |
                                                                                             'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                             'following' | 'following-sibling' | 'for' | 'function' | 'ge' |
                                                                                             'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                             'le' | 'let' | 'lt' | 'map' | 'mod' | 'namespace' |
                                                                                             'namespace-node' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                             'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                             'satisfies' | 'schema-attribute' | 'schema-element' | 'self' |
                                                                                             'some' | 'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                                                             'union' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 329936">                                    <!-- 'map' '(' '*' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AnyMapTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypedMapTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'MapTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production TypedFunctionTest (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TypedFunctionTest-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(17, $input, $state)"/>     <!-- S^WS | ('(' ':') | ')' | ',' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(45, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-SequenceType($input, $state)
            "/>
            <xsl:sequence select="p:parse-TypedFunctionTest-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse TypedFunctionTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TypedFunctionTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(67, $input, $state)"/>             <!-- 'function' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(48, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | ')' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 19">                                       <!-- ')' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SequenceType($input, $state)
          "/>
          <xsl:variable name="state" select="p:parse-TypedFunctionTest-1($input, $state)"/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>          <!-- S^WS | ('(' ':') | 'as' -->
    <xsl:variable name="state" select="p:consume(48, $input, $state)"/>             <!-- 'as' -->
    <xsl:variable name="state" select="p:lookahead1W(45, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SequenceType($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TypedFunctionTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AnyFunctionTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AnyFunctionTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(67, $input, $state)"/>             <!-- 'function' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(5, $input, $state)"/>          <!-- S^WS | ('(' ':') | '*' -->
    <xsl:variable name="state" select="p:consume(20, $input, $state)"/>             <!-- '*' -->
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AnyFunctionTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FunctionTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 67">                                       <!-- 'function' -->
          <xsl:variable name="state" select="p:lookahead2W(3, $input, $state)"/>    <!-- S^WS | '(' | ('(' ':') -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:lk] eq 2243">                               <!-- 'function' '(' -->
                <xsl:variable name="state" select="p:lookahead3W(51, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | ')' |
                                                                                             '*' | 'ancestor' | 'ancestor-or-self' | 'and' | 'array' |
                                                                                             'attribute' | 'cast' | 'castable' | 'child' | 'comment' |
                                                                                             'descendant' | 'descendant-or-self' | 'div' | 'document-node' |
                                                                                             'element' | 'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                             'following' | 'following-sibling' | 'for' | 'function' | 'ge' |
                                                                                             'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                             'le' | 'let' | 'lt' | 'map' | 'mod' | 'namespace' |
                                                                                             'namespace-node' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                             'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                             'satisfies' | 'schema-attribute' | 'schema-element' | 'self' |
                                                                                             'some' | 'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                                                             'union' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 329923">                                    <!-- 'function' '(' '*' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AnyFunctionTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypedFunctionTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AnyKindTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AnyKindTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(85, $input, $state)"/>             <!-- 'node' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AnyKindTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse NamespaceNodeTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NamespaceNodeTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(83, $input, $state)"/>             <!-- 'namespace-node' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NamespaceNodeTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TextTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TextTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(99, $input, $state)"/>             <!-- 'text' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TextTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse CommentTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-CommentTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(53, $input, $state)"/>             <!-- 'comment' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'CommentTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse PITest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PITest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(91, $input, $state)"/>             <!-- 'processing-instruction' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(21, $input, $state)"/>         <!-- StringLiteral | NCName | S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 19">                                       <!-- ')' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 7">                                   <!-- NCName -->
                <xsl:variable name="state" select="p:consume(7, $input, $state)"/>  <!-- NCName -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="p:consume(5, $input, $state)"/>  <!-- StringLiteral -->
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PITest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AttributeDeclaration.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AttributeDeclaration" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AttributeName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AttributeDeclaration', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SchemaAttributeTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SchemaAttributeTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(94, $input, $state)"/>             <!-- 'schema-attribute' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AttributeDeclaration($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SchemaAttributeTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AttributeName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AttributeName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EQName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AttributeName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AttribNameOrWildcard.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AttribNameOrWildcard" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 20">                                        <!-- '*' -->
          <xsl:variable name="state" select="p:consume(20, $input, $state)"/>       <!-- '*' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AttributeName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AttribNameOrWildcard', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AttributeTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AttributeTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(49, $input, $state)"/>             <!-- 'attribute' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(50, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' | '*' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 19">                                       <!-- ')' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AttribNameOrWildcard($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(17, $input, $state)"/>   <!-- S^WS | ('(' ':') | ')' | ',' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 22">                                  <!-- ',' -->
                <xsl:variable name="state" select="p:consume(22, $input, $state)"/> <!-- ',' -->
                <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                             'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                             'castable' | 'child' | 'comment' | 'descendant' |
                                                                                             'descendant-or-self' | 'div' | 'document-node' | 'element' |
                                                                                             'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                             'following' | 'following-sibling' | 'for' | 'function' | 'ge' |
                                                                                             'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                             'le' | 'let' | 'lt' | 'map' | 'mod' | 'namespace' |
                                                                                             'namespace-node' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                             'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                             'satisfies' | 'schema-attribute' | 'schema-element' | 'self' |
                                                                                             'some' | 'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                                                             'union' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-TypeName($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AttributeTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ElementDeclaration.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ElementDeclaration" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ElementName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ElementDeclaration', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SchemaElementTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SchemaElementTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(95, $input, $state)"/>             <!-- 'schema-element' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ElementDeclaration($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SchemaElementTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TypeName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TypeName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EQName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TypeName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ElementName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ElementName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EQName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ElementName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ElementNameOrWildcard.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ElementNameOrWildcard" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 20">                                        <!-- '*' -->
          <xsl:variable name="state" select="p:consume(20, $input, $state)"/>       <!-- '*' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ElementName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ElementNameOrWildcard', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ElementTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ElementTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(58, $input, $state)"/>             <!-- 'element' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(50, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | ')' | '*' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 19">                                       <!-- ')' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ElementNameOrWildcard($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(17, $input, $state)"/>   <!-- S^WS | ('(' ':') | ')' | ',' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 22">                                  <!-- ',' -->
                <xsl:variable name="state" select="p:consume(22, $input, $state)"/> <!-- ',' -->
                <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                             'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                             'castable' | 'child' | 'comment' | 'descendant' |
                                                                                             'descendant-or-self' | 'div' | 'document-node' | 'element' |
                                                                                             'else' | 'empty-sequence' | 'eq' | 'every' | 'except' |
                                                                                             'following' | 'following-sibling' | 'for' | 'function' | 'ge' |
                                                                                             'gt' | 'idiv' | 'if' | 'instance' | 'intersect' | 'is' | 'item' |
                                                                                             'le' | 'let' | 'lt' | 'map' | 'mod' | 'namespace' |
                                                                                             'namespace-node' | 'ne' | 'node' | 'or' | 'parent' | 'preceding' |
                                                                                             'preceding-sibling' | 'processing-instruction' | 'return' |
                                                                                             'satisfies' | 'schema-attribute' | 'schema-element' | 'self' |
                                                                                             'some' | 'switch' | 'text' | 'to' | 'treat' | 'typeswitch' |
                                                                                             'union' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-TypeName($input, $state)
                "/>
                <xsl:variable name="state" select="p:lookahead1W(18, $input, $state)"/> <!-- S^WS | ('(' ':') | ')' | '?' -->
                <xsl:variable name="state" as="item()+">
                  <xsl:choose>
                    <xsl:when test="$state[$p:error]">
                      <xsl:sequence select="$state"/>
                    </xsl:when>
                    <xsl:when test="$state[$p:l1] = 40">                            <!-- '?' -->
                      <xsl:variable name="state" select="p:consume(40, $input, $state)"/> <!-- '?' -->
                      <xsl:sequence select="$state"/>
                    </xsl:when>
                    <xsl:otherwise>
                      <xsl:sequence select="$state"/>
                    </xsl:otherwise>
                  </xsl:choose>
                </xsl:variable>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ElementTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse DocumentTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-DocumentTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(57, $input, $state)"/>             <!-- 'document-node' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(23, $input, $state)"/>         <!-- S^WS | ('(' ':') | ')' | 'element' | 'schema-element' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 19">                                       <!-- ')' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 58">                                  <!-- 'element' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-ElementTest($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-SchemaElementTest($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>          <!-- S^WS | ('(' ':') | ')' -->
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'DocumentTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse KindTest.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-KindTest" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 57">                                        <!-- 'document-node' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-DocumentTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 58">                                        <!-- 'element' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ElementTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 49">                                        <!-- 'attribute' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AttributeTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 95">                                        <!-- 'schema-element' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SchemaElementTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 94">                                        <!-- 'schema-attribute' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SchemaAttributeTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 91">                                        <!-- 'processing-instruction' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-PITest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 53">                                        <!-- 'comment' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-CommentTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 99">                                        <!-- 'text' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-TextTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 83">                                        <!-- 'namespace-node' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NamespaceNodeTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AnyKindTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'KindTest', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ItemType.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ItemType" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] = (47,                                          (: 'array' :)
                                         49,                                          (: 'attribute' :)
                                         53,                                          (: 'comment' :)
                                         57,                                          (: 'document-node' :)
                                         58,                                          (: 'element' :)
                                         67,                                          (: 'function' :)
                                         76,                                          (: 'item' :)
                                         80,                                          (: 'map' :)
                                         83,                                          (: 'namespace-node' :)
                                         85,                                          (: 'node' :)
                                         91,                                          (: 'processing-instruction' :)
                                         94,                                          (: 'schema-attribute' :)
                                         95,                                          (: 'schema-element' :)
                                         99)">                                      <!-- 'text' -->
          <xsl:variable name="state" select="p:lookahead2W(31, $input, $state)"/>   <!-- S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' |
                                                                                         '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' | ']' | 'and' |
                                                                                         'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'union' | '{' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2225                                          (: 'attribute' '(' :)
                     or $state[$p:lk] = 2229                                          (: 'comment' '(' :)
                     or $state[$p:lk] = 2233                                          (: 'document-node' '(' :)
                     or $state[$p:lk] = 2234                                          (: 'element' '(' :)
                     or $state[$p:lk] = 2259                                          (: 'namespace-node' '(' :)
                     or $state[$p:lk] = 2261                                          (: 'node' '(' :)
                     or $state[$p:lk] = 2267                                          (: 'processing-instruction' '(' :)
                     or $state[$p:lk] = 2270                                          (: 'schema-attribute' '(' :)
                     or $state[$p:lk] = 2271                                          (: 'schema-element' '(' :)
                     or $state[$p:lk] = 2275">                                      <!-- 'text' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-KindTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2252">                                      <!-- 'item' '(' -->
          <xsl:variable name="state" select="p:consume(76, $input, $state)"/>       <!-- 'item' -->
          <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>    <!-- S^WS | '(' | ('(' ':') -->
          <xsl:variable name="state" select="p:consume(17, $input, $state)"/>       <!-- '(' -->
          <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>    <!-- S^WS | ('(' ':') | ')' -->
          <xsl:variable name="state" select="p:consume(19, $input, $state)"/>       <!-- ')' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2243">                                      <!-- 'function' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-FunctionTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2256">                                      <!-- 'map' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-MapTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2223">                                      <!-- 'array' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ArrayTest($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 17">                                        <!-- '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ParenthesizedItemType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AtomicOrUnionType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ItemType', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SequenceType.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SequenceType" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 60">                                       <!-- 'empty-sequence' -->
          <xsl:variable name="state" select="p:lookahead2W(31, $input, $state)"/>   <!-- S^WS | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' |
                                                                                         '<' | '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' | ']' | 'and' |
                                                                                         'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'union' | '{' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2236">                                      <!-- 'empty-sequence' '(' -->
          <xsl:variable name="state" select="p:consume(60, $input, $state)"/>       <!-- 'empty-sequence' -->
          <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>    <!-- S^WS | '(' | ('(' ':') -->
          <xsl:variable name="state" select="p:consume(17, $input, $state)"/>       <!-- '(' -->
          <xsl:variable name="state" select="p:lookahead1W(4, $input, $state)"/>    <!-- S^WS | ('(' ':') | ')' -->
          <xsl:variable name="state" select="p:consume(19, $input, $state)"/>       <!-- ')' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ItemType($input, $state)
          "/>
          <xsl:variable name="state" select="p:lookahead1W(29, $input, $state)"/>   <!-- S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' | '<' |
                                                                                         '<<' | '<=' | '=' | '>' | '>=' | '>>' | '?' | ']' | 'and' | 'div' |
                                                                                         'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'union' | '{' | '|' | '||' | '}' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 20                                      (: '*' :)
                           or $state[$p:l1] = 21                                      (: '+' :)
                           or $state[$p:l1] = 40">                                  <!-- '?' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-OccurrenceIndicator($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SequenceType', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TypeDeclaration.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TypeDeclaration" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(48, $input, $state)"/>             <!-- 'as' -->
    <xsl:variable name="state" select="p:lookahead1W(45, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SequenceType($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TypeDeclaration', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Param.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Param" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '$' -->
    <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EQName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(22, $input, $state)"/>         <!-- S^WS | ('(' ':') | ')' | ',' | 'as' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 48">                                        <!-- 'as' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-TypeDeclaration($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Param', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production ParamList (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ParamList-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(17, $input, $state)"/>     <!-- S^WS | ('(' ':') | ')' | ',' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>  <!-- S^WS | '$' | ('(' ':') -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-Param($input, $state)
            "/>
            <xsl:sequence select="p:parse-ParamList-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse ParamList.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ParamList" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-Param($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-ParamList-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ParamList', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse InlineFunctionExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-InlineFunctionExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(67, $input, $state)"/>             <!-- 'function' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(16, $input, $state)"/>         <!-- S^WS | '$' | ('(' ':') | ')' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 16">                                        <!-- '$' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ParamList($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="state" select="p:lookahead1W(19, $input, $state)"/>         <!-- S^WS | ('(' ':') | 'as' | '{' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 48">                                        <!-- 'as' -->
          <xsl:variable name="state" select="p:consume(48, $input, $state)"/>       <!-- 'as' -->
          <xsl:variable name="state" select="p:lookahead1W(45, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SequenceType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(13, $input, $state)"/>         <!-- S^WS | ('(' ':') | '{' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-FunctionBody($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'InlineFunctionExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse NamedFunctionRef.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NamedFunctionRef" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-FunctionEQName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(1, $input, $state)"/>          <!-- S^WS | '#' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(15, $input, $state)"/>             <!-- '#' -->
    <xsl:variable name="state" select="p:lookahead1W(0, $input, $state)"/>          <!-- IntegerLiteral | S^WS | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(2, $input, $state)"/>              <!-- IntegerLiteral -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NamedFunctionRef', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FunctionItemExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionItemExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 67">                                        <!-- 'function' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-InlineFunctionExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NamedFunctionRef($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionItemExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ArgumentPlaceholder.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArgumentPlaceholder" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(40, $input, $state)"/>             <!-- '?' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ArgumentPlaceholder', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Argument.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Argument" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 40">                                       <!-- '?' -->
          <xsl:variable name="state" select="p:lookahead2W(25, $input, $state)"/>   <!-- IntegerLiteral | NCName | S^WS | '(' | ('(' ':') | ')' | '*' | ',' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2472                                          (: '?' ')' :)
                     or $state[$p:lk] = 2856">                                      <!-- '?' ',' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ArgumentPlaceholder($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ExprSingle($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Argument', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production ArgumentList (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArgumentList-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(17, $input, $state)"/>     <!-- S^WS | ('(' ':') | ')' | ',' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-Argument($input, $state)
            "/>
            <xsl:sequence select="p:parse-ArgumentList-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse ArgumentList.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArgumentList" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | ')' | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' |
                                                                                         '[' | 'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 19">                                       <!-- ')' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-Argument($input, $state)
          "/>
          <xsl:variable name="state" select="p:parse-ArgumentList-1($input, $state)"/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ArgumentList', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FunctionEQName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionEQName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 6">                                         <!-- URIQualifiedName -->
          <xsl:variable name="state" select="p:consume(6, $input, $state)"/>        <!-- URIQualifiedName -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-FunctionName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionEQName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FunctionCall.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionCall" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-FunctionEQName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ArgumentList($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionCall', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ContextItemExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ContextItemExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(24, $input, $state)"/>             <!-- '.' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ContextItemExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ParenthesizedExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ParenthesizedExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(55, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | ')' | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' |
                                                                                         '[' | 'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 19">                                       <!-- ')' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-Expr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ParenthesizedExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse VarRef.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-VarRef" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '$' -->
    <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-VarName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'VarRef', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse NumericLiteral.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-NumericLiteral" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 2">                                         <!-- IntegerLiteral -->
          <xsl:variable name="state" select="p:consume(2, $input, $state)"/>        <!-- IntegerLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 3">                                         <!-- DecimalLiteral -->
          <xsl:variable name="state" select="p:consume(3, $input, $state)"/>        <!-- DecimalLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(4, $input, $state)"/>        <!-- DoubleLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'NumericLiteral', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse Literal.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Literal" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 5">                                         <!-- StringLiteral -->
          <xsl:variable name="state" select="p:consume(5, $input, $state)"/>        <!-- StringLiteral -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-NumericLiteral($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Literal', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse PrimaryExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PrimaryExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] = (6,                                           (: URIQualifiedName :)
                                         8,                                           (: QName^Token :)
                                         44,                                          (: 'ancestor' :)
                                         45,                                          (: 'ancestor-or-self' :)
                                         46,                                          (: 'and' :)
                                         50,                                          (: 'cast' :)
                                         51,                                          (: 'castable' :)
                                         52,                                          (: 'child' :)
                                         54,                                          (: 'descendant' :)
                                         55,                                          (: 'descendant-or-self' :)
                                         56,                                          (: 'div' :)
                                         59,                                          (: 'else' :)
                                         61,                                          (: 'eq' :)
                                         62,                                          (: 'every' :)
                                         63,                                          (: 'except' :)
                                         64,                                          (: 'following' :)
                                         65,                                          (: 'following-sibling' :)
                                         66,                                          (: 'for' :)
                                         68,                                          (: 'ge' :)
                                         69,                                          (: 'gt' :)
                                         70,                                          (: 'idiv' :)
                                         73,                                          (: 'instance' :)
                                         74,                                          (: 'intersect' :)
                                         75,                                          (: 'is' :)
                                         77,                                          (: 'le' :)
                                         78,                                          (: 'let' :)
                                         79,                                          (: 'lt' :)
                                         81,                                          (: 'mod' :)
                                         82,                                          (: 'namespace' :)
                                         84,                                          (: 'ne' :)
                                         87,                                          (: 'or' :)
                                         88,                                          (: 'parent' :)
                                         89,                                          (: 'preceding' :)
                                         90,                                          (: 'preceding-sibling' :)
                                         92,                                          (: 'return' :)
                                         93,                                          (: 'satisfies' :)
                                         96,                                          (: 'self' :)
                                         97,                                          (: 'some' :)
                                         101,                                         (: 'to' :)
                                         102,                                         (: 'treat' :)
                                         104)">                                     <!-- 'union' -->
          <xsl:variable name="state" select="p:lookahead2W(15, $input, $state)"/>   <!-- S^WS | '#' | '(' | ('(' ':') -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2                                             (: IntegerLiteral :)
                     or $state[$p:lk] = 3                                             (: DecimalLiteral :)
                     or $state[$p:lk] = 4                                             (: DoubleLiteral :)
                     or $state[$p:lk] = 5">                                         <!-- StringLiteral -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-Literal($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 16">                                        <!-- '$' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-VarRef($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 17">                                        <!-- '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ParenthesizedExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 24">                                        <!-- '.' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ContextItemExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2182                                          (: URIQualifiedName '(' :)
                     or $state[$p:lk] = 2184                                          (: QName^Token '(' :)
                     or $state[$p:lk] = 2220                                          (: 'ancestor' '(' :)
                     or $state[$p:lk] = 2221                                          (: 'ancestor-or-self' '(' :)
                     or $state[$p:lk] = 2222                                          (: 'and' '(' :)
                     or $state[$p:lk] = 2226                                          (: 'cast' '(' :)
                     or $state[$p:lk] = 2227                                          (: 'castable' '(' :)
                     or $state[$p:lk] = 2228                                          (: 'child' '(' :)
                     or $state[$p:lk] = 2230                                          (: 'descendant' '(' :)
                     or $state[$p:lk] = 2231                                          (: 'descendant-or-self' '(' :)
                     or $state[$p:lk] = 2232                                          (: 'div' '(' :)
                     or $state[$p:lk] = 2235                                          (: 'else' '(' :)
                     or $state[$p:lk] = 2237                                          (: 'eq' '(' :)
                     or $state[$p:lk] = 2238                                          (: 'every' '(' :)
                     or $state[$p:lk] = 2239                                          (: 'except' '(' :)
                     or $state[$p:lk] = 2240                                          (: 'following' '(' :)
                     or $state[$p:lk] = 2241                                          (: 'following-sibling' '(' :)
                     or $state[$p:lk] = 2242                                          (: 'for' '(' :)
                     or $state[$p:lk] = 2244                                          (: 'ge' '(' :)
                     or $state[$p:lk] = 2245                                          (: 'gt' '(' :)
                     or $state[$p:lk] = 2246                                          (: 'idiv' '(' :)
                     or $state[$p:lk] = 2249                                          (: 'instance' '(' :)
                     or $state[$p:lk] = 2250                                          (: 'intersect' '(' :)
                     or $state[$p:lk] = 2251                                          (: 'is' '(' :)
                     or $state[$p:lk] = 2253                                          (: 'le' '(' :)
                     or $state[$p:lk] = 2254                                          (: 'let' '(' :)
                     or $state[$p:lk] = 2255                                          (: 'lt' '(' :)
                     or $state[$p:lk] = 2257                                          (: 'mod' '(' :)
                     or $state[$p:lk] = 2258                                          (: 'namespace' '(' :)
                     or $state[$p:lk] = 2260                                          (: 'ne' '(' :)
                     or $state[$p:lk] = 2263                                          (: 'or' '(' :)
                     or $state[$p:lk] = 2264                                          (: 'parent' '(' :)
                     or $state[$p:lk] = 2265                                          (: 'preceding' '(' :)
                     or $state[$p:lk] = 2266                                          (: 'preceding-sibling' '(' :)
                     or $state[$p:lk] = 2268                                          (: 'return' '(' :)
                     or $state[$p:lk] = 2269                                          (: 'satisfies' '(' :)
                     or $state[$p:lk] = 2272                                          (: 'self' '(' :)
                     or $state[$p:lk] = 2273                                          (: 'some' '(' :)
                     or $state[$p:lk] = 2277                                          (: 'to' '(' :)
                     or $state[$p:lk] = 2278                                          (: 'treat' '(' :)
                     or $state[$p:lk] = 2280">                                      <!-- 'union' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-FunctionCall($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 80">                                        <!-- 'map' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-MapConstructor($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 42                                            (: '[' :)
                     or $state[$p:lk] = 47">                                        <!-- 'array' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ArrayConstructor($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 40">                                        <!-- '?' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-UnaryLookup($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-FunctionItemExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PrimaryExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production PostfixExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PostfixExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(40, $input, $state)"/>     <!-- S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                                                         '?' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' | 'eq' |
                                                                                         'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                                                         'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' |
                                                                                         'treat' | 'union' | '|' | '||' | '}' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 17                                         (: '(' :)
                      and $state[$p:l1] != 40                                         (: '?' :)
                      and $state[$p:l1] != 42">                                     <!-- '[' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 42">                                <!-- '[' -->
                  <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                  <xsl:variable name="state" select="
                    if ($state[$p:error]) then
                      $state
                    else
                      p:parse-Predicate($input, $state)
                  "/>
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 17">                                <!-- '(' -->
                  <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                  <xsl:variable name="state" select="
                    if ($state[$p:error]) then
                      $state
                    else
                      p:parse-ArgumentList($input, $state)
                  "/>
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                  <xsl:variable name="state" select="
                    if ($state[$p:error]) then
                      $state
                    else
                      p:parse-Lookup($input, $state)
                  "/>
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:sequence select="p:parse-PostfixExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse PostfixExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PostfixExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-PrimaryExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-PostfixExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PostfixExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse StepExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-StepExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 67">                                       <!-- 'function' -->
          <xsl:variable name="state" select="p:lookahead2W(35, $input, $state)"/>   <!-- S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                                                         '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' | 'eq' |
                                                                                         'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                                                         'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' |
                                                                                         'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = (47,                                          (: 'array' :)
                                         80)">                                      <!-- 'map' -->
          <xsl:variable name="state" select="p:lookahead2W(37, $input, $state)"/>   <!-- S^WS | '!' | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | '/' |
                                                                                         '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '[' |
                                                                                         ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' | 'eq' | 'except' |
                                                                                         'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' | 'le' | 'lt' |
                                                                                         'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' | 'treat' |
                                                                                         'union' | '{' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = (44,                                          (: 'ancestor' :)
                                         45,                                          (: 'ancestor-or-self' :)
                                         52,                                          (: 'child' :)
                                         54,                                          (: 'descendant' :)
                                         55,                                          (: 'descendant-or-self' :)
                                         64,                                          (: 'following' :)
                                         65,                                          (: 'following-sibling' :)
                                         82,                                          (: 'namespace' :)
                                         88,                                          (: 'parent' :)
                                         89,                                          (: 'preceding' :)
                                         90,                                          (: 'preceding-sibling' :)
                                         96)">                                      <!-- 'self' -->
          <xsl:variable name="state" select="p:lookahead2W(42, $input, $state)"/>   <!-- S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                                                         '-' | '/' | '//' | ':' | '::' | '<' | '<<' | '<=' | '=' | '=>' | '>' |
                                                                                         '>=' | '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' |
                                                                                         'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = (6,                                           (: URIQualifiedName :)
                                         8,                                           (: QName^Token :)
                                         46,                                          (: 'and' :)
                                         50,                                          (: 'cast' :)
                                         51,                                          (: 'castable' :)
                                         56,                                          (: 'div' :)
                                         59,                                          (: 'else' :)
                                         61,                                          (: 'eq' :)
                                         62,                                          (: 'every' :)
                                         63,                                          (: 'except' :)
                                         66,                                          (: 'for' :)
                                         68,                                          (: 'ge' :)
                                         69,                                          (: 'gt' :)
                                         70,                                          (: 'idiv' :)
                                         73,                                          (: 'instance' :)
                                         74,                                          (: 'intersect' :)
                                         75,                                          (: 'is' :)
                                         77,                                          (: 'le' :)
                                         78,                                          (: 'let' :)
                                         79,                                          (: 'lt' :)
                                         81,                                          (: 'mod' :)
                                         84,                                          (: 'ne' :)
                                         87,                                          (: 'or' :)
                                         92,                                          (: 'return' :)
                                         93,                                          (: 'satisfies' :)
                                         97,                                          (: 'some' :)
                                         101,                                         (: 'to' :)
                                         102,                                         (: 'treat' :)
                                         104)">                                     <!-- 'union' -->
          <xsl:variable name="state" select="p:lookahead2W(38, $input, $state)"/>   <!-- S^WS | '!' | '!=' | '#' | '(' | ('(' ':') | ')' | '*' | '+' | ',' |
                                                                                         '-' | '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' |
                                                                                         '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                                                         'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                                                         'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2                                             (: IntegerLiteral :)
                     or $state[$p:lk] = 3                                             (: DecimalLiteral :)
                     or $state[$p:lk] = 4                                             (: DoubleLiteral :)
                     or $state[$p:lk] = 5                                             (: StringLiteral :)
                     or $state[$p:lk] = 16                                            (: '$' :)
                     or $state[$p:lk] = 17                                            (: '(' :)
                     or $state[$p:lk] = 24                                            (: '.' :)
                     or $state[$p:lk] = 40                                            (: '?' :)
                     or $state[$p:lk] = 42                                            (: '[' :)
                     or $state[$p:lk] = 1926                                          (: URIQualifiedName '#' :)
                     or $state[$p:lk] = 1928                                          (: QName^Token '#' :)
                     or $state[$p:lk] = 1964                                          (: 'ancestor' '#' :)
                     or $state[$p:lk] = 1965                                          (: 'ancestor-or-self' '#' :)
                     or $state[$p:lk] = 1966                                          (: 'and' '#' :)
                     or $state[$p:lk] = 1970                                          (: 'cast' '#' :)
                     or $state[$p:lk] = 1971                                          (: 'castable' '#' :)
                     or $state[$p:lk] = 1972                                          (: 'child' '#' :)
                     or $state[$p:lk] = 1974                                          (: 'descendant' '#' :)
                     or $state[$p:lk] = 1975                                          (: 'descendant-or-self' '#' :)
                     or $state[$p:lk] = 1976                                          (: 'div' '#' :)
                     or $state[$p:lk] = 1979                                          (: 'else' '#' :)
                     or $state[$p:lk] = 1981                                          (: 'eq' '#' :)
                     or $state[$p:lk] = 1982                                          (: 'every' '#' :)
                     or $state[$p:lk] = 1983                                          (: 'except' '#' :)
                     or $state[$p:lk] = 1984                                          (: 'following' '#' :)
                     or $state[$p:lk] = 1985                                          (: 'following-sibling' '#' :)
                     or $state[$p:lk] = 1986                                          (: 'for' '#' :)
                     or $state[$p:lk] = 1988                                          (: 'ge' '#' :)
                     or $state[$p:lk] = 1989                                          (: 'gt' '#' :)
                     or $state[$p:lk] = 1990                                          (: 'idiv' '#' :)
                     or $state[$p:lk] = 1993                                          (: 'instance' '#' :)
                     or $state[$p:lk] = 1994                                          (: 'intersect' '#' :)
                     or $state[$p:lk] = 1995                                          (: 'is' '#' :)
                     or $state[$p:lk] = 1997                                          (: 'le' '#' :)
                     or $state[$p:lk] = 1998                                          (: 'let' '#' :)
                     or $state[$p:lk] = 1999                                          (: 'lt' '#' :)
                     or $state[$p:lk] = 2001                                          (: 'mod' '#' :)
                     or $state[$p:lk] = 2002                                          (: 'namespace' '#' :)
                     or $state[$p:lk] = 2004                                          (: 'ne' '#' :)
                     or $state[$p:lk] = 2007                                          (: 'or' '#' :)
                     or $state[$p:lk] = 2008                                          (: 'parent' '#' :)
                     or $state[$p:lk] = 2009                                          (: 'preceding' '#' :)
                     or $state[$p:lk] = 2010                                          (: 'preceding-sibling' '#' :)
                     or $state[$p:lk] = 2012                                          (: 'return' '#' :)
                     or $state[$p:lk] = 2013                                          (: 'satisfies' '#' :)
                     or $state[$p:lk] = 2016                                          (: 'self' '#' :)
                     or $state[$p:lk] = 2017                                          (: 'some' '#' :)
                     or $state[$p:lk] = 2021                                          (: 'to' '#' :)
                     or $state[$p:lk] = 2022                                          (: 'treat' '#' :)
                     or $state[$p:lk] = 2024                                          (: 'union' '#' :)
                     or $state[$p:lk] = 2182                                          (: URIQualifiedName '(' :)
                     or $state[$p:lk] = 2184                                          (: QName^Token '(' :)
                     or $state[$p:lk] = 2220                                          (: 'ancestor' '(' :)
                     or $state[$p:lk] = 2221                                          (: 'ancestor-or-self' '(' :)
                     or $state[$p:lk] = 2222                                          (: 'and' '(' :)
                     or $state[$p:lk] = 2226                                          (: 'cast' '(' :)
                     or $state[$p:lk] = 2227                                          (: 'castable' '(' :)
                     or $state[$p:lk] = 2228                                          (: 'child' '(' :)
                     or $state[$p:lk] = 2230                                          (: 'descendant' '(' :)
                     or $state[$p:lk] = 2231                                          (: 'descendant-or-self' '(' :)
                     or $state[$p:lk] = 2232                                          (: 'div' '(' :)
                     or $state[$p:lk] = 2235                                          (: 'else' '(' :)
                     or $state[$p:lk] = 2237                                          (: 'eq' '(' :)
                     or $state[$p:lk] = 2238                                          (: 'every' '(' :)
                     or $state[$p:lk] = 2239                                          (: 'except' '(' :)
                     or $state[$p:lk] = 2240                                          (: 'following' '(' :)
                     or $state[$p:lk] = 2241                                          (: 'following-sibling' '(' :)
                     or $state[$p:lk] = 2242                                          (: 'for' '(' :)
                     or $state[$p:lk] = 2243                                          (: 'function' '(' :)
                     or $state[$p:lk] = 2244                                          (: 'ge' '(' :)
                     or $state[$p:lk] = 2245                                          (: 'gt' '(' :)
                     or $state[$p:lk] = 2246                                          (: 'idiv' '(' :)
                     or $state[$p:lk] = 2249                                          (: 'instance' '(' :)
                     or $state[$p:lk] = 2250                                          (: 'intersect' '(' :)
                     or $state[$p:lk] = 2251                                          (: 'is' '(' :)
                     or $state[$p:lk] = 2253                                          (: 'le' '(' :)
                     or $state[$p:lk] = 2254                                          (: 'let' '(' :)
                     or $state[$p:lk] = 2255                                          (: 'lt' '(' :)
                     or $state[$p:lk] = 2257                                          (: 'mod' '(' :)
                     or $state[$p:lk] = 2258                                          (: 'namespace' '(' :)
                     or $state[$p:lk] = 2260                                          (: 'ne' '(' :)
                     or $state[$p:lk] = 2263                                          (: 'or' '(' :)
                     or $state[$p:lk] = 2264                                          (: 'parent' '(' :)
                     or $state[$p:lk] = 2265                                          (: 'preceding' '(' :)
                     or $state[$p:lk] = 2266                                          (: 'preceding-sibling' '(' :)
                     or $state[$p:lk] = 2268                                          (: 'return' '(' :)
                     or $state[$p:lk] = 2269                                          (: 'satisfies' '(' :)
                     or $state[$p:lk] = 2272                                          (: 'self' '(' :)
                     or $state[$p:lk] = 2273                                          (: 'some' '(' :)
                     or $state[$p:lk] = 2277                                          (: 'to' '(' :)
                     or $state[$p:lk] = 2278                                          (: 'treat' '(' :)
                     or $state[$p:lk] = 2280                                          (: 'union' '(' :)
                     or $state[$p:lk] = 13487                                         (: 'array' '{' :)
                     or $state[$p:lk] = 13520">                                     <!-- 'map' '{' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-PostfixExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AxisStep($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'StepExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production RelativePathExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-RelativePathExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 26                                         (: '/' :)
                      and $state[$p:l1] != 27">                                     <!-- '//' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 26">                                <!-- '/' -->
                  <xsl:variable name="state" select="p:consume(26, $input, $state)"/> <!-- '/' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(27, $input, $state)"/> <!-- '//' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" select="p:lookahead1W(52, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '.' | '..' | '?' | '@' | '[' | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-StepExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-RelativePathExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse RelativePathExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-RelativePathExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-StepExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-RelativePathExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'RelativePathExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse PathExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-PathExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 26">                                        <!-- '/' -->
          <xsl:variable name="state" select="p:consume(26, $input, $state)"/>       <!-- '/' -->
          <xsl:variable name="state" select="p:lookahead1W(58, $input, $state)"/>   <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '!' | '!=' | '$' |
                                                                                         '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | '.' | '..' | ':' |
                                                                                         '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | '?' | '@' | '[' |
                                                                                         ']' | 'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' | '|' | '||' | '}' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 13                                      (: '!' :)
                           or $state[$p:l1] = 14                                      (: '!=' :)
                           or $state[$p:l1] = 19                                      (: ')' :)
                           or $state[$p:l1] = 20                                      (: '*' :)
                           or $state[$p:l1] = 21                                      (: '+' :)
                           or $state[$p:l1] = 22                                      (: ',' :)
                           or $state[$p:l1] = 23                                      (: '-' :)
                           or $state[$p:l1] = 28                                      (: ':' :)
                           or $state[$p:l1] = 32                                      (: '&lt;' :)
                           or $state[$p:l1] = 33                                      (: '&lt;&lt;' :)
                           or $state[$p:l1] = 34                                      (: '&lt;=' :)
                           or $state[$p:l1] = 35                                      (: '=' :)
                           or $state[$p:l1] = 36                                      (: '=>' :)
                           or $state[$p:l1] = 37                                      (: '>' :)
                           or $state[$p:l1] = 38                                      (: '>=' :)
                           or $state[$p:l1] = 39                                      (: '>>' :)
                           or $state[$p:l1] = 43                                      (: ']' :)
                           or $state[$p:l1] = 106                                     (: '|' :)
                           or $state[$p:l1] = 107                                     (: '||' :)
                           or $state[$p:l1] = 108">                                 <!-- '}' -->
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-RelativePathExpr($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 27">                                        <!-- '//' -->
          <xsl:variable name="state" select="p:consume(27, $input, $state)"/>       <!-- '//' -->
          <xsl:variable name="state" select="p:lookahead1W(52, $input, $state)"/>   <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '.' | '..' | '?' | '@' | '[' | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-RelativePathExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-RelativePathExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'PathExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production SimpleMapExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleMapExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 13">                                     <!-- '!' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(13, $input, $state)"/>     <!-- '!' -->
            <xsl:variable name="state" select="p:lookahead1W(53, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '.' | '..' | '/' | '//' | '?' | '@' | '[' | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-PathExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-SimpleMapExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse SimpleMapExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleMapExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-PathExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-SimpleMapExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SimpleMapExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ValueExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ValueExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SimpleMapExpr($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ValueExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production UnaryExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-UnaryExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>     <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 21                                         (: '+' :)
                      and $state[$p:l1] != 23">                                     <!-- '-' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 23">                                <!-- '-' -->
                  <xsl:variable name="state" select="p:consume(23, $input, $state)"/> <!-- '-' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(21, $input, $state)"/> <!-- '+' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:sequence select="p:parse-UnaryExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse UnaryExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-UnaryExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:parse-UnaryExpr-1($input, $state)"/>
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ValueExpr($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'UnaryExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production ArrowExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArrowExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(33, $input, $state)"/>     <!-- S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' | '<' |
                                                                                         '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' | ']' | 'and' | 'cast' |
                                                                                         'castable' | 'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' |
                                                                                         'instance' | 'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' |
                                                                                         'return' | 'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' |
                                                                                         '}' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 36">                                     <!-- '=>' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(36, $input, $state)"/>     <!-- '=>' -->
            <xsl:variable name="state" select="p:lookahead1W(47, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | '$' | '(' | ('(' ':') |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ArrowFunctionSpecifier($input, $state)
            "/>
            <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>  <!-- S^WS | '(' | ('(' ':') -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ArgumentList($input, $state)
            "/>
            <xsl:sequence select="p:parse-ArrowExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse ArrowExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ArrowExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-UnaryExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-ArrowExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ArrowExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse CastExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-CastExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ArrowExpr($input, $state)
    "/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 50">                                        <!-- 'cast' -->
          <xsl:variable name="state" select="p:consume(50, $input, $state)"/>       <!-- 'cast' -->
          <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>    <!-- S^WS | ('(' ':') | 'as' -->
          <xsl:variable name="state" select="p:consume(48, $input, $state)"/>       <!-- 'as' -->
          <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SingleType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'CastExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse CastableExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-CastableExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-CastExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(30, $input, $state)"/>         <!-- S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' | '<' |
                                                                                         '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' | 'castable' |
                                                                                         'div' | 'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' | '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 51">                                        <!-- 'castable' -->
          <xsl:variable name="state" select="p:consume(51, $input, $state)"/>       <!-- 'castable' -->
          <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>    <!-- S^WS | ('(' ':') | 'as' -->
          <xsl:variable name="state" select="p:consume(48, $input, $state)"/>       <!-- 'as' -->
          <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SingleType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'CastableExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse TreatExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-TreatExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-CastableExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(28, $input, $state)"/>         <!-- S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' | '<' |
                                                                                         '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                                                         'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                                                         'to' | 'treat' | 'union' | '|' | '||' | '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 102">                                       <!-- 'treat' -->
          <xsl:variable name="state" select="p:consume(102, $input, $state)"/>      <!-- 'treat' -->
          <xsl:variable name="state" select="p:lookahead1W(9, $input, $state)"/>    <!-- S^WS | ('(' ':') | 'as' -->
          <xsl:variable name="state" select="p:consume(48, $input, $state)"/>       <!-- 'as' -->
          <xsl:variable name="state" select="p:lookahead1W(45, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SequenceType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'TreatExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse InstanceofExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-InstanceofExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-TreatExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(27, $input, $state)"/>         <!-- S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' | '<' |
                                                                                         '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' |
                                                                                         'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' |
                                                                                         'to' | 'union' | '|' | '||' | '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 73">                                        <!-- 'instance' -->
          <xsl:variable name="state" select="p:consume(73, $input, $state)"/>       <!-- 'instance' -->
          <xsl:variable name="state" select="p:lookahead1W(11, $input, $state)"/>   <!-- S^WS | ('(' ':') | 'of' -->
          <xsl:variable name="state" select="p:consume(86, $input, $state)"/>       <!-- 'of' -->
          <xsl:variable name="state" select="p:lookahead1W(45, $input, $state)"/>   <!-- URIQualifiedName | QName^Token | S^WS | '(' | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-SequenceType($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'InstanceofExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production IntersectExceptExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-IntersectExceptExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(26, $input, $state)"/>     <!-- S^WS | '!=' | ('(' ':') | ')' | '*' | '+' | ',' | '-' | ':' | '<' |
                                                                                         '<<' | '<=' | '=' | '>' | '>=' | '>>' | ']' | 'and' | 'div' | 'else' |
                                                                                         'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'intersect' | 'is' | 'le' |
                                                                                         'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' | 'union' |
                                                                                         '|' | '||' | '}' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 63                                         (: 'except' :)
                      and $state[$p:l1] != 74">                                     <!-- 'intersect' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 74">                                <!-- 'intersect' -->
                  <xsl:variable name="state" select="p:consume(74, $input, $state)"/> <!-- 'intersect' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(63, $input, $state)"/> <!-- 'except' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-InstanceofExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-IntersectExceptExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse IntersectExceptExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-IntersectExceptExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-InstanceofExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-IntersectExceptExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'IntersectExceptExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production UnionExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-UnionExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 104                                        (: 'union' :)
                      and $state[$p:l1] != 106">                                    <!-- '|' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 104">                               <!-- 'union' -->
                  <xsl:variable name="state" select="p:consume(104, $input, $state)"/> <!-- 'union' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(106, $input, $state)"/> <!-- '|' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-IntersectExceptExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-UnionExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse UnionExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-UnionExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-IntersectExceptExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-UnionExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'UnionExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production MultiplicativeExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MultiplicativeExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 20                                         (: '*' :)
                      and $state[$p:l1] != 56                                         (: 'div' :)
                      and $state[$p:l1] != 70                                         (: 'idiv' :)
                      and $state[$p:l1] != 81">                                     <!-- 'mod' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 20">                                <!-- '*' -->
                  <xsl:variable name="state" select="p:consume(20, $input, $state)"/> <!-- '*' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 56">                                <!-- 'div' -->
                  <xsl:variable name="state" select="p:consume(56, $input, $state)"/> <!-- 'div' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 70">                                <!-- 'idiv' -->
                  <xsl:variable name="state" select="p:consume(70, $input, $state)"/> <!-- 'idiv' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(81, $input, $state)"/> <!-- 'mod' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-UnionExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-MultiplicativeExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse MultiplicativeExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-MultiplicativeExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-UnionExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-MultiplicativeExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'MultiplicativeExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production AdditiveExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AdditiveExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 21                                         (: '+' :)
                      and $state[$p:l1] != 23">                                     <!-- '-' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" as="item()+">
              <xsl:choose>
                <xsl:when test="$state[$p:error]">
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:when test="$state[$p:l1] = 21">                                <!-- '+' -->
                  <xsl:variable name="state" select="p:consume(21, $input, $state)"/> <!-- '+' -->
                  <xsl:sequence select="$state"/>
                </xsl:when>
                <xsl:otherwise>
                  <xsl:variable name="state" select="p:consume(23, $input, $state)"/> <!-- '-' -->
                  <xsl:sequence select="$state"/>
                </xsl:otherwise>
              </xsl:choose>
            </xsl:variable>
            <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-MultiplicativeExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-AdditiveExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse AdditiveExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AdditiveExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-MultiplicativeExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-AdditiveExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AdditiveExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse RangeExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-RangeExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AdditiveExpr($input, $state)
    "/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 101">                                       <!-- 'to' -->
          <xsl:variable name="state" select="p:consume(101, $input, $state)"/>      <!-- 'to' -->
          <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>   <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-AdditiveExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'RangeExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production StringConcatExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-StringConcatExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 107">                                    <!-- '||' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(107, $input, $state)"/>    <!-- '||' -->
            <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-RangeExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-StringConcatExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse StringConcatExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-StringConcatExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-RangeExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-StringConcatExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'StringConcatExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ComparisonExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ComparisonExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-StringConcatExpr($input, $state)
    "/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 19                                           (: ')' :)
                    and $state[$p:l1] != 22                                           (: ',' :)
                    and $state[$p:l1] != 28                                           (: ':' :)
                    and $state[$p:l1] != 43                                           (: ']' :)
                    and $state[$p:l1] != 46                                           (: 'and' :)
                    and $state[$p:l1] != 59                                           (: 'else' :)
                    and $state[$p:l1] != 87                                           (: 'or' :)
                    and $state[$p:l1] != 92                                           (: 'return' :)
                    and $state[$p:l1] != 93                                           (: 'satisfies' :)
                    and $state[$p:l1] != 108">                                      <!-- '}' -->
          <xsl:variable name="state" as="item()+">
            <xsl:choose>
              <xsl:when test="$state[$p:error]">
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 61                                      (: 'eq' :)
                           or $state[$p:l1] = 68                                      (: 'ge' :)
                           or $state[$p:l1] = 69                                      (: 'gt' :)
                           or $state[$p:l1] = 77                                      (: 'le' :)
                           or $state[$p:l1] = 79                                      (: 'lt' :)
                           or $state[$p:l1] = 84">                                  <!-- 'ne' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-ValueComp($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:when test="$state[$p:l1] = 33                                      (: '&lt;&lt;' :)
                           or $state[$p:l1] = 39                                      (: '>>' :)
                           or $state[$p:l1] = 75">                                  <!-- 'is' -->
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-NodeComp($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:variable name="state" select="p:whitespace($input, $state)"/>
                <xsl:variable name="state" select="
                  if ($state[$p:error]) then
                    $state
                  else
                    p:parse-GeneralComp($input, $state)
                "/>
                <xsl:sequence select="$state"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:variable>
          <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>   <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-StringConcatExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ComparisonExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production AndExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AndExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 46">                                     <!-- 'and' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(46, $input, $state)"/>     <!-- 'and' -->
            <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ComparisonExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-AndExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse AndExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AndExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ComparisonExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-AndExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AndExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production OrExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-OrExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 87">                                     <!-- 'or' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(87, $input, $state)"/>     <!-- 'or' -->
            <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-AndExpr($input, $state)
            "/>
            <xsl:sequence select="p:parse-OrExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse OrExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-OrExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AndExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-OrExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'OrExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse IfExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-IfExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(71, $input, $state)"/>             <!-- 'if' -->
    <xsl:variable name="state" select="p:lookahead1W(3, $input, $state)"/>          <!-- S^WS | '(' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(17, $input, $state)"/>             <!-- '(' -->
    <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-Expr($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(19, $input, $state)"/>             <!-- ')' -->
    <xsl:variable name="state" select="p:lookahead1W(12, $input, $state)"/>         <!-- S^WS | ('(' ':') | 'then' -->
    <xsl:variable name="state" select="p:consume(100, $input, $state)"/>            <!-- 'then' -->
    <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(59, $input, $state)"/>             <!-- 'else' -->
    <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'IfExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production QuantifiedExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-QuantifiedExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>  <!-- S^WS | '$' | ('(' ':') -->
            <xsl:variable name="state" select="p:consume(16, $input, $state)"/>     <!-- '$' -->
            <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/> <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-VarName($input, $state)
            "/>
            <xsl:variable name="state" select="p:lookahead1W(10, $input, $state)"/> <!-- S^WS | ('(' ':') | 'in' -->
            <xsl:variable name="state" select="p:consume(72, $input, $state)"/>     <!-- 'in' -->
            <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ExprSingle($input, $state)
            "/>
            <xsl:sequence select="p:parse-QuantifiedExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse QuantifiedExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-QuantifiedExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 97">                                        <!-- 'some' -->
          <xsl:variable name="state" select="p:consume(97, $input, $state)"/>       <!-- 'some' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(62, $input, $state)"/>       <!-- 'every' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>          <!-- S^WS | '$' | ('(' ':') -->
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '$' -->
    <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-VarName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(10, $input, $state)"/>         <!-- S^WS | ('(' ':') | 'in' -->
    <xsl:variable name="state" select="p:consume(72, $input, $state)"/>             <!-- 'in' -->
    <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-QuantifiedExpr-1($input, $state)"/>
    <xsl:variable name="state" select="p:consume(93, $input, $state)"/>             <!-- 'satisfies' -->
    <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'QuantifiedExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SimpleLetBinding.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleLetBinding" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '$' -->
    <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-VarName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(8, $input, $state)"/>          <!-- S^WS | ('(' ':') | ':=' -->
    <xsl:variable name="state" select="p:consume(31, $input, $state)"/>             <!-- ':=' -->
    <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SimpleLetBinding', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production SimpleLetClause (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleLetClause-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>  <!-- S^WS | '$' | ('(' ':') -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-SimpleLetBinding($input, $state)
            "/>
            <xsl:sequence select="p:parse-SimpleLetClause-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse SimpleLetClause.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleLetClause" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(78, $input, $state)"/>             <!-- 'let' -->
    <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>          <!-- S^WS | '$' | ('(' ':') -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SimpleLetBinding($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-SimpleLetClause-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SimpleLetClause', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse LetExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-LetExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SimpleLetClause($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(92, $input, $state)"/>             <!-- 'return' -->
    <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'LetExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse FunctionName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-FunctionName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 8">                                         <!-- QName^Token -->
          <xsl:variable name="state" select="p:consume(8, $input, $state)"/>        <!-- QName^Token -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 44">                                        <!-- 'ancestor' -->
          <xsl:variable name="state" select="p:consume(44, $input, $state)"/>       <!-- 'ancestor' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 45">                                        <!-- 'ancestor-or-self' -->
          <xsl:variable name="state" select="p:consume(45, $input, $state)"/>       <!-- 'ancestor-or-self' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 46">                                        <!-- 'and' -->
          <xsl:variable name="state" select="p:consume(46, $input, $state)"/>       <!-- 'and' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 50">                                        <!-- 'cast' -->
          <xsl:variable name="state" select="p:consume(50, $input, $state)"/>       <!-- 'cast' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 51">                                        <!-- 'castable' -->
          <xsl:variable name="state" select="p:consume(51, $input, $state)"/>       <!-- 'castable' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 52">                                        <!-- 'child' -->
          <xsl:variable name="state" select="p:consume(52, $input, $state)"/>       <!-- 'child' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 54">                                        <!-- 'descendant' -->
          <xsl:variable name="state" select="p:consume(54, $input, $state)"/>       <!-- 'descendant' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 55">                                        <!-- 'descendant-or-self' -->
          <xsl:variable name="state" select="p:consume(55, $input, $state)"/>       <!-- 'descendant-or-self' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 56">                                        <!-- 'div' -->
          <xsl:variable name="state" select="p:consume(56, $input, $state)"/>       <!-- 'div' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 59">                                        <!-- 'else' -->
          <xsl:variable name="state" select="p:consume(59, $input, $state)"/>       <!-- 'else' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 61">                                        <!-- 'eq' -->
          <xsl:variable name="state" select="p:consume(61, $input, $state)"/>       <!-- 'eq' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 62">                                        <!-- 'every' -->
          <xsl:variable name="state" select="p:consume(62, $input, $state)"/>       <!-- 'every' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 63">                                        <!-- 'except' -->
          <xsl:variable name="state" select="p:consume(63, $input, $state)"/>       <!-- 'except' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 64">                                        <!-- 'following' -->
          <xsl:variable name="state" select="p:consume(64, $input, $state)"/>       <!-- 'following' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 65">                                        <!-- 'following-sibling' -->
          <xsl:variable name="state" select="p:consume(65, $input, $state)"/>       <!-- 'following-sibling' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 66">                                        <!-- 'for' -->
          <xsl:variable name="state" select="p:consume(66, $input, $state)"/>       <!-- 'for' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 68">                                        <!-- 'ge' -->
          <xsl:variable name="state" select="p:consume(68, $input, $state)"/>       <!-- 'ge' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 69">                                        <!-- 'gt' -->
          <xsl:variable name="state" select="p:consume(69, $input, $state)"/>       <!-- 'gt' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 70">                                        <!-- 'idiv' -->
          <xsl:variable name="state" select="p:consume(70, $input, $state)"/>       <!-- 'idiv' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 73">                                        <!-- 'instance' -->
          <xsl:variable name="state" select="p:consume(73, $input, $state)"/>       <!-- 'instance' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 74">                                        <!-- 'intersect' -->
          <xsl:variable name="state" select="p:consume(74, $input, $state)"/>       <!-- 'intersect' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 75">                                        <!-- 'is' -->
          <xsl:variable name="state" select="p:consume(75, $input, $state)"/>       <!-- 'is' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 77">                                        <!-- 'le' -->
          <xsl:variable name="state" select="p:consume(77, $input, $state)"/>       <!-- 'le' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 78">                                        <!-- 'let' -->
          <xsl:variable name="state" select="p:consume(78, $input, $state)"/>       <!-- 'let' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 79">                                        <!-- 'lt' -->
          <xsl:variable name="state" select="p:consume(79, $input, $state)"/>       <!-- 'lt' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 81">                                        <!-- 'mod' -->
          <xsl:variable name="state" select="p:consume(81, $input, $state)"/>       <!-- 'mod' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 82">                                        <!-- 'namespace' -->
          <xsl:variable name="state" select="p:consume(82, $input, $state)"/>       <!-- 'namespace' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 84">                                        <!-- 'ne' -->
          <xsl:variable name="state" select="p:consume(84, $input, $state)"/>       <!-- 'ne' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 87">                                        <!-- 'or' -->
          <xsl:variable name="state" select="p:consume(87, $input, $state)"/>       <!-- 'or' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 88">                                        <!-- 'parent' -->
          <xsl:variable name="state" select="p:consume(88, $input, $state)"/>       <!-- 'parent' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 89">                                        <!-- 'preceding' -->
          <xsl:variable name="state" select="p:consume(89, $input, $state)"/>       <!-- 'preceding' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 90">                                        <!-- 'preceding-sibling' -->
          <xsl:variable name="state" select="p:consume(90, $input, $state)"/>       <!-- 'preceding-sibling' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 92">                                        <!-- 'return' -->
          <xsl:variable name="state" select="p:consume(92, $input, $state)"/>       <!-- 'return' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 93">                                        <!-- 'satisfies' -->
          <xsl:variable name="state" select="p:consume(93, $input, $state)"/>       <!-- 'satisfies' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 96">                                        <!-- 'self' -->
          <xsl:variable name="state" select="p:consume(96, $input, $state)"/>       <!-- 'self' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 97">                                        <!-- 'some' -->
          <xsl:variable name="state" select="p:consume(97, $input, $state)"/>       <!-- 'some' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 101">                                       <!-- 'to' -->
          <xsl:variable name="state" select="p:consume(101, $input, $state)"/>      <!-- 'to' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 102">                                       <!-- 'treat' -->
          <xsl:variable name="state" select="p:consume(102, $input, $state)"/>      <!-- 'treat' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="p:consume(104, $input, $state)"/>      <!-- 'union' -->
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'FunctionName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse QName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-QName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 47">                                        <!-- 'array' -->
          <xsl:variable name="state" select="p:consume(47, $input, $state)"/>       <!-- 'array' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 49">                                        <!-- 'attribute' -->
          <xsl:variable name="state" select="p:consume(49, $input, $state)"/>       <!-- 'attribute' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 53">                                        <!-- 'comment' -->
          <xsl:variable name="state" select="p:consume(53, $input, $state)"/>       <!-- 'comment' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 57">                                        <!-- 'document-node' -->
          <xsl:variable name="state" select="p:consume(57, $input, $state)"/>       <!-- 'document-node' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 58">                                        <!-- 'element' -->
          <xsl:variable name="state" select="p:consume(58, $input, $state)"/>       <!-- 'element' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 60">                                        <!-- 'empty-sequence' -->
          <xsl:variable name="state" select="p:consume(60, $input, $state)"/>       <!-- 'empty-sequence' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 67">                                        <!-- 'function' -->
          <xsl:variable name="state" select="p:consume(67, $input, $state)"/>       <!-- 'function' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 71">                                        <!-- 'if' -->
          <xsl:variable name="state" select="p:consume(71, $input, $state)"/>       <!-- 'if' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 76">                                        <!-- 'item' -->
          <xsl:variable name="state" select="p:consume(76, $input, $state)"/>       <!-- 'item' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 80">                                        <!-- 'map' -->
          <xsl:variable name="state" select="p:consume(80, $input, $state)"/>       <!-- 'map' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 83">                                        <!-- 'namespace-node' -->
          <xsl:variable name="state" select="p:consume(83, $input, $state)"/>       <!-- 'namespace-node' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 85">                                        <!-- 'node' -->
          <xsl:variable name="state" select="p:consume(85, $input, $state)"/>       <!-- 'node' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 91">                                        <!-- 'processing-instruction' -->
          <xsl:variable name="state" select="p:consume(91, $input, $state)"/>       <!-- 'processing-instruction' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 94">                                        <!-- 'schema-attribute' -->
          <xsl:variable name="state" select="p:consume(94, $input, $state)"/>       <!-- 'schema-attribute' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 95">                                        <!-- 'schema-element' -->
          <xsl:variable name="state" select="p:consume(95, $input, $state)"/>       <!-- 'schema-element' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 98">                                        <!-- 'switch' -->
          <xsl:variable name="state" select="p:consume(98, $input, $state)"/>       <!-- 'switch' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 99">                                        <!-- 'text' -->
          <xsl:variable name="state" select="p:consume(99, $input, $state)"/>       <!-- 'text' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 103">                                       <!-- 'typeswitch' -->
          <xsl:variable name="state" select="p:consume(103, $input, $state)"/>      <!-- 'typeswitch' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-FunctionName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'QName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse EQName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-EQName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = 6">                                         <!-- URIQualifiedName -->
          <xsl:variable name="state" select="p:consume(6, $input, $state)"/>        <!-- URIQualifiedName -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-QName($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'EQName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse VarName.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-VarName" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-EQName($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'VarName', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse SimpleForBinding.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleForBinding" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(16, $input, $state)"/>             <!-- '$' -->
    <xsl:variable name="state" select="p:lookahead1W(43, $input, $state)"/>         <!-- URIQualifiedName | QName^Token | S^WS | ('(' ':') | 'ancestor' |
                                                                                         'ancestor-or-self' | 'and' | 'array' | 'attribute' | 'cast' |
                                                                                         'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-VarName($input, $state)
    "/>
    <xsl:variable name="state" select="p:lookahead1W(10, $input, $state)"/>         <!-- S^WS | ('(' ':') | 'in' -->
    <xsl:variable name="state" select="p:consume(72, $input, $state)"/>             <!-- 'in' -->
    <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SimpleForBinding', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production SimpleForClause (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleForClause-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>  <!-- S^WS | '$' | ('(' ':') -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-SimpleForBinding($input, $state)
            "/>
            <xsl:sequence select="p:parse-SimpleForClause-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse SimpleForClause.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-SimpleForClause" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(66, $input, $state)"/>             <!-- 'for' -->
    <xsl:variable name="state" select="p:lookahead1W(2, $input, $state)"/>          <!-- S^WS | '$' | ('(' ':') -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SimpleForBinding($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-SimpleForClause-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'SimpleForClause', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ForExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ForExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-SimpleForClause($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(92, $input, $state)"/>             <!-- 'return' -->
    <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ForExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse ExprSingle.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-ExprSingle" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:l1] eq 71">                                       <!-- 'if' -->
          <xsl:variable name="state" select="p:lookahead2W(35, $input, $state)"/>   <!-- S^WS | '!' | '!=' | '(' | ('(' ':') | ')' | '*' | '+' | ',' | '-' |
                                                                                         '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' | '>=' | '>>' |
                                                                                         '[' | ']' | 'and' | 'cast' | 'castable' | 'div' | 'else' | 'eq' |
                                                                                         'except' | 'ge' | 'gt' | 'idiv' | 'instance' | 'intersect' | 'is' |
                                                                                         'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' | 'satisfies' | 'to' |
                                                                                         'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] = (62,                                          (: 'every' :)
                                         66,                                          (: 'for' :)
                                         78,                                          (: 'let' :)
                                         97)">                                      <!-- 'some' -->
          <xsl:variable name="state" select="p:lookahead2W(41, $input, $state)"/>   <!-- S^WS | '!' | '!=' | '#' | '$' | '(' | ('(' ':') | ')' | '*' | '+' |
                                                                                         ',' | '-' | '/' | '//' | ':' | '<' | '<<' | '<=' | '=' | '=>' | '>' |
                                                                                         '>=' | '>>' | '[' | ']' | 'and' | 'cast' | 'castable' | 'div' |
                                                                                         'else' | 'eq' | 'except' | 'ge' | 'gt' | 'idiv' | 'instance' |
                                                                                         'intersect' | 'is' | 'le' | 'lt' | 'mod' | 'ne' | 'or' | 'return' |
                                                                                         'satisfies' | 'to' | 'treat' | 'union' | '|' | '||' | '}' -->
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state[$p:l1], subsequence($state, $p:lk + 1)"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2114">                                      <!-- 'for' '$' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-ForExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2126">                                      <!-- 'let' '$' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-LetExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2110                                          (: 'every' '$' :)
                     or $state[$p:lk] = 2145">                                      <!-- 'some' '$' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-QuantifiedExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:lk] = 2247">                                      <!-- 'if' '(' -->
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-IfExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-OrExpr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'ExprSingle', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production Expr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Expr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 22">                                     <!-- ',' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(22, $input, $state)"/>     <!-- ',' -->
            <xsl:variable name="state" select="p:lookahead1W(54, $input, $state)"/> <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-ExprSingle($input, $state)
            "/>
            <xsl:sequence select="p:parse-Expr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse Expr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-Expr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-ExprSingle($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-Expr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'Expr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AVTVar.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AVTVar" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:consume(105, $input, $state)"/>            <!-- '{' -->
    <xsl:variable name="state" select="p:lookahead1W(57, $input, $state)"/>         <!-- IntegerLiteral | DecimalLiteral | DoubleLiteral | StringLiteral |
                                                                                         URIQualifiedName | QName^Token | S^WS | Wildcard | '$' | '(' |
                                                                                         ('(' ':') | '+' | '-' | '.' | '..' | '/' | '//' | '?' | '@' | '[' |
                                                                                         'ancestor' | 'ancestor-or-self' | 'and' | 'array' | 'attribute' |
                                                                                         'cast' | 'castable' | 'child' | 'comment' | 'descendant' |
                                                                                         'descendant-or-self' | 'div' | 'document-node' | 'element' | 'else' |
                                                                                         'empty-sequence' | 'eq' | 'every' | 'except' | 'following' |
                                                                                         'following-sibling' | 'for' | 'function' | 'ge' | 'gt' | 'idiv' |
                                                                                         'if' | 'instance' | 'intersect' | 'is' | 'item' | 'le' | 'let' | 'lt' |
                                                                                         'map' | 'mod' | 'namespace' | 'namespace-node' | 'ne' | 'node' | 'or' |
                                                                                         'parent' | 'preceding' | 'preceding-sibling' |
                                                                                         'processing-instruction' | 'return' | 'satisfies' |
                                                                                         'schema-attribute' | 'schema-element' | 'self' | 'some' | 'switch' |
                                                                                         'text' | 'to' | 'treat' | 'typeswitch' | 'union' | '}' -->
    <xsl:variable name="state" as="item()+">
      <xsl:choose>
        <xsl:when test="$state[$p:error]">
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:when test="$state[$p:l1] != 108">                                      <!-- '}' -->
          <xsl:variable name="state" select="p:whitespace($input, $state)"/>
          <xsl:variable name="state" select="
            if ($state[$p:error]) then
              $state
            else
              p:parse-Expr($input, $state)
          "/>
          <xsl:sequence select="$state"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:sequence select="$state"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
    <xsl:variable name="state" select="p:consume(108, $input, $state)"/>            <!-- '}' -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AVTVar', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production AVTFix (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AVTFix-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="state" select="p:lookahead1W(20, $input, $state)"/>     <!-- AVTFixChar | S^WS | EOF | ('(' ':') | '{' -->
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 1">                                      <!-- AVTFixChar -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:consume(1, $input, $state)"/>      <!-- AVTFixChar -->
            <xsl:sequence select="p:parse-AVTFix-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse AVTFix.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AVTFix" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:parse-AVTFix-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AVTFix', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse the 1st loop of production AVTExpr (zero or more). Use
   ! tail recursion for iteratively updating the lexer state.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AVTExpr-1">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:choose>
          <xsl:when test="$state[$p:l1] != 105">                                    <!-- '{' -->
            <xsl:sequence select="$state"/>
          </xsl:when>
          <xsl:otherwise>
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-AVTVar($input, $state)
            "/>
            <xsl:variable name="state" select="p:lookahead1W(20, $input, $state)"/> <!-- AVTFixChar | S^WS | EOF | ('(' ':') | '{' -->
            <xsl:variable name="state" select="p:whitespace($input, $state)"/>
            <xsl:variable name="state" select="
              if ($state[$p:error]) then
                $state
              else
                p:parse-AVTFix($input, $state)
            "/>
            <xsl:sequence select="p:parse-AVTExpr-1($input, $state)"/>
          </xsl:otherwise>
        </xsl:choose>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Parse AVTExpr.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AVTExpr" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AVTFix($input, $state)
    "/>
    <xsl:variable name="state" select="p:parse-AVTExpr-1($input, $state)"/>
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AVTExpr', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Parse AVT.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:parse-AVT" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="count" select="count($state)"/>
    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="state" select="p:lookahead1W(20, $input, $state)"/>         <!-- AVTFixChar | S^WS | EOF | ('(' ':') | '{' -->
    <xsl:variable name="state" select="p:whitespace($input, $state)"/>
    <xsl:variable name="state" select="
      if ($state[$p:error]) then
        $state
      else
        p:parse-AVTExpr($input, $state)
    "/>
    <xsl:variable name="state" select="p:consume(12, $input, $state)"/>             <!-- EOF -->
    <xsl:variable name="end" select="$state[$p:e0]"/>
    <xsl:sequence select="p:reduce($state, 'AVT', $count, $begin, $end)"/>
  </xsl:function>

  <!--~
   ! Create a textual error message from a parsing error.
   !
   ! @param $input the input string.
   ! @param $error the parsing error descriptor.
   ! @return the error message.
  -->
  <xsl:function name="p:error-message" as="xs:string">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="error" as="element(error)"/>

    <xsl:variable name="begin" select="xs:integer($error/@b)"/>
    <xsl:variable name="context" select="string-to-codepoints(substring($input, 1, $begin - 1))"/>
    <xsl:variable name="linefeeds" select="index-of($context, 10)"/>
    <xsl:variable name="line" select="count($linefeeds) + 1"/>
    <xsl:variable name="column" select="($begin - $linefeeds[last()], $begin)[1]"/>
    <xsl:variable name="expected" select="if ($error/@x or $error/@ambiguous-input) then () else p:expected-token-set($error/@s)"/>
    <xsl:sequence select="
      string-join
      (
        (
          if ($error/@o) then
            ('syntax error, found ', $p:TOKEN[$error/@o + 1])
          else
            'lexical analysis failed',
          '&#10;',
          'while expecting ',
          if ($error/@x) then
            $p:TOKEN[$error/@x + 1]
          else
          (
            '['[exists($expected[2])],
            string-join($expected, ', '),
            ']'[exists($expected[2])]
          ),
          '&#10;',
          if ($error/@o or $error/@e = $begin) then
            ()
          else
            ('after successfully scanning ', string($error/@e - $begin), ' characters beginning '),
          'at line ', string($line), ', column ', string($column), ':&#10;',
          '...', substring($input, $begin, 64), '...'
        ),
        ''
      )
    "/>
  </xsl:function>

  <!--~
   ! Consume one token, i.e. compare lookahead token 1 with expected
   ! token and in case of a match, shift lookahead tokens down such that
   ! l1 becomes the current token, and higher lookahead tokens move down.
   ! When lookahead token 1 does not match the expected token, raise an
   ! error by saving the expected token code in the error field of the
   ! lexer state.
   !
   ! @param $code the expected token.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:consume" as="item()+">
    <xsl:param name="code" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:when test="$state[$p:l1] eq $code">
        <xsl:variable name="begin" select="$state[$p:e0]"/>
        <xsl:variable name="end" select="$state[$p:b1]"/>
        <xsl:variable name="whitespace">
          <xsl:if test="$begin ne $end">
            <xsl:value-of select="substring($input, $begin, $end - $begin)"/>
          </xsl:if>
        </xsl:variable>
        <xsl:variable name="token" select="$p:TOKEN[1 + $state[$p:l1]]"/>
        <xsl:variable name="name" select="if (starts-with($token, &quot;'&quot;)) then 'TOKEN' else $token"/>
        <xsl:variable name="begin" select="$state[$p:b1]"/>
        <xsl:variable name="end" select="$state[$p:e1]"/>
        <xsl:variable name="node">
          <xsl:element name="{$name}">
            <xsl:sequence select="substring($input, $begin, $end - $begin)"/>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="
          subsequence($state, $p:l1, 9),
          0, 0, 0,
          subsequence($state, 13),
          $whitespace/node(),
          $node/node()
        "/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="error">
          <xsl:element name="error">
            <xsl:attribute name="b" select="$state[$p:b1]"/>
            <xsl:attribute name="e" select="$state[$p:e1]"/>
            <xsl:choose>
              <xsl:when test="$state[$p:l1] lt 0">
                <xsl:attribute name="s" select="- $state[$p:l1]"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:attribute name="o" select="$state[$p:l1]"/>
                <xsl:attribute name="x" select="$code"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="
          subsequence($state, 1, $p:error - 1),
          $error/node(),
          subsequence($state, $p:error + 1)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Consume one token, i.e. compare lookahead token 1 with expected
   ! token and in case of a match, shift lookahead tokens down such that
   ! l1 becomes the current token, and higher lookahead tokens move down.
   ! When lookahead token 1 does not match the expected token, raise an
   ! error by saving the expected token code in the error field of the
   ! lexer state. In contrast to p:consume, do not create any output.
   !
   ! @param $code the expected token.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:consumeT" as="item()+">
    <xsl:param name="code" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:error]">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:when test="$state[$p:l1] eq $code">
        <xsl:sequence select="
          subsequence($state, $p:l1, 9),
          0, 0, 0,
          subsequence($state, 13)
        "/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="error">
          <xsl:element name="error">
            <xsl:attribute name="b" select="$state[$p:b1]"/>
            <xsl:attribute name="e" select="$state[$p:e1]"/>
            <xsl:choose>
              <xsl:when test="$state[$p:l1] lt 0">
                <xsl:attribute name="s" select="- $state[$p:l1]"/>
              </xsl:when>
              <xsl:otherwise>
                <xsl:attribute name="o" select="$state[$p:l1]"/>
                <xsl:attribute name="x" select="$code"/>
              </xsl:otherwise>
            </xsl:choose>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="
          subsequence($state, 1, $p:error - 1),
          $error/node(),
          subsequence($state, $p:error + 1)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Consume whitespace.
   !
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result.
   ! @return the updated state.
  -->
  <xsl:function name="p:whitespace" as="item()+">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="begin" select="$state[$p:e0]"/>
    <xsl:variable name="end" select="$state[$p:b1]"/>
    <xsl:choose>
      <xsl:when test="$begin eq $end">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="whitespace">
          <xsl:value-of select="substring($input, $begin, $end - $begin)"/>
        </xsl:variable>
        <xsl:sequence select="
          0,
          $state[$p:b0],
          $end,
          subsequence($state, $p:e0 + 1),
          $whitespace/node()
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Use p:match to fetch the next token, but skip any leading
   ! whitespace.
   !
   ! @param $input the input string.
   ! @param $begin the index where to start.
   ! @param $token-set the valid token set id.
   ! @return a sequence of three values: the token code of the result
   ! token, with input string positions of token begin and end.
  -->
  <xsl:function name="p:matchW">
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="token-set" as="xs:integer"/>

    <xsl:variable name="match" select="p:match($input, $begin, $token-set)"/>
    <xsl:choose>
      <xsl:when test="$match[1] = 9">                                               <!-- S^WS -->
        <xsl:sequence select="p:matchW($input, $match[3], $token-set)"/>
      </xsl:when>
      <xsl:when test="$match[1] = 18">                                              <!-- ('(' ':') -->
        <xsl:variable name="state" select="p:try-Whitespace($input, (0, $begin, $begin, $match, 0, 0, 0, 0, 0, 0, false()))"/>
        <xsl:sequence select="p:matchW($input, $state[$p:e0], $token-set)"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="$match"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Lookahead one token on level 1 with whitespace skipping.
   !
   ! @param $set the code of the DFA entry state for the set of valid tokens.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result stack.
   ! @return the updated state.
  -->
  <xsl:function name="p:lookahead1W" as="item()+">
    <xsl:param name="set" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:l1] ne 0">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="match" select="
          p:matchW($input, $state[$p:e0], $set),
          0, 0, 0
        "/>
        <xsl:sequence select="
          $match[1],
          subsequence($state, $p:b0, 2),
          $match,
          subsequence($state, 10)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Lookahead one token on level 2 with whitespace skipping.
   !
   ! @param $set the code of the DFA entry state for the set of valid tokens.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result stack.
   ! @return the updated state.
  -->
  <xsl:function name="p:lookahead2W" as="item()+">
    <xsl:param name="set" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="match" select="
      if ($state[$p:l2] ne 0) then
        subsequence($state, $p:l2, 6)
      else
      (
        p:matchW($input, $state[$p:e1], $set),
        0, 0, 0
      )
    "/>
    <xsl:sequence select="
      $match[1] * 128 + $state[$p:l1],
      subsequence($state, $p:b0, 5),
      $match,
      subsequence($state, 13)
    "/>
  </xsl:function>

  <!--~
   ! Lookahead one token on level 3 with whitespace skipping.
   !
   ! @param $set the code of the DFA entry state for the set of valid tokens.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result stack.
   ! @return the updated state.
  -->
  <xsl:function name="p:lookahead3W" as="item()+">
    <xsl:param name="set" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:variable name="match" select="
      if ($state[$p:l3] ne 0) then
        subsequence($state, $p:l3, 3)
      else
        p:matchW($input, $state[$p:e2], $set)
    "/>
    <xsl:sequence select="
      $match[1] * 16384 + $state[$p:lk],
      subsequence($state, $p:b0, 8),
      $match,
      subsequence($state, 13)
    "/>
  </xsl:function>

  <!--~
   ! Lookahead one token on level 1.
   !
   ! @param $set the code of the DFA entry state for the set of valid tokens.
   ! @param $input the input string.
   ! @param $state lexer state, error indicator, and result stack.
   ! @return the updated state.
  -->
  <xsl:function name="p:lookahead1" as="item()+">
    <xsl:param name="set" as="xs:integer"/>
    <xsl:param name="input" as="xs:string"/>
    <xsl:param name="state" as="item()+"/>

    <xsl:choose>
      <xsl:when test="$state[$p:l1] ne 0">
        <xsl:sequence select="$state"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:variable name="match" select="
          p:match($input, $state[$p:e0], $set),
          0, 0, 0
        "/>
        <xsl:sequence select="
          $match[1],
          subsequence($state, $p:b0, 2),
          $match,
          subsequence($state, 10)
        "/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

  <!--~
   ! Reduce the result stack, creating a nonterminal element. Pop
   ! $count elements off the stack, wrap them in a new element
   ! named $name, and push the new element.
   !
   ! @param $state lexer state, error indicator, and result.
   ! @param $name the name of the result node.
   ! @param $count the number of child nodes.
   ! @param $begin the input index where the nonterminal begins.
   ! @param $end the input index where the nonterminal ends.
   ! @return the updated state.
  -->
  <xsl:function name="p:reduce" as="item()+">
    <xsl:param name="state" as="item()+"/>
    <xsl:param name="name" as="xs:string"/>
    <xsl:param name="count" as="xs:integer"/>
    <xsl:param name="begin" as="xs:integer"/>
    <xsl:param name="end" as="xs:integer"/>

    <xsl:variable name="node">
      <xsl:element name="{$name}">
        <xsl:sequence select="subsequence($state, $count + 1)"/>
      </xsl:element>
    </xsl:variable>
    <xsl:sequence select="subsequence($state, 1, $count), $node/node()"/>
  </xsl:function>

  <!--~
   ! Parse start symbol AVT from given string.
   !
   ! @param $s the string to be parsed.
   ! @return the result as generated by parser actions.
  -->
  <xsl:function name="p:parse-AVT" as="item()*">
    <xsl:param name="s" as="xs:string"/>

    <xsl:variable name="state" select="0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, false()"/>
    <xsl:variable name="state" select="p:parse-AVT($s, $state)"/>
    <xsl:variable name="error" select="$state[$p:error]"/>
    <xsl:choose>
      <xsl:when test="$error">
        <xsl:variable name="ERROR">
          <xsl:element name="ERROR">
            <xsl:sequence select="$error/@*, p:error-message($s, $error)"/>
          </xsl:element>
        </xsl:variable>
        <xsl:sequence select="$ERROR/node()"/>
      </xsl:when>
      <xsl:otherwise>
        <xsl:sequence select="subsequence($state, $p:result)"/>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:function>

</xsl:stylesheet>