<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:math="http://www.w3.org/2005/xpath-functions/math"
    xmlns:axsl="http://www.w3.org/1999/XSL/TransformAlias"
    xmlns:xpt="http://www.nkutsche.com/xmlml/xpath-engine/types"
    xmlns:xpts="http://www.nkutsche.com/xmlml/xpath-engine/types-schema"
    xmlns:xpe="http://www.nkutsche.com/xpath-model/engine"
    xmlns:map="http://www.w3.org/2005/xpath-functions/map"
    exclude-result-prefixes="axsl"
    version="3.0">
    <xsl:namespace-alias result-prefix="xsl" stylesheet-prefix="axsl"/>
    
    <xsl:output indent="yes"/>
    
    <xsl:variable name="this.stylesheet" select="document('')"/>
    <xsl:variable name="namespace-uris" select="$this.stylesheet/*/namespace::*/map{name() : .} => map:merge()"/>
    
    <xsl:template match="/">
        <xsl:comment expand-text="yes">
            This stylesheet is generated by {tokenize(static-base-uri(), '/')[last()]}
            with {tokenize(base-uri(/), '/')[last()]} as input!
        </xsl:comment>
        <axsl:stylesheet version="3.0">
            <axsl:variable name="xpt:type-system">
                <xsl:copy-of select="*"/>
            </axsl:variable>
            <xsl:apply-templates/>
            <xsl:sequence select="$this.stylesheet/*/(xsl:function|xsl:variable)"/>
        </axsl:stylesheet>
    </xsl:template>
    
    <xsl:template match="xpt:type">
        <xsl:variable name="castable" select="(@castable, 'true')[1] = 'true'"/>
        <xsl:variable name="parent-type" select="parent::xpt:type/xpe:eqname(xpe:get-function-name-by-type(.))"/>
        <xsl:variable name="is-simple" select="(ancestor-or-self::*[@simple][1]/@simple, 'false')[1] = 'true'"/>
        
        <xsl:variable name="prefix" select="
            if (starts-with(@name, 'xs:')) then 'xpts' else 'xpt'
            "/>
        <xsl:variable name="name" select="@name"/>
        <xsl:variable name="qname" select="resolve-QName($name, .)"/>
        <xsl:variable name="test-name" select="
            if ($is-simple) 
            then xpe:eqname($qname)
            else $name
            
            "/>
        <xsl:variable name="test" select="ancestor-or-self::*[@test][1]
            ! replace(@test, '\$n', $test-name)
            "/>
        <axsl:function name="{xpe:get-function-name-by-type-name($qname)}" as="map(*)">
            
            <xsl:variable name="error" select="'error(xpe:error-code(''XPST0080''), ''No value is castable to ' || $name ||''')'"/>
            <xsl:variable name="castable-as" select=" 
                if ($is-simple and not($castable)) then $error else '$item castable as ' || $test 
                "/>
            <xsl:variable name="cast-as" select=" 
                if ($is-simple and not($castable)) then $error else '$item cast as ' || $test 
                "/>
            <xsl:variable name="map-body" select="
                '''is-simple'' : ' || $is-simple || '()',
                '''is-castable'' : ' || $castable || '()',
                '''parent-type'' : ' || $parent-type || '()', (: trick: if $parent-type does not exists, this will be an empty sequence otherwise a function call :)
                '''instance-of'' : function($item){$item instance of ' || $test || '}',
                '''treat-as'' : function($item){$item treat as ' || $test || '}',
                ('''cast-as'' : function($item){' || $cast-as || '}')[$is-simple],
                ('''castable-as'' : function($item){' || $castable-as || '}')[$is-simple]
                "/>
            
            <axsl:sequence select="
                map{{
                    {string-join($map-body, ',')}
                }}
                "/>
        </axsl:function>
        <xsl:apply-templates/>
    </xsl:template>
    
    <xsl:function name="xpe:eqname" as="xs:string">
        <xsl:param name="qname" as="xs:QName"/>
        <xsl:sequence select="'Q{' || namespace-uri-from-QName($qname) || '}' || local-name-from-QName($qname)"/>
    </xsl:function>
    
    <xsl:function name="xpe:get-function-name-by-type" as="xs:QName">
        <xsl:param name="type" as="element(xpt:type)"/>
        <xsl:sequence select="xpe:get-function-name-by-type-name(resolve-QName($type/@name, $type))"/>
    </xsl:function>
    
    <xsl:function name="xpe:get-function-name-by-type-name" as="xs:QName">
        <xsl:param name="qname" as="xs:QName"/>
        <xsl:variable name="ns" select="
            namespace-uri-from-QName($qname)
            "/>
        <xsl:variable name="localname" select="
            local-name-from-QName($qname)
            "/>
        <xsl:variable name="prefix" select="if ($ns = $namespace-uris('xs')) 
            then 'xpts' 
            else 'xpt'"/>
        <xsl:sequence select="
            QName($namespace-uris($prefix), $prefix || ':' || $localname)
            "/>
    </xsl:function>
    
    
    
</xsl:stylesheet>